<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест за Напреднали по ООП</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .option-btn {
            transition: all 0.2s ease-in-out;
        }
        .correct {
            background-color: #22c55e !important; /* green-500 */
            color: white !important;
            border-color: #16a34a !important; /* green-600 */
        }
        .incorrect {
            background-color: #ef4444 !important; /* red-500 */
            color: white !important;
            border-color: #dc2626 !important; /* red-600 */
        }
    </style>
</head>
<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 flex items-center justify-center min-h-screen p-4">

    <div id="quiz-container" class="w-full max-w-2xl bg-white dark:bg-slate-800 shadow-2xl rounded-2xl p-6 md:p-8">
        <div id="question-header" class="mb-6">
            <h2 class="text-2xl md:text-3xl font-bold text-slate-900 dark:text-white" id="question-text">Зареждане на въпрос...</h2>
            <p id="question-counter" class="text-sm font-medium text-slate-500 dark:text-slate-400 mt-2">Въпрос 1 от 50</p>
        </div>

        <div id="options-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <!-- Answer options will be generated here -->
        </div>

        <div id="feedback-container" class="hidden min-h-[6rem] p-4 rounded-lg bg-slate-100 dark:bg-slate-700 mb-6">
             <p id="feedback-rationale" class="text-slate-700 dark:text-slate-200"></p>
        </div>

        <div class="flex justify-end">
            <button id="next-btn" class="hidden bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 dark:focus:ring-indigo-800 transition-transform duration-200 transform hover:scale-105">
                Следващ въпрос &rarr;
            </button>
        </div>
        
        <div id="score-container" class="hidden text-center">
            <h2 class="text-3xl font-bold text-slate-900 dark:text-white mb-4">Тестът приключи!</h2>
            <p class="text-xl text-slate-600 dark:text-slate-300 mb-8" id="score-text">Вашият резултат е 0 от 50.</p>
            <button id="restart-btn" class="bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 dark:focus:ring-indigo-800 transition-transform duration-200 transform hover:scale-105">
                Започни отначало
            </button>
        </div>
    </div>

    <script>
        const quizDataRaw = {
            "questions": [
                { "questionNumber": 1, "question": "Ако клас `Manager` наследява `Employee`, а `Employee` има метод `getRole()` връщащ обект от тип `Role`, кое от изброените е валиден `covariant return type` за пренаписания `getRole()` метод в класа `Manager`?", "answerOptions": [ { "text": "Object", "rationale": "Връщането на по-общ тип (`Object`) нарушава принципа на ковариантност, който изисква същия или по-специфичен тип.", "isCorrect": false }, { "text": "ManagerRole (където `ManagerRole` наследява `Role`)", "rationale": "Това е класически пример за ковариантен тип на връщане - подкласът връща по-специфичен тип от този на родителя.", "isCorrect": true }, { "text": "String", "rationale": "Типът `String` не е в йерархията на наследяване на `Role` и следователно е несъвместим.", "isCorrect": false }, { "text": "void", "rationale": "Промяната на типа на връщане на `void` е промяна на сигнатурата и не представлява валидно пренаписване.", "isCorrect": false } ], "hint": "Помислете за правилото, което позволява на пренаписан метод да връща по-специфичен тип." },
                { "questionNumber": 2, "question": "Каква е основната причина един клас да имплементира празен (маркерен) интерфейс като `Cloneable` или `Serializable`?", "answerOptions": [ { "text": "За да наследи `default` методи от интерфейса.", "rationale": "Маркерните интерфейси по дефиниция нямат методи, така че няма какво да се наследи.", "isCorrect": false }, { "text": "За да укаже на JVM, че обектите от този клас поддържат определена семантика или поведение.", "rationale": "Това е същността на маркерния интерфейс - той е 'знак' за JVM или други библиотеки, че класът има определена способност.", "isCorrect": true }, { "text": "За да принуди класа да имплементира методи от `java.lang.Object`.", "rationale": "Всички класове вече наследяват методите на `Object`, независимо от интерфейсите, които имплементират.", "isCorrect": false }, { "text": "За да забрани създаването на инстанции на този клас.", "rationale": "Имплементирането на интерфейс не влияе на възможността за инстанциране; за това се използват абстрактни класове.", "isCorrect": false } ], "hint": "Какво 'съобщава' класът на виртуалната машина, когато имплементира такъв интерфейс?" },
                { "questionNumber": 3, "question": "Ако два различни обекта, които НЕ са равни според `equals()`, връщат един и същ `hashCode()`, какво е най-прякото последствие?", "answerOptions": [ { "text": "Програмата ще даде грешка при компилация.", "rationale": "Това е логически проблем, а не синтактичен, и компилаторът не може да го хване.", "isCorrect": false }, { "text": "Ще се получи `RuntimeException` при добавяне в `HashSet`.", "rationale": "Няма да възникне изключение. Това е валидна, макар и неоптимална ситуация.", "isCorrect": false }, { "text": "Потенциално намаляване на производителността при работа с хеш-базирани колекции.", "rationale": "Това се нарича 'колизия' и води до по-бавно търсене в колекции като `HashMap`, защото се налага обхождане на свързан списък.", "isCorrect": true }, { "text": "Невъзможност за разграничаване на обектите при селекция.", "rationale": "Въпреки колизията в хеш кода, колекцията ще използва `equals()` за финално разграничаване на обектите.", "isCorrect": false } ], "hint": "Как `HashMap` и `HashSet` се справят, когато два различни ключа попаднат в един и същи 'bucket'?" },
                { "questionNumber": 4, "question": "Защо `static` метод в интерфейс не може да бъде пренаписан (overridden) от имплементиращ го клас?", "answerOptions": [ { "text": "Защото статичните методи в интерфейсите са имплицитно `final`.", "rationale": "Въпреки че не могат да бъдат пренаписани, причината не е в `final`, а в самата природа на статичното свързване.", "isCorrect": false }, { "text": "Защото статичните методи принадлежат на самия интерфейс, а не на инстанциите, докато `overriding` е механизъм на runtime полиморфизма за инстанции.", "rationale": "Това е точната причина: `overriding` е свързан с динамично свързване спрямо реалния тип на обекта, а статичните методи се викат чрез статично свързване към типа.", "isCorrect": true }, { "text": "Защото модификаторът за достъп на статичните методи е `private` по подразбиране.", "rationale": "Статичните методи в интерфейсите са `public` по подразбиране.", "isCorrect": false }, { "text": "Защото имплементиращият клас може да има собствен статичен метод със същата сигнатура, който го скрива (hiding).", "rationale": "Това е вярно (method hiding), но описва какво се случва, а не защо `overriding` е невъзможен.", "isCorrect": false } ], "hint": "Свързано ли е извикването на статичен метод с конкретен обект (инстанция)?" },
                { "questionNumber": 5, "question": "Клас `C` имплементира два интерфейса `A` и `B`. И двата интерфейса дефинират `default` метод `void calculate()`. Как `C` може да извика имплементацията от интерфейс `A` вътре в своето собствено пренаписано `calculate()` тяло?", "answerOptions": [ { "text": "super.calculate();", "rationale": "`super.calculate()` би се обърнало към родителски клас, ако има такъв, а не към конкретен интерфейс.", "isCorrect": false }, { "text": "this.A.calculate();", "rationale": "Няма такъв синтаксис в Java за достъп до имплементация на интерфейс.", "isCorrect": false }, { "text": "A.super.calculate();", "rationale": "Това е специфичният синтаксис, предоставен в Java за разрешаване на конфликти при множествено наследяване на поведение, като се указва точно кой `default` метод да се използва.", "isCorrect": true }, { "text": "((A)this).calculate();", "rationale": "Кастването към тип интерфейс би довело до рекурсивно извикване на собствения `calculate()` метод на обекта `C`.", "isCorrect": false } ], "hint": "Потърсете специфичния синтаксис, който Java предоставя за разрешаване на 'диамантения проблем' с default методи." },
                { "questionNumber": 6, "question": "Кое твърдение най-точно описва разликата между `this` и `super` в контекста на извикване на методи?", "answerOptions": [ { "text": "`this` е референция към текущия обект, докато `super` е референция към обекта на родителския клас.", "rationale": "Това е често срещано погрешно схващане. `super` не е референция към обект; обектът е само един.", "isCorrect": false }, { "text": "`this` участва в динамичното свързване (runtime polymorphism), докато `super.method()` е разрешено по време на компилация и заобикаля динамичното свързване.", "rationale": "Точно така. `super` казва на компилатора да започне търсенето на метода от суперкласа, игнорирайки версията в текущия клас.", "isCorrect": true }, { "text": "Използването на `super` е възможно само в абстрактни класове.", "rationale": "`super` се използва във всеки подклас, независимо дали е абстрактен или не.", "isCorrect": false }, { "text": "`this()` извиква конструктор от същия клас, а `super()` извиква метод от родителския клас.", "rationale": "`super()` също извиква конструктор, но от родителския клас. `super.method()` извиква метод.", "isCorrect": false } ], "hint": "Помислете кога се взима решението кой метод да се изпълни - по време на компилация или по време на изпълнение?" },
                { "questionNumber": 7, "question": "В контекста на 'Flexible Constructor Bodies' (Java 22+), какво ограничение се запазва за кода в 'пролога' (преди `this()` или `super()`)?", "answerOptions": [ { "text": "Не може да се присвоява стойност на никоя член-променлива.", "rationale": "Точно обратното, може да се присвоява, но не и да се чете от член-променливи на инстанцията.", "isCorrect": false }, { "text": "Може да се извикват само `private` методи на класа.", "rationale": "Не могат да се извикват никакви нестатични методи, тъй като обектът все още не е напълно конструиран.", "isCorrect": false }, { "text": "Не може да се чете състоянието на инстанцията (достъп до член-променливи).", "rationale": "Това е ключово ограничение, за да се гарантира, че обектът не се използва преди родителската му част да е напълно инициализирана.", "isCorrect": true }, { "text": "Може да се извършват само аритметични операции.", "rationale": "Ограниченията не са свързани с вида на операциите, а с достъпа до състоянието на обекта.", "isCorrect": false } ], "hint": "Какво трябва да се случи задължително, преди да можете безопасно да използвате състоянието на един обект?" },
                { "questionNumber": 8, "question": "Защо един абстрактен клас може да има конструктор, въпреки че не може да бъде инстанциран директно?", "answerOptions": [ { "text": "За да може да бъде инстанциран чрез рефлексия (reflection).", "rationale": "Въпреки че рефлексията позволява много неща, основната цел на конструктора е друга.", "isCorrect": false }, { "text": "За да инициализира статичните си полета.", "rationale": "Статичните полета се инициализират в статични блокове, а не в конструктори на инстанции.", "isCorrect": false }, { "text": "Защото той трябва да бъде извикан (чрез `super()`) от конструкторите на конкретните класове-наследници.", "rationale": "Конструкторът на подкласа винаги трябва да извика конструктор на суперкласа, за да инициализира наследените полета.", "isCorrect": true }, { "text": "Това е остаряла характеристика и няма практическо приложение в модерната Java.", "rationale": "Това е фундаментална и необходима част от механизма на наследяване в Java.", "isCorrect": false } ], "hint": "Как подкласът се грижи за инициализацията на данните, които наследява от своя абстрактен родител?" },
                { "questionNumber": 9, "question": "Кое от следните най-добре описва връзката между compile-time полиморфизъм и runtime полиморфизъм?", "answerOptions": [ { "text": "И двете се постигат чрез наследяване.", "rationale": "Само runtime полиморфизмът разчита на наследяване; compile-time полиморфизмът се постига чрез претоварване (overloading).", "isCorrect": false }, { "text": "Compile-time (статично свързване) се решава от компилатора чрез `overloading`, докато runtime (динамично свързване) се решава от JVM чрез `overriding`.", "rationale": "Това точно разграничава двата вида полиморфизъм, кой ги управлява и чрез какъв механизъм се постигат.", "isCorrect": true }, { "text": "Runtime полиморфизмът е по-бърз, защото решението се взима в последния момент.", "rationale": "Точно обратното, статичното свързване е по-бързо, защото не изисква допълнителна проверка по време на изпълнение.", "isCorrect": false }, { "text": "`final` методите са пример за runtime полиморфизъм.", "rationale": "Тъй като `final` методите не могат да бъдат пренаписани, те винаги се свързват статично (compile-time).", "isCorrect": false } ], "hint": "Кой взима решението (компилаторът или JVM) и на базата на какво (сигнатура на метод или реален тип на обект)?" },
                { "questionNumber": 10, "question": "При пренаписване на метод (method overriding), защо модификаторът за достъп в подкласа не може да бъде по-ограничаващ от този в суперкласа?", "answerOptions": [ { "text": "Защото това би нарушило принципа на Лисков за заместване (Liskov Substitution Principle).", "rationale": "Този принцип гласи, че трябва да можем да използваме обект от подклас навсякъде, където се очаква обект от суперклас. Намаляването на видимостта би 'счупило' този договор.", "isCorrect": true }, { "text": "Защото компилаторът няма как да провери кой метод да извика.", "rationale": "Компилаторът може да го засече като грешка, но причината е в принципите на ООП, а не в техническо ограничение.", "isCorrect": false }, { "text": "Защото води до по-ниска производителност.", "rationale": "Правилото не е свързано с производителността, а с коректността и дизайна на класовата йерархия.", "isCorrect": false }, { "text": "Защото всички наследени методи трябва да са `public`.", "rationale": "Това не е вярно, методите могат да бъдат `protected` или `package-private` и пак да се наследяват и пренаписват.", "isCorrect": false } ], "hint": "Помислете за 'договора', който суперкласът предоставя. Може ли подкласът да предложи 'по-малко' от този договор?" },
                { "questionNumber": 11, "question": "Каква е основната цел на `private` методите, добавени в интерфейсите (Java 9+)?", "answerOptions": [ { "text": "Да позволят на интерфейсите да имат скрито състояние (член-данни).", "rationale": "Интерфейсите все още не могат да имат състояние; `private` методите са без състояние (stateless).", "isCorrect": false }, { "text": "Да се споделя код между `default` методите в един и същ интерфейс, без да се излага тази логика навън.", "rationale": "Те служат като помощни функции за избягване на дублирането на код в рамките на самия интерфейс.", "isCorrect": true }, { "text": "Да се предоставят методи, които могат да бъдат извикани само от класове в същия пакет.", "rationale": "Те са `private` за интерфейса, което означава, че са напълно недостъпни извън него, дори от класове в същия пакет.", "isCorrect": false }, { "text": "Да заменят напълно нуждата от абстрактни класове.", "rationale": "Въпреки че увеличават възможностите на интерфейсите, те не заместват напълно ролята на абстрактните класове (например за споделяне на състояние).", "isCorrect": false } ], "hint": "Как може да се избегне copy-paste на код между няколко `default` метода в един интерфейс?" },
                { "questionNumber": 12, "question": "Кое от следните е пример за имплицитно (`implicit`) създаване на обект?", "answerOptions": [ { "text": "String name = new String(\"John\");", "rationale": "Използването на `new` е дефиницията за експлицитно създаване на обект.", "isCorrect": false }, { "text": "Integer number = 100;", "rationale": "Това е пример за autoboxing, при който компилаторът имплицитно преобразува `int` литерала в `Integer` обект (все едно е извикано `Integer.valueOf(100)`).", "isCorrect": true }, { "text": "StringBuilder sb = new StringBuilder();", "rationale": "Използването на `new` за създаване на `StringBuilder` е експлицитно.", "isCorrect": false }, { "text": "Object obj = new Object();", "rationale": "Това е най-базовият пример за експлицитно създаване на обект.", "isCorrect": false } ], "hint": "Помислете за ситуации, в които компилаторът извършва 'магия' зад кулисите, за да улесни програмиста." },
                { "questionNumber": 13, "question": "Защо се препоръчва използването на `import some.package.SpecificClass;` вместо `import some.package.*;`?", "answerOptions": [ { "text": "Защото импортирането с `*` е значително по-бавно по време на изпълнение.", "rationale": "Няма разлика в производителността по време на изпълнение; JVM зарежда само класовете, които реално се използват.", "isCorrect": false }, { "text": "Защото wildcard импортът може да доведе до двусмислие (ambiguity), ако два пакета съдържат клас с едно и също име.", "rationale": "Това е основният практически проблем. Ако импортирате `java.util.*` и `java.awt.*` и използвате `List`, компилаторът няма да знае кой `List` имате предвид.", "isCorrect": true }, { "text": "Защото wildcard импортът не работи за `static` класове.", "rationale": "Няма такова нещо като `static` клас на топ ниво, а и wildcard импортът работи за всички публични класове.", "isCorrect": false }, { "text": "Защото е остаряла практика и не се поддържа в новите версии на Java.", "rationale": "Wildcard импортът все още е напълно поддържан синтаксис, макар и често непрепоръчителен.", "isCorrect": false } ], "hint": "Какво може да се обърка, ако два различни пакета, които импортирате, дефинират клас с името 'List'?" },
                { "questionNumber": 14, "question": "Какво е основното предимство на полиморфизма, илюстрирано чрез референция от тип суперклас, сочеща към обект от тип подклас (`SuperClass obj = new SubClass()`)?", "answerOptions": [ { "text": "Позволява достъп до всички методи на подкласа, които не съществуват в суперкласа.", "rationale": "Точно обратното. Чрез референция от тип суперклас могат да се викат само методите, дефинирани в суперкласа.", "isCorrect": false }, { "text": "Гарантира по-висока сигурност, като скрива реалния тип на обекта.", "rationale": "Въпреки че типът е абстрахиран, това не е основна цел за сигурност, а за гъвкавост на кода.", "isCorrect": false }, { "text": "Позволява писането на по-гъвкав и разширяем код, който може да работи с различни имплементации (обекти) през единен интерфейс (тип).", "rationale": "Това е същността на полиморфизма - да се третират различни обекти по еднакъв начин, което улеснява добавянето на нови типове без промяна на съществуващия код.", "isCorrect": true }, { "text": "Винаги води до по-добра производителност поради статичното свързване.", "rationale": "Полиморфизмът разчита на динамично свързване, което може да бъде малко по-бавно от статичното.", "isCorrect": false } ], "hint": "Как може да напишете метод, който обработва всякакъв вид 'Животно', без да знае дали е 'Куче', 'Котка' или 'Риба'?" },
                { "questionNumber": 15, "question": "Кога е подходящо да се използва абстрактен клас вместо интерфейс?", "answerOptions": [ { "text": "Когато искате да дефинирате договор, който много несвързани класове да могат да имплементират.", "rationale": "Това е идеалният сценарий за използване на интерфейс.", "isCorrect": false }, { "text": "Когато искате да се възползвате от множествено наследяване.", "rationale": "Множествено наследяване на състояние не се поддържа в Java; това се постига чрез имплементиране на множество интерфейси.", "isCorrect": false }, { "text": "Когато искате да споделите общо състояние (член-променливи) или конкретни методи между тясно свързани класове.", "rationale": "Абстрактните класове са идеални, когато имате 'is-a' връзка и искате да избегнете дублиране на общи данни и имплементации сред наследниците.", "isCorrect": true }, { "text": "Когато искате да създадете тип, който съдържа само `public static final` константи.", "rationale": "Това може да се постигне и с интерфейс, и често е по-добрият избор за дефиниране само на константи.", "isCorrect": false } ], "hint": "Кой от двата механизма ви позволява да дефинирате не-финални и не-статични член-променливи, които да бъдат наследени?" },
                { "questionNumber": 16, "question": "Какво ще се случи, ако конструктор на подклас не извика изрично `super()` или `this()`, а неговият суперклас НЯМА конструктор по подразбиране (без аргументи)?", "answerOptions": [ { "text": "Ще се получи грешка по време на изпълнение (`RuntimeException`).", "rationale": "Проблемът се открива по-рано. Java изисква всеки обект да бъде напълно конструиран, което включва и родителската му част.", "isCorrect": false }, { "text": "Няма да се случи нищо, родителската част на обекта остава неинициализирана.", "rationale": "Компилаторът не позволява такава ситуация, тъй като би довела до нестабилно състояние на обекта.", "isCorrect": false }, { "text": "Ще се получи грешка при компилация.", "rationale": "Компилаторът се опитва да вмъкне `super()` автоматично, но не намира такъв конструктор в родителя, което води до грешка.", "isCorrect": true }, { "text": "Ще се използва конструкторът на класа `Object`.", "rationale": "Йерархията на извикване на конструктори върви само едно ниво нагоре, до прекия родител.", "isCorrect": false } ], "hint": "Какво се опитва да направи компилаторът, когато не намери изрично извикване на конструктор?" },
                { "questionNumber": 17, "question": "Ако в суперклас има `public static void print()` и в подклас има `public static void print()`, какво се случва, когато се извика методът?", "answerOptions": [ { "text": "Това е пример за method overriding и ще се извика версията от реалния тип на обекта.", "rationale": "Method overriding се отнася само за инстанционни (нестатични) методи. Статичните методи не участват в полиморфизма.", "isCorrect": false }, { "text": "Това е пример за method hiding и коя версия ще се извика зависи от типа на референцията, а не от обекта.", "rationale": "Това е правилният термин. Статичните методи се свързват по време на компилация (статично свързване) с типа на променливата.", "isCorrect": true }, { "text": "Ще се получи грешка при компилация заради дублиране на статични методи.", "rationale": "Това е позволен синтаксис в Java, макар че може да доведе до объркване.", "isCorrect": false }, { "text": "Ще се извикват и двата метода последователно, първо този от суперкласа.", "rationale": "Изпълнява се само една версия на метода, определена от типа на референцията.", "isCorrect": false } ], "hint": "Свързва ли се извикването на статичен метод с реалния обект в паметта или с типа, деклариран при компилация?" },
                { "questionNumber": 18, "question": "Коя е основната причина да се програмира спрямо интерфейс, а не спрямо конкретна имплементация (напр. `List list = new ArrayList()` вместо `ArrayList list = new ArrayList()`)?", "answerOptions": [ { "text": "За по-добра производителност, защото интерфейсите са по-бързи.", "rationale": "Няма значителна разлика в производителността; предимствата са в дизайна на софтуера.", "isCorrect": false }, { "text": "Защото позволява лесна смяна на имплементацията (напр. `ArrayList` с `LinkedList`) без да се променя останалата част от кода.", "rationale": "Това е същността на гъвкавия дизайн. Кодът зависи от 'договора' (`List`), а не от конкретния изпълнител (`ArrayList`).", "isCorrect": true }, { "text": "За да се ограничи достъпа само до методите, дефинирани в интерфейса.", "rationale": "Въпреки че това е вярно последствие, то е по-скоро страничен ефект, а не основната цел, която е гъвкавостта.", "isCorrect": false }, { "text": "Защото интерфейсите заемат по-малко памет.", "rationale": "Типът на референцията не влияе на паметта, заета от обекта.", "isCorrect": false } ], "hint": "Какво би се наложило да промените в кода си, ако решите, че `LinkedList` е по-добър избор от `ArrayList` за вашата задача?" },
                { "questionNumber": 19, "question": "Ако клас `A` имплементира интерфейс с `default` метод `m()` и наследява абстрактен клас с абстрактен метод `m()`, какво е задължен да направи клас `A`?", "answerOptions": [ { "text": "Нищо, наследява `default` имплементацията от интерфейса.", "rationale": "Правилото за предимство е, че декларация в клас (дори абстрактна) е 'по-силна' от `default` имплементация.", "isCorrect": false }, { "text": "Трябва да предостави своя собствена имплементация на метода `m()`.", "rationale": "Задължението да се имплементира абстрактният метод от суперкласа има по-висок приоритет от наследяването на `default` имплементация.", "isCorrect": true }, { "text": "Получава грешка при компилация заради конфликта.", "rationale": "Няма конфликт, защото правилата на Java ясно определят кое има предимство.", "isCorrect": false }, { "text": "Трябва да избере коя версия да използва чрез синтаксиса `Interface.super.m()`.", "rationale": "Този синтаксис се използва при конфликт между два `default` метода от интерфейси, а не между клас и интерфейс.", "isCorrect": false } ], "hint": "Кое е 'по-силно' задължение: да се имплементира абстрактен метод или да се наследи `default` имплементация?" },
                { "questionNumber": 20, "question": "Каква е разликата в проверката `obj instanceof MyClass` и `obj.getClass() == MyClass.class`?", "answerOptions": [ { "text": "Няма разлика, и двете проверяват типа на обекта.", "rationale": "Те проверяват типа, но по различен начин, което води до различни резултати при наследяване.", "isCorrect": false }, { "text": "`instanceof` е по-бърза операция от `getClass()`.", "rationale": "Разликата в производителността е пренебрежима; разликата е в семантиката.", "isCorrect": false }, { "text": "`instanceof` връща `true` и за подкласове, докато `getClass()` връща `true` само за точно съвпадение на класа.", "rationale": "Това е ключовата разлика: `instanceof` уважава 'is-a' връзката, докато `getClass()` проверява за точна идентичност на типа.", "isCorrect": true }, { "text": "`getClass()` може да хвърли `NullPointerException`, докато `instanceof` връща `false` за `null`.", "rationale": "Въпреки че това е вярно, основната семантична разлика е свързана с наследяването.", "isCorrect": false } ], "hint": "Ако `Dog` наследява `Animal`, какво ще върнат двете проверки за обект от тип `Dog`, когато се сравнява с `Animal`?" },
                { "questionNumber": 21, "question": "Може ли интерфейс да бъде деклариран като `final`?", "answerOptions": [ { "text": "Да, ако не съдържа никакви методи.", "rationale": "Дори и празен, `final` интерфейс би бил безсмислен.", "isCorrect": false }, { "text": "Не, защото това противоречи на основната му цел да бъде имплементиран от други класове.", "rationale": "Ключовата дума `final` забранява разширяването/наследяването, което е основното предназначение на интерфейсите.", "isCorrect": true }, { "text": "Да, ако всичките му методи са `private`.", "rationale": "Дори и с `private` методи, интерфейсът трябва да може да бъде имплементиран, за да има смисъл.", "isCorrect": false }, { "text": "Да, но само ако е вложен в друг клас.", "rationale": "Правилото важи за всички интерфейси, независимо къде са дефинирани.", "isCorrect": false } ], "hint": "Какво означава `final` в контекста на наследяване?" },
                { "questionNumber": 22, "question": "Ако използвате `import static java.lang.Math.*` и дефинирате в собствения си клас метод `public static double cos(double val)`, кой метод ще бъде извикан при повикване на `cos(0.5)`?", "answerOptions": [ { "text": "Методът от `java.lang.Math`, защото е от стандартната библиотека.", "rationale": "Компилаторът дава предимство на членовете на текущия клас.", "isCorrect": false }, { "text": "Методът, дефиниран във вашия собствен клас.", "rationale": "Членовете (методи, променливи), дефинирани в самия клас, винаги имат предимство пред тези, импортирани статично.", "isCorrect": true }, { "text": "Ще се получи грешка при компилация заради двусмислие.", "rationale": "Няма двусмислие, тъй като правилата за обхват (scope) са ясни - локалното 'скрива' импортираното.", "isCorrect": false }, { "text": "Ще се извика този с по-специфичен тип на аргумента.", "rationale": "Това се отнася за `overloading`, а тук сигнатурите са идентични.", "isCorrect": false } ], "hint": "Кой обхват (scope) има по-висок приоритет - на текущия клас или на статичния импорт?" },
                { "questionNumber": 23, "question": "Коя е основната цел на `protected` модификатора за достъп?", "answerOptions": [ { "text": "Да направи член видим за всички класове в проекта.", "rationale": "Това е ролята на `public` модификатора.", "isCorrect": false }, { "text": "Да позволи на подкласове да достъпят детайли от имплементацията на родителя, като същевременно ги скрива от останалия свят.", "rationale": "Това е балансът, който `protected` осигурява - 'отворен за разширение, но затворен за модификация' от външни класове.", "isCorrect": true }, { "text": "Да направи член видим само в рамките на същия пакет (package-private).", "rationale": "Това се постига с липсата на модификатор. `protected` е по-малко ограничаващ, защото включва и подкласове извън пакета.", "isCorrect": false }, { "text": "Да направи член достъпен само в рамките на класа, в който е дефиниран.", "rationale": "Това е ролята на `private` модификатора.", "isCorrect": false } ], "hint": "Как един клас може да 'сподели' нещо с децата си, но не и с непознати?" },
                { "questionNumber": 24, "question": "Ако не предефинирате метода `toString()` в своя клас, какво ще отпечата имплементацията по подразбиране от класа `Object`?", "answerOptions": [ { "text": "Думата 'Object'.", "rationale": "Имплементацията по подразбиране дава повече информация от просто 'Object'.", "isCorrect": false }, { "text": "Пълното име на класа, последвано от `@` и хеш кода на обекта в шестнадесетичен формат.", "rationale": "Това е точният формат, например: `com.example.MyClass@1f32e575`.", "isCorrect": true }, { "text": "Стойностите на всички член-променливи, разделени със запетая.", "rationale": "Това е типичното поведение на добре предефиниран `toString()`, но не и на този по подразбиране.", "isCorrect": false }, { "text": "Празен стринг.", "rationale": "Имплементацията по подразбиране винаги връща идентифицираща информация за обекта.", "isCorrect": false } ], "hint": "Как може да се идентифицира уникално един обект в паметта, без да се познават неговите полета?" },
                { "questionNumber": 25, "question": "Защо е лоша практика `equals()` методът да зависи от променливи (mutable) полета?", "answerOptions": [ { "text": "Защото `final` полетата не могат да се сравняват.", "rationale": "`final` полетата могат и трябва да участват в сравнението.", "isCorrect": false }, { "text": "Защото нарушава договора с `hashCode()` - ако обект се промени след като е добавен в `HashSet`, той може да стане 'неоткриваем'.", "rationale": "Ако хеш кодът се промени, обектът вече няма да се намира в правилния 'bucket', което нарушава основната функционалност на колекцията.", "isCorrect": true }, { "text": "Защото води до по-бавно сравнение.", "rationale": "Скоростта на сравнение не е основният проблем; проблемът е в логическата коректност.", "isCorrect": false }, { "text": "Защото е позволено `equals()` да сравнява само примитивни типове.", "rationale": "Няма такова ограничение; `equals()` може да сравнява всякакви полета.", "isCorrect": false } ], "hint": "Какво ще се случи, ако сложите ключ в чекмедже 'А', след което промените ключа така, че вече да принадлежи на чекмедже 'Б'?" },
                { "questionNumber": 26, "question": "Коя комбинация от ключови думи за метод е НЕВАЛИДНА в Java?", "answerOptions": [ { "text": "public static final", "rationale": "Тази комбинация е валидна и често се използва за дефиниране на константи.", "isCorrect": false }, { "text": "private static", "rationale": "Валидна комбинация, често използвана за помощни статични методи в рамките на един клас.", "isCorrect": false }, { "text": "protected abstract", "rationale": "Валидна комбинация. Методът е абстрактен и видим за подкласове и класове в същия пакет.", "isCorrect": false }, { "text": "abstract final", "rationale": "`abstract` означава 'трябва да бъде имплементиран от подклас', а `final` означава 'не може да бъде пренаписан'. Двете са в пълно противоречие.", "isCorrect": true } ], "hint": "Помислете за семантичното противоречие между две ключови думи." },
                { "questionNumber": 27, "question": "Клас `A` в пакет `p1` има `protected` метод `m()`. Клас `B` в пакет `p2` наследява `A`. В метод на клас `B`, можем ли да извикаме `m()` върху инстанция на `A`?", "answerOptions": [ { "text": "Да, защото `B` е наследник и има достъп до `protected` членове.", "rationale": "Достъпът до `protected` член от друг пакет е позволен само през референция от собствен или подкласов тип, не от тип на родителя.", "isCorrect": false }, { "text": "Не, защото `protected` достъпът извън пакета е валиден само за членове на самия обект (`this`), а не на друга инстанция.", "rationale": "Това е тънък момент в спецификацията. `B` може да извика `m()` на `this` или на друга инстанция от тип `B`, но не и на инстанция от тип `A`.", "isCorrect": true }, { "text": "Да, но само ако `A` и `B` са в един и същи модул.", "rationale": "Модулната система не променя това правило за достъп.", "isCorrect": false }, { "text": "Не, защото `m()` е видим само в пакет `p1`.", "rationale": "Това би било вярно, ако методът беше `package-private`. `protected` разширява видимостта и за наследници.", "isCorrect": false } ], "hint": "Какви са ограниченията на `protected` достъпа, когато наследникът е в друг пакет?" },
                { "questionNumber": 28, "question": "Какво се случва с нестатичните член-променливи на суперкласа, когато се създаде обект от подклас?", "answerOptions": [ { "text": "Създава се отделен обект за суперкласа, към който подкласът има референция.", "rationale": "Обектът е само един; той съдържа в себе си и данните на родителя, и на детето.", "isCorrect": false }, { "text": "Те се копират в подкласа.", "rationale": "Те не се копират, а са неразделна част от състоянието на обекта от подкласа.", "isCorrect": false }, { "text": "Те стават част от паметта, алокирана за обекта от подкласа.", "rationale": "Една инстанция на подкласа съдържа всички инстанционни полета от цялата си йерархия нагоре до `Object`.", "isCorrect": true }, { "text": "Те са достъпни само чрез извикване на `super`.", "rationale": "Ако не са скрити (shadowed) от полета със същото име в подкласа, те са достъпни директно.", "isCorrect": false } ], "hint": "Колко отделни обекта се създават в паметта при `new SubClass()`?" },
                { "questionNumber": 29, "question": "Може ли конструктор да бъде `synchronized`?", "answerOptions": [ { "text": "Да, за да се предотвратят race conditions при създаване на обекти.", "rationale": "Синхронизацията се постига по други начини, например със `static factory` методи.", "isCorrect": false }, { "text": "Да, но само ако класът наследява `java.lang.Thread`.", "rationale": "Няма такава специална зависимост. Правилото е универсално.", "isCorrect": false }, { "text": "Не, това е грешка при компилация, защото обектът все още не съществува напълно и няма асоцииран с него монитор (lock).", "rationale": "Ключалката на обекта, която `synchronized` използва, става достъпна едва след като конструкторът приключи работа.", "isCorrect": true }, { "text": "Не, но може да бъде `volatile`.", "rationale": "`volatile` се прилага за променливи, не за методи или конструктори.", "isCorrect": false } ], "hint": "Какво е необходимо, за да работи ключовата дума `synchronized` върху инстанционен метод?" },
                { "questionNumber": 30, "question": "Кой от следните модификатори не може да се приложи към клас от най-високо ниво (top-level class)?", "answerOptions": [ { "text": "public", "rationale": "`public` е позволен и прави класа достъпен отвсякъде.", "isCorrect": false }, { "text": "abstract", "rationale": "`abstract` е позволен и означава, че класът не може да бъде инстанциран.", "isCorrect": false }, { "text": "final", "rationale": "`final` е позволен и означава, че класът не може да бъде наследяван.", "isCorrect": false }, { "text": "protected", "rationale": "Модификаторите `protected` и `private` са предназначени за членове на класове и не могат да се използват за класове от най-високо ниво.", "isCorrect": true } ], "hint": "Какви са двете единствени опции за видимост на един самостоятелен клас?" },
                { "questionNumber": 31, "question": "Коя е основната разлика между статичен блок за инициализация (`static { ... }`) и конструктор?", "answerOptions": [ { "text": "Конструкторът се изпълнява преди статичния блок.", "rationale": "Статичният блок се изпълнява първи, само веднъж, когато класът се зарежда в паметта.", "isCorrect": false }, { "text": "Статичният блок се изпълнява само веднъж при зареждане на класа, докато конструкторът се изпълнява при всяко създаване на инстанция.", "rationale": "Това е ключовата разлика: статичният блок е за инициализация на ниво клас, а конструкторът - на ниво обект.", "isCorrect": true }, { "text": "Статичният блок не може да достъпва `private` полета.", "rationale": "Статичният блок може да достъпва `private static` полета.", "isCorrect": false }, { "text": "Конструкторът може да хвърля изключения, а статичният блок - не.", "rationale": "И двете конструкции могат да хвърлят изключения, но необработено изключение в статичен блок е фатално (`ExceptionInInitializerError`).", "isCorrect": false } ], "hint": "Кога се случва инициализацията - когато класът е зареден от JVM или когато се създава конкретен обект?" },
                { "questionNumber": 32, "question": "Ако метод в суперклас е `package-private`, може ли подклас в същия пакет да го пренапише (override) и да го направи `public`?", "answerOptions": [ { "text": "Не, модификаторът за достъп трябва да остане същият.", "rationale": "Правилото позволява разширяване на видимостта.", "isCorrect": false }, { "text": "Да, това е позволено, защото `public` е по-малко ограничаващ от `package-private`.", "rationale": "Правилото за пренаписване гласи, че видимостта може да бъде същата или по-малко ограничаваща. `public` е по-малко ограничаващ.", "isCorrect": true }, { "text": "Не, `package-private` методи изобщо не могат да бъдат пренаписвани.", "rationale": "Те могат да бъдат пренаписвани от класове в същия пакет.", "isCorrect": false }, { "text": "Да, но само ако суперкласът е `abstract`.", "rationale": "Това правило не зависи от това дали суперкласът е абстрактен или не.", "isCorrect": false } ], "hint": "Какво е правилото за промяна на видимостта при method overriding?" },
                { "questionNumber": 33, "question": "Какъв е резултатът от извикването на `super.super.method()`?", "answerOptions": [ { "text": "Извиква се методът от 'дядото' на класа (две нива нагоре).", "rationale": "Тази конструкция не съществува в Java.", "isCorrect": false }, { "text": "Грешка при компилация.", "rationale": "Синтаксисът `super.super` е невалиден. `super` може да се използва само за достъп до прекия родител.", "isCorrect": true }, { "text": "Извиква се статичен метод от класа `Object`.", "rationale": "Няма връзка със статични методи или класа `Object`.", "isCorrect": false }, { "text": "Резултатът е същият като при `super.method()`.", "rationale": "Компилаторът не игнорира второто `super`, а го отчита като синтактична грешка.", "isCorrect": false } ], "hint": "До колко нива 'нагоре' в йерархията на наследяване може да 'погледне' ключовата дума `super`?" },
                { "questionNumber": 34, "question": "Кое от изброените НЕ е характеристика на функционален интерфейс?", "answerOptions": [ { "text": "Трябва да съдържа точно един абстрактен метод.", "rationale": "Това е основното изискване за един интерфейс да бъде функционален.", "isCorrect": false }, { "text": "Може да съдържа произволен брой `default` методи.", "rationale": "`default` и `static` методите не се броят към ограничението за един абстрактен метод.", "isCorrect": false }, { "text": "Не може да наследява друг интерфейс.", "rationale": "Функционален интерфейс може да наследява друг интерфейс, стига крайният резултат да е само един абстрактен метод.", "isCorrect": true }, { "text": "Може да съдържа методи, които пренаписват публични методи от `java.lang.Object`.", "rationale": "Методи като `toString()` или `equals()` от класа `Object`, декларирани в интерфейса, не се броят към абстрактните методи.", "isCorrect": false } ], "hint": "Въпросът е за това кое НЕ е вярно. Помислете за композицията на интерфейси." },
                { "questionNumber": 35, "question": "Какво означава, че един обект е 'immutable' (непроменлив)?", "answerOptions": [ { "text": "Класът му е деклариран като `final`.", "rationale": "Въпреки че често е добра практика, `final` клас не гарантира непроменливост на състоянието.", "isCorrect": false }, { "text": "Всичките му полета са `private`.", "rationale": "Това е част от енкапсулацията, но не гарантира, че `setter` методи няма да променят състоянието.", "isCorrect": false }, { "text": "Състоянието му не може да бъде променено след като обектът е създаден.", "rationale": "Това е дефиницията за непроменливост. Примери са `String` и `Integer`.", "isCorrect": true }, { "text": "Няма публични методи.", "rationale": "Непроменливите обекти имат публични методи за достъп до състоянието (`getters`), но не и за промяна.", "isCorrect": false } ], "hint": "Помислете за поведението на обект от клас `String`. Можете ли да промените символите в него след създаването му?" },
                { "questionNumber": 36, "question": "Каква е целта на `varargs` (променлив брой аргументи)?", "answerOptions": [ { "text": "Да позволи на метод да приема масив като единствен аргумент.", "rationale": "Въпреки че `varargs` се третира като масив вътре в метода, целта му е да улесни извикването.", "isCorrect": false }, { "text": "Да осигури синтактично улеснение за извикване на метод с нула или повече аргументи от един и същи тип.", "rationale": "Това позволява гъвкавост при извикването, без да се налага програмистът ръчно да създава масив.", "isCorrect": true }, { "text": "Да позволи `overloading` на методи само по тип на връщана стойност.", "rationale": "`varargs` не е свързан с типа на връщана стойност.", "isCorrect": false }, { "text": "Да замени напълно нуждата от колекции като `ArrayList`.", "rationale": "`varargs` е за подаване на параметри, а не за съхранение и манипулация на данни като колекциите.", "isCorrect": false } ], "hint": "Каква е разликата при извикване на `myMethod(new String[]{\"a\", \"b\"})` и `myMethod(\"a\", \"b\")`?" },
                { "questionNumber": 37, "question": "Кой от следните типове полиморфизъм се решава по време на компилация (статично свързване)?", "answerOptions": [ { "text": "Извикване на пренаписан (overridden) метод през референция от тип суперклас.", "rationale": "Това е класически пример за динамично свързване (runtime полиморфизъм).", "isCorrect": false }, { "text": "Избор между няколко претоварени (overloaded) метода.", "rationale": "Компилаторът избира правилния метод, като анализира типовете на аргументите при извикването.", "isCorrect": true }, { "text": "Използване на оператора `instanceof`.", "rationale": "Проверката с `instanceof` се случва по време на изпълнение.", "isCorrect": false }, { "text": "Извикване на метод на абстрактен клас.", "rationale": "Извикването на метод, който може да бъде имплементиран в подклас, разчита на динамично свързване.", "isCorrect": false } ], "hint": "При кой сценарий компилаторът има цялата необходима информация, за да избере точната имплементация на метода?" },
                { "questionNumber": 38, "question": "Каква е основната разлика между поле, което е `final`, и поле, което е `private`?", "answerOptions": [ { "text": "`final` полетата не могат да бъдат наследени, докато `private` могат.", "rationale": "И двата вида полета се наследяват, но достъпът до `private` е ограничен само в суперкласа.", "isCorrect": false }, { "text": "`final` означава, че стойността не може да бъде променена след инициализация, докато `private` ограничава видимостта само до класа.", "rationale": "Това точно описва ортогоналните роли на двата модификатора - единият контролира променливостта, а другият - достъпа.", "isCorrect": true }, { "text": "`private` полетата трябва да бъдат инициализирани в конструктора, а `final` - не.", "rationale": "Точно обратното, неинициализирано `final` поле трябва да получи стойност в конструктора.", "isCorrect": false }, { "text": "Няма разлика, те са взаимозаменяеми.", "rationale": "Те имат напълно различни цели и често се използват заедно (напр. `private final`).", "isCorrect": false } ], "hint": "Едната ключова дума е свързана с 'константност', а другата с 'видимост'." },
                { "questionNumber": 39, "question": "Кога е подходящо да се използва `static import`?", "answerOptions": [ { "text": "Винаги, когато се използват статични методи, за да се намали кода.", "rationale": "Прекомерната употреба може да направи кода по-трудно четим, защото не е ясно от кой клас идва методът.", "isCorrect": false }, { "text": "Когато се използват често голям брой статични константи от един и същи клас (напр. от `TimeUnit`).", "rationale": "Това е добър случай на употреба, защото подобрява четимостта, като `SECONDS` вместо `TimeUnit.SECONDS`.", "isCorrect": true }, { "text": "За импортиране на `private` статични методи.", "rationale": "`static import` спазва правилата за достъп и не може да импортира `private` членове.", "isCorrect": false }, { "text": "Когато искате да пренапишете (override) статичен метод.", "rationale": "Статичните методи не се пренаписват и `static import` не е свързан с този механизъм.", "isCorrect": false } ], "hint": "Помислете за баланса между краткост и яснота на кода." },
                { "questionNumber": 40, "question": "Ако един клас имплементира интерфейс, той задължително ли трябва да имплементира всички негови методи?", "answerOptions": [ { "text": "Да, винаги трябва да имплементира всички методи.", "rationale": "Има изключение от това правило.", "isCorrect": false }, { "text": "Не, трябва да имплементира само методите, които не са `default` или `static`.", "rationale": "Това е по-близо, но все още има важен случай, който не е покрит.", "isCorrect": false }, { "text": "Не, ако класът е деклариран като `abstract`, той не е задължен да имплементира всички методи.", "rationale": "Абстрактният клас може да 'прехвърли' задължението за имплементация на своите собствени подкласове.", "isCorrect": true }, { "text": "Не, имплементацията на методите е изцяло по избор.", "rationale": "Имплементирането на интерфейс създава 'договор', който трябва да бъде спазен.", "isCorrect": false } ], "hint": "Как един клас може да 'отложи' изпълнението на договорните си задължения?" },
                { "questionNumber": 41, "question": "Кой от изброените НЕ е метод на класа `java.lang.Object`?", "answerOptions": [ { "text": "equals(Object obj)", "rationale": "`equals` е фундаментален метод на `Object` за сравняване на обекти.", "isCorrect": false }, { "text": "hashCode()", "rationale": "`hashCode` е ключов метод, тясно свързан с `equals` и хеш-базираните колекции.", "isCorrect": false }, { "text": "clone()", "rationale": "`clone` е `protected` метод в `Object` за създаване на копия на обекти.", "isCorrect": false }, { "text": "compareTo(Object obj)", "rationale": "`compareTo` не е част от `Object`. Той е дефиниран в интерфейса `Comparable`, който класовете трябва да имплементират, за да имат естествен ред на подредба.", "isCorrect": true } ], "hint": "Кой метод е свързан с подредба и сортиране на обекти?" },
                { "questionNumber": 42, "question": "Какво е 'shadowing' (засенчване) на променлива?", "answerOptions": [ { "text": "Когато метод в подклас пренаписва метод в суперклас.", "rationale": "Това се нарича `method overriding`.", "isCorrect": false }, { "text": "Когато локална променлива или параметър в метод има същото име като член-променлива на класа.", "rationale": "В този случай, за достъп до член-променливата трябва да се използва `this`.", "isCorrect": true }, { "text": "Когато статична променлива се скрива от нестатична.", "rationale": "Статични и нестатични членове съществуват в различни контексти и не се засенчват по този начин.", "isCorrect": false }, { "text": "Когато `private` променлива в суперклас е недостъпна.", "rationale": "Това е резултат от енкапсулацията, а не 'shadowing'.", "isCorrect": false } ], "hint": "Какво трябва да направите в конструктор, когато името на параметъра съвпада с името на полето, което трябва да инициализирате?" },
                { "questionNumber": 43, "question": "Каква е основната разлика между енкапсулация и абстракция?", "answerOptions": [ { "text": "Няма разлика, те са синоними.", "rationale": "Въпреки че са свързани, те описват различни аспекти на ООП.", "isCorrect": false }, { "text": "Енкапсулацията е свързана с наследяване, а абстракцията - с композиция.", "rationale": "И двата принципа могат да се използват и при наследяване, и при композиция.", "isCorrect": false }, { "text": "Енкапсулацията е механизъм за скриване на данни, докато абстракцията е механизъм за скриване на сложността на имплементацията.", "rationale": "Това е ключовото разграничение: енкапсулацията защитава състоянието, а абстракцията предоставя опростен изглед към поведението.", "isCorrect": true }, { "text": "Абстракцията се постига с `private` полета, а енкапсулацията с абстрактни класове.", "rationale": "Точно обратното е по-близо до истината.", "isCorrect": false } ], "hint": "Единият принцип е за 'какво' прави един обект, а другият е за 'как' данните му са защитени." },
                { "questionNumber": 44, "question": "Какво се случва, ако `final` променлива не е инициализирана в момента на декларацията си?", "answerOptions": [ { "text": "Тя автоматично получава стойност `null` или 0.", "rationale": "Компилаторът не присвоява стойност по подразбиране на `final` променливи.", "isCorrect": false }, { "text": "Тя трябва задължително да бъде инициализирана във всеки конструктор на класа.", "rationale": "Това е правилото за 'blank final variable'. Компилаторът гарантира, че тя ще получи стойност точно веднъж при създаването на обекта.", "isCorrect": true }, { "text": "Ще се получи грешка по време на изпълнение, когато се опитате да я използвате.", "rationale": "Проблемът се засича по-рано, от компилатора.", "isCorrect": false }, { "text": "Тя може да бъде инициализирана по-късно във всеки един метод.", "rationale": "След като конструкторът приключи, стойността на `final` променливата е 'бетонирана' и не може да се променя.", "isCorrect": false } ], "hint": "Как компилаторът гарантира, че 'константата' наистина ще получи стойност?" },
                { "questionNumber": 45, "question": "В какъв ред се извикват конструкторите и инициализационните блокове при създаване на обект от подклас?", "answerOptions": [ { "text": "Конструктор на суперклас -> Конструктор на подклас -> Инициализационни блокове.", "rationale": "Инициализационните блокове се изпълняват преди конструктора.", "isCorrect": false }, { "text": "Инициализационни блокове на суперклас -> Конструктор на суперклас -> Инициализационни блокове на подклас -> Конструктор на подклас.", "rationale": "Това е точната последователност. Инициализацията върви от най-високо в йерархията надолу.", "isCorrect": true }, { "text": "Инициализационни блокове на подклас -> Конструктор на подклас -> Инициализационни блокове на суперклас -> Конструктор на суперклас.", "rationale": "Инициализацията винаги започва от родителя, а не от детето.", "isCorrect": false }, { "text": "Всички инициализационни блокове -> Всички конструктори.", "rationale": "Редът е преплетен, като за всеки клас първо се изпълнява инициализационният блок, а след това конструкторът.", "isCorrect": false } ], "hint": "Помислете за веригата на конструиране. Какво трябва да се случи първо, за да се изгради основата на обекта?" },
                { "questionNumber": 46, "question": "Защо `private` метод не може да бъде `abstract`?", "answerOptions": [ { "text": "Защото абстрактните методи не могат да връщат стойност.", "rationale": "Абстрактните методи могат да имат всякакъв тип на връщана стойност, включително `void`.", "isCorrect": false }, { "text": "Защото `private` метод не е видим за подкласовете и следователно не може да бъде имплементиран от тях.", "rationale": "`abstract` означава 'трябва да се имплементира от наследник', а `private` означава 'не се вижда от наследник', което е логическо противоречие.", "isCorrect": true }, { "text": "Защото абстрактните методи трябва да са `static`.", "rationale": "Точно обратното, абстрактните методи са инстанционни и не могат да бъдат `static`.", "isCorrect": false }, { "text": "Това е просто стилистично ограничение без техническа причина.", "rationale": "Има силна техническа и логическа причина за това ограничение.", "isCorrect": false } ], "hint": "Каква е целта на `abstract` метода и кой е отговорен да я изпълни?" },
                { "questionNumber": 47, "question": "Кое е най-доброто описание на 'динамично свързване' (dynamic binding)?", "answerOptions": [ { "text": "Процесът, при който компилаторът свързва извикването на метод с конкретна имплементация.", "rationale": "Това описва статичното свързване (static binding).", "isCorrect": false }, { "text": "Процесът на свързване на сорс файла с необходимите библиотеки.", "rationale": "Това е част от процеса на компилация и линкване, а не от полиморфизма.", "isCorrect": false }, { "text": "Механизмът, при който JVM по време на изпълнение определя коя имплементация на пренаписан метод да извика, базирано на реалния тип на обекта.", "rationale": "Това е същността на runtime полиморфизма, който позволява гъвкавост и разширяемост на кода.", "isCorrect": true }, { "text": "Автоматичното преобразуване на примитивен тип в неговия wrapper клас (autoboxing).", "rationale": "Autoboxing е удобство на компилатора, но не е свързано с динамичното извикване на методи.", "isCorrect": false } ], "hint": "Кой (компилаторът или JVM) и кога (по време на компилация или на изпълнение) взима решението?" },
                { "questionNumber": 48, "question": "Клас `A` има `private` метод `m()`. Подклас `B` също дефинира метод `m()` със същата сигнатура. Кое твърдение е вярно?", "answerOptions": [ { "text": "Методът `m()` в `B` пренаписва (overrides) метода в `A`.", "rationale": "Пренаписване не е възможно, тъй като методът в `A` не е видим за `B`.", "isCorrect": false }, { "text": "Това ще доведе до грешка при компилация.", "rationale": "Няма грешка, защото двата метода са напълно независими един от друг.", "isCorrect": false }, { "text": "Двата метода са напълно несвързани. Методът в `B` не пренаписва и не скрива метода в `A`.", "rationale": "Тъй като `private` методът е невидим извън своя клас, дефиницията в `B` е напълно нова и независима.", "isCorrect": true }, { "text": "Методът `m()` в `B` скрива (hides) метода в `A`.", "rationale": "Скриването (hiding) се отнася за статични методи. Тук методите са напълно независими.", "isCorrect": false } ], "hint": "Може ли да пренапишеш нещо, което не виждаш?" },
                { "questionNumber": 49, "question": "Кога операторът `instanceof` е за предпочитане пред `getClass()`?", "answerOptions": [ { "text": "Когато искате да проверите за точния, конкретен тип на един обект.", "rationale": "За проверка на точния тип `getClass()` е по-подходящ.", "isCorrect": false }, { "text": "Когато искате да проверите дали един обект спазва определен 'договор' или е част от дадена йерархия (is-a relationship).", "rationale": "`instanceof` е полиморфната проверка за тип, която позволява на кода ви да работи с цели фамилии от класове.", "isCorrect": true }, { "text": "Когато работите с примитивни типове.", "rationale": "Нито `instanceof`, нито `getClass()` работят с примитивни типове.", "isCorrect": false }, { "text": "Никога, `getClass()` е винаги по-добрият избор.", "rationale": "И двата оператора имат своето място; изборът зависи от това дали искате да уважите наследяването или не.", "isCorrect": false } ], "hint": "Кой от двата оператора е в съответствие с принципа на Лисков за заместване?" },
                { "questionNumber": 50, "question": "Каква е основната причина за съществуването на пакети (packages) в Java?", "answerOptions": [ { "text": "Да се ускори процесът на компилация.", "rationale": "Пакетите не влияят пряко на скоростта на компилация.", "isCorrect": false }, { "text": "Да се осигури механизъм за контрол на достъпа и да се предотвратят конфликти в имената.", "rationale": "Пакетите създават именни пространства (namespaces), които позволяват съществуването на два класа с име `List` в различни пакети, и дефинират обхвата за `package-private` достъп.", "isCorrect": true }, { "text": "Да се позволи на класовете да наследяват множество други класове.", "rationale": "Пакетите не са свързани с множественото наследяване.", "isCorrect": false }, { "text": "Да се ограничи броят на класовете в един файл.", "rationale": "В Java има правило за един публичен клас на файл, но то не е свързано с основната цел на пакетите.", "isCorrect": false } ], "hint": "Какво би се случило, ако всички класове в стандартната библиотека на Java и във вашия проект бяха в една и съща 'папка'?" }
            ]
        };

        let quizData = [];

        // DOM Elements
        const questionTextEl = document.getElementById('question-text');
        const questionCounterEl = document.getElementById('question-counter');
        const optionsContainerEl = document.getElementById('options-container');
        const nextBtnEl = document.getElementById('next-btn');
        const scoreContainerEl = document.getElementById('score-container');
        const scoreTextEl = document.getElementById('score-text');
        const restartBtnEl = document.getElementById('restart-btn');
        const questionHeaderEl = document.getElementById('question-header');
        const feedbackContainerEl = document.getElementById('feedback-container');
        const feedbackRationaleEl = document.getElementById('feedback-rationale');

        // State
        let currentQuestionIndex = 0;
        let score = 0;

        // Shuffle function (Fisher-Yates shuffle)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            
            // Shuffle the questions at the start of the quiz
            quizData = [...quizDataRaw.questions];
            shuffleArray(quizData);

            scoreContainerEl.classList.add('hidden');
            questionHeaderEl.classList.remove('hidden');
            optionsContainerEl.classList.remove('hidden');
            nextBtnEl.classList.add('hidden');
            feedbackContainerEl.classList.add('hidden');
            loadQuestion();
        }

        function loadQuestion() {
            // Clear previous options and feedback
            optionsContainerEl.innerHTML = '';
            nextBtnEl.classList.add('hidden');
            feedbackContainerEl.classList.add('hidden');

            const currentQuestion = quizData[currentQuestionIndex];
            
            questionTextEl.textContent = currentQuestion.question;
            questionCounterEl.textContent = `Въпрос ${currentQuestionIndex + 1} от ${quizData.length}`;
            
            // Also shuffle answer options for each question
            const shuffledOptions = [...currentQuestion.answerOptions];
            shuffleArray(shuffledOptions);

            shuffledOptions.forEach(option => {
                const button = document.createElement('button');
                button.innerHTML = option.text;
                button.classList.add('option-btn', 'w-full', 'p-4', 'border-2', 'border-slate-300', 'dark:border-slate-600', 'rounded-lg', 'text-left', 'hover:bg-slate-100', 'dark:hover:bg-slate-700', 'focus:outline-none', 'focus:ring-2', 'focus:ring-indigo-400');
                
                button.addEventListener('click', () => selectAnswer(button, option, currentQuestion));
                optionsContainerEl.appendChild(button);
            });
        }

        function selectAnswer(button, selectedOption, question) {
            // Disable all buttons to prevent multiple answers
            const allOptions = optionsContainerEl.querySelectorAll('.option-btn');
            allOptions.forEach(btn => btn.disabled = true);
            
            feedbackRationaleEl.textContent = selectedOption.rationale;
            feedbackContainerEl.classList.remove('hidden');

            if (selectedOption.isCorrect) {
                score++;
                button.classList.add('correct');
            } else {
                button.classList.add('incorrect');
                // Highlight the correct answer
                const correctOptionText = question.answerOptions.find(opt => opt.isCorrect).text;
                allOptions.forEach(btn => {
                    if (btn.innerHTML === correctOptionText) {
                        btn.classList.add('correct');
                    }
                });
            }
            
            nextBtnEl.classList.remove('hidden');
        }

        function showNextQuestion() {
            currentQuestionIndex++;
            if (currentQuestionIndex < quizData.length) {
                loadQuestion();
            } else {
                showScore();
            }
        }

        function showScore() {
            questionHeaderEl.classList.add('hidden');
            optionsContainerEl.classList.add('hidden');
            nextBtnEl.classList.add('hidden');
            feedbackContainerEl.classList.add('hidden');
            
            scoreTextEl.textContent = `Вашият резултат е ${score} от ${quizData.length}.`;
            scoreContainerEl.classList.remove('hidden');
        }
        
        // Event Listeners
        nextBtnEl.addEventListener('click', showNextQuestion);
        restartBtnEl.addEventListener('click', startQuiz);

        // Initial load
        startQuiz();
    </script>
</body>
</html>