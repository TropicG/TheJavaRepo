* Какво представлява Обектно-ориентираното прогрмиране 

	ООП се появява поради необходимостта за по-добър контрол над едновременната модификция на споделни данни 
	
	Основната идея е, да няма директен достъп до данните, а те да се достъпват през нарочен за целта слой код 
	
	Понеже и самите данни трябва да се предават и да се модифицират, се ражда самата концепция за обект 
	
* Какво представлява един обект 

	Обект е множество от данни, които могат да се предават и да се достъпват чрез методи, които може да се създадат когато подаваме данните за обекта 
	
	Самите данните съставляват състоянието на обекта, докато методите съставляват поведението на обекта
	
	Самото състояние на обекта е скрито (енкапсулирано) от директен достъп
	Обектът е инстанция (представител) на даден клас, като обектите се създават: 
	- явно (explicit) с оператора 
	- неявно (implicit)
	Обектите живеят в heap паметта 
	
* Създаване на обекти: implicit vs explicit 

	Примери, когато се използва имплицитно:
	- String[] stringArr = {"Some", "Example"} // това е implicitno, създават се обекти в String memory-то
	- Integer studentsCount = Integer.valueOf(60) // това е implicit, защото valueof(60) автоматично създава Integer обект
	
	Примери, когато се използва експилитно:
	- String message = new String("This is a string");
	- int[] intArr = new int[100];
	- stringArr = new String[]{"Changed", "my", "gun"}; 
	
	
* Какво представлява Клас 

	Клас е шаблон, който дефинира от какви части е изграден даден обект, той описва две основни неща:
	- Състоянието (член-данните): Това са характеристиките на класа 
	- Поведението (методите): Описва какво прави класа
	
	Конструктура е специален метод, който се извиква автоматично, когато създаваме нов обект.
	Неговата основна задача е да извърши първоначалната настройка - да зададе първоначалното състояние.
	
	Методите са всички останали функции в класа (без конструктурите), които дефинират неговото поведение и позволява да се променя неговото състояние
	
	Възможно е един клас да няма състояние (тоест data-members) или да няма поведение (тоест да няма методи)
	
	Всеки един клас има определен интерфейс, това е списъкът от публични променливи и методи, които други части на програмата могат да използват 
	
* Какво представлява един метод 

	Методът е функция, която принадлежи на даден клас. Методите са основният начин, по който един обект проявява своето поведение  и манипулира своето състояние
	
	Сигнатурата е като "уникален подпис" на метода, който го отличава от другите.
	Една сигнатура се състои от две неща:
	- Името на метода 
	- Списък от параметри, с които работи метода 
	Арността на един метод е буквално броя на параметрите, които той приема
	Два метода са напълно идентични, ако те имат едно и също име, еднакаква арност и еднакви типове параметри в една и съща последователност 
	
	Страничен ефект е всяко действие, което променя състоянието извън самия метод, пример:
	- промяна на данните 
	- отпечатване на текст в конзолата
	- записване на информация във файл
	- изпращане на данни по мрежата 
	
* Методи с променлив брой аргументи 

	Позволява на един метод да приема различен брой аргументи всеки път, когато бъде извикан 
	Varargs е стандартния термин в програмирането за тази функционалност. 
	
	Синтаксиса е името на тип, последван от три точки, като ако един метод има varargs параметъй, той трябва да е единствен и последен в списъка за параметри 
	
	При достигане на varargs параметъра, компилатора създава масив от подадените аргументи и ги подава на метода като масив.
	В самото тяло на метода те могат да се достъпва като масив 
	
	Пример:
	static void functionExample(int... a); 
	
* Статични член променливи и статични методи 

	Когато нещо е статично, то принадлежи на самият клас, а не на отделните обекти (инстанции) създадени от този клас. Можем да ги достъпим директно чрез името на класа
	
	Примери:
	- Math.PI // това е 3.14....
	- Маth.pow(int base, int power) // функцията за степен, буквално се извиква директно 
	
	Статичните член-променливи имат едно-единствено копие което се споделя между всички инстанции на класа, това може да има 2 употреби:
	- Ако това е някаква константа, ще спести памет, защото няма смисъл да е във всяка инстанция
	- Ако са променливи, всяка инстанция вижда и променя една и съща стойност, което е механизъм за комуникация между инстанции на даден клас 
	
	Базирано дали един метод е статичен или не има няколко правила, които трябва да се спазят:
	- Статичните методи имат достъп само до статичните член-променливи и други статични методи (един вид говори само със своите си)
	- Нестатичните методи имат достъп както до статичните методи така и до нестатичните методи (говори с всички )
	- Статичните методи не могат да се пренаписват (overriding), един референтен тип винаги ще вика своя статичен метод
	
* Ключовата дума this 

	Накратко this е начинът, по който един обект говори за себе си 
	
	Във всеки нестатичен метод, this е специална променлива, която пази адреса (референцията) на текущия обект.
	This implicit-но се подва като параметър на всеки конструктур и нестатичен метод на класа, компилатора добавя this като първи скрит параметър
	
	Най-честите практически приложения на this:
	- достъпване на член-променбливи, които са скрити от параметъра на даден метод, защото има същото име (говоря за ситуация от случая this.name = name;)
	- извикване от конструктур на друг overloaded конструктор в същия клас (става дума за constructor chaining)
	- извикване на произволен метод на класа 
	
* Constructor Chaning 

	Това е техника, при която един конструктор извиква друг конструктор в същия клас. Основната цел е да се избегнат повторенията и да се централизира логиката.
	Извикването на такъв конструктор в конструктор става чрез this(...) като this винаги трябва да е на първия ред 
	
	A method overloaded е възможността да имаш няколко метода с едно и също име в един и същи клас, които са различават само по параметри 

* Пакети

	Накратко пакетите са буквално папки за кода, организирането на класовете в пакетите е аналогички на организирането на файлове в папките 
	
	За какво служат пакетите:
	- Именувани групи от семантично свързани класове: Един пакет съдържа класове, които работят заедно или имат обща цел 
	- Служат за йерархично организиране на кода: Един пакет може да съдържа други пакет, създавайки так дърдовидна структура
	- Когато се създава пакет, всъщност се създава папка на твърдия диск 
	
	Конценция за именуване:
	- използват се само малки букви и точка за разделител
	- използване на обратен домейн адрес: вместо mail.google.com -> com.google.mail
	
	За да декларираш, че един Java Клас принадлежи на определен пакет трябва на първия ред във всеки java файл да използваше package keyword-a 
	
	Характеристики относно пакетите:
	- Всеки Java Клас се намира в някакъв пакет, дори и да не го укажем изрочно 
	- Пакетът се указва в началото на сорс файл с ключовата дума package, декларацията за пакет, винаги трябва да е на първия ред 
	- Ако липсва package декларация, класът е в пакета по подразбиране (който няма лошо име), това е лоша практика 
	
	Защо ако се намира в пакета по подразбиране е лоша практика:
	- липса на организация
	- проблеми с достъпа: класовете от пакета по подразбиране не могат да бъдат импортиране и използване в класове, които са в нормални именувани пакети 
	- риск от конфликти 
	
	Пример как да правиш пакет: package bg.sofia.fmi.Class;
	
* Достъп до клас от друг пакет 

	Трябва да кажем на файла откъде да заредеи външните класове, които иска да ползва. Това се случва с import декларацията 
	
	Всеки Java клас автоматично може да използва два типа други класове:
	- Класовете от собствения пакет
	- Класовете в пакета Java.lang: Този пакет съдържа класовете като String, System, Math, Integer. Те се използват много често и езика ги прави достъпни навсякъде
	
	Ако искаме външен клас да има достъп до клас в някой друг пакет има два варианта:
	- Чрез import декларацията: Това е най-препоръчителния начин, след package декларацията се добавят редове import базирано на кой класове ще искаме да ползваме
	- Чрез пълното му име на външния клас: Така можем да избегнем import, но това не се препоръчва
	
	Има два начина да импортваме:
	- Импортиране на конкретен клас: import java.util.ArrayList Това е препоръчителната практика, защото показва точно и ясно кои класове се използват от даден пакет
	- импортиране с wildcard (*): import java.util.* това означава импортирай всички публични класове от пакета java.util
	
	Прието е също импортите да се подреждат по лексикографен ред 
	
	Виж ImportingExample.java
	
* Статичен импорт
	
	import static позволява да изпълним статични методи и променливи от друг клас, без да изписваме името на класа всеки път 
	
	Стандартния начин да достъпваме статични член-данни и методи е с префикс: името на класа и точка и след това името на метода/член-данната 
	
	import static позволява статичните членове да се използват директно по имената си 
	
	Примери:
	import static java.lang.Math.PI;
	import static java.lang.Math.cos;
	...
	double r = cos(PI * 10.0);
	
* Модификатори за достъп 

	Модификаторите за достъп в Java са ключови думи определящи видомостта на класовете, променливите и методите. 
	Те са като нива за сигурност или поверителност на кода.
	
	Модификатори за достъп за класове от най-високо ниво (top level class, тоест който не е вложен в друг клас)
	Има само две възможности:
	- public: Класът е публичен и може да бъде достъпен от всеки друг клас във всеки друг пакет.
	- без модификатор: Класът е достъпен само за класовете в собствения си пакет, ако се опиташ да го използваш от клас в друг пакет ще се получи грешка
	
	Модификатори за достъп за членове на класа (За член-променливи и методи):
	- public: Никакви ограничения, всеки може да види и използва този член без значение къде се намира 
	- Protected: Видимо само за класовете в същия пакет, за класовете-наследници, дори и да са в други пакети 
	- no modifier / package-private: Видимо само за класовете, които се намират в същия пакет 
	- private: Видимо и достъпно само и единствено в класа, в който е дефинират. Това е основата на енкапсулацията, понеже скрива вътрешната реализация
	
* Енкапсулация

	Енкапсулацията е една от четирите основни принципа на обектно-ориентираното програмиране, като това е принципа на скриване на данни.
	Групират се данни и методи, които работят с тези данни, в един клас, като същевременно се скрива и вътрешната реализация на класа е
	
	Енкапсулацията диктува, че директният достъп до състоянието е забранен от външни за класа компоненти.
	Единствено вътрешните методи на самия клас трябва да имат правото да четат или променят неговите член-данни
	
	В Java енкапсулаципта се постига чрез използването на модификатори за достъп:
	- Data members се декларират като private. Това означава че те са достъпни само за рамките на самият клас 
	- Предоставят се публични интерфейси чрез public методите (getters, setters). Те позволяват контролиран достъп до private данните.
	
	Виж WrongEncapsulation.java 
	Виж ProperEncapsulation.java
	
* Наследяване 

	Наследяването позволява на нов клас да придобие характеристиките като данните и методите от вече съществуващ клас 
	
	Основната цел на наследяването е преизползването на код. Вместо да се пише един и същи код в няколко класове, се създава един базов клас с обща функционалност
	След това други класове могат да наследяват и да разширяват неговите възможности като се добавят нови данни или методите 
	
	Класът, който наследява, се нарича подклас или клас-наследник
	Класът, който бива наследен, се нарича суперклас или базов клас или клас-родител
	
	В Java се наследява като се използва extends. Пример: class Subclass extends SuperClass {...}. Не може да има няколко наследявания в Java 
	Класът-наследник получава достъп само до методите или член данните, които са public или protected.
	Private членовете също се наследяват, но те единствено могат да се променят или използват чрез public или protected методите на родителя
	
	Виж ExtendExample
	
* Наследяване и method overriding
	
	Method overriding позволява на един подклас да предостави своя собствена имплементация на метод, който вече е дефиниран в суперклас.
	Когато метода се извика от обект от подкласа, ще се изпълни новият метод а не този на родителя 
	
	Когато пренаписваме така методи, има няколко правила, които трябва да следваме:
	- Идентична сигнатура: Името на метода и неговите параметри (брой, тип и последователност) в подкласа трябва да са напълно идентични с тези в суперкласа 
	
	- Модификатор за достъп: Модификатора на пренаписания метод трябва да бъде или същия или по-малко ограничаващ.
	Ако примерно в суперкласа метода е с protected, тогава пренаписания метод може да бъде или с public или с protected 
	
	- Съвместим тип на връщаната стойност: Ако метода в суперкласа връща примитив тип данни, тогава и метода в подкласа трябва да връща същия примитивен тип
	Ако обаче се връща референтен тип от метода в суперкласа, тогава метода в подкласа може да връща същия референтен тип или подклас на този референтен тип.
	Тази концепция даже се нарича return type covariance.
	
	- Анотацията @Override: Препоръчително е да пишем анотацията над дефиницията на пренаписания метод.
	Това го правим, за да може да провери компилатора дали правилата, които са описани по-отгоре са правилно спазени. Компилатора ще генерира грешка, ако нещо не е спазено
	
	Виж MethodOverridingExample.java
	
* Ключовата дума super 

	super е референция, която се използва в подклас за достъп до членове на неговия суперклас 
	
	super има няколко приложения:
	- Достъп до член-променливи на родителя
	- Извикване на конструк на родеилския клас: Използва се за извикване на конструктор от суперкласа чрез super(...)
	super(...) трябва да бъде първия ред в конструктора на подкласа, ако не се извика от прогрмаистта, Java слага автоматично default конструктора от 
	супер класа super()
	- Извикване на метод от родителския клас
	
	Допълнителни характеристики спрямо super:
	- Не нарушава енкапсулацията: чрез супер може само да се достъпват protected или public членове на родителския класм, докато private остават недостъпни.
	- Разликата му от this: this е референция към текущия обект и се подава като скрит праметър на методите, докато super не работи така.
	Super не е рефенренция към обект, super указва на компилатора да търси даден член в дефиницията на суперкласа, вместо в текущия клас.
	
* Flexible Constructor Bodies 

	Това представлява нова функционалнсот в Java, която позволява да се пише код преди извикването на super(...) или this(...) в конструктор
	Докато преди Java 22 това не беше позволено

	Кодът, който се намира преди this(...) или super(...) се нарича пролог
	Кодът, който се намира след this(...) или super(...) се нарича епилог
	
	Едно от правилата в пролога е че може да се иницилизират полета, но не трябва да четат/достъпват полетата на класа и не трябва да се викат нестатичните методи на класа 
	Може примерно да се извършват проверки, изчисления или да се присвояват стойностите на полетат от текущият обект 
	
	Виж FlexibleConstructor.java
	
* Йерархията от класове в Java 
	
	Всички класове в Java са наследници на класа java.lang.Object 
	Ако даден обект няма пряк наследник (тоест няма extend) тогава той е директен наследник на Object класа (компилатора автоматично прави така)
	
	Всеки един клас има точно един родител, който е java.lang.Object, единствено Object няма родител.
	Може да се каже че йерархията на един класове е дърво, а java.lang.Object е корена на това дърво 
	Този клас няма член данни 
	
	Следните методи на този клас са:
	- boolean equals(Object obj): Проверява дали текущият обект е равен на този подаден като параметър.
	По подразбиране метода проверява дали двете референции сочат към едно и също място в паметта, но обикновенно може да се пренапише, за да сравнява обектите по тяхното съдържание.
	
	- int hashCode(): Връща цяло число (hashcode), което представлява обекта. Този метод е ключов за работа с колекции HashMap и HashSet. Ако два обекта са равни според equals(), то те имат еднакакуъв hashCode()
	Трябва също да сме го предефинирали, ако сме предифинирали equals()
	
	- String toString(): Връща текстовото представяне на обекта чрез String. Хубаво е да се пренаписва този метод, за да представя четима информация за състоянието на обекта 
	
	- Object clone(): Създава и връща точно копие на текущия обект, за да се използва е нужно имплементиране на Cloneable интерфейса 
	
* Оператора instanceof

	Този оператор се използва за проверка на типа на даден обект. Проверява дали референцията отляво е инстанция на класа или на интерфейса и връща булева стойност 
	
	Разгледай следните случай:
	- Student ivan = new Student("Ivan"); ivan instanceof Student -> true; ivan instanceof Human -> true (да кажем, че Student extends Human)
	- null instanceof <ClassName> -> false, null не е инстанция на нещо и винаги ще е false това 
	- <AnyClassInstance> instanceof Object -> true, винаги ще е вярно, защото всеки обект наследява Object 
	
* Ключовата дума final 

	Думата final може да се използва при няколко ситуации:
	- ако е в декларацията на променлива я прави константна 
	- ако тя е в декларацията на метод, този метод не може да бъде overrid-вам 
	- ако е в декларацията на клас тогава този клас не може да бъде наследяван
	
* Наследяване 

	Наследяването дава възможноста на една референция да се отнася към обекти от различни класове и да извиква правилния метод за всеки от тези класове
	
	В контекста на ООП това позволява един обект да бъде третиран като инстанция на своя собствен клас, на неговия родител или като имплемнтация на интерфейс.
	Това позволява една променлива от тип родител да съхранява референция към обект от тип наследник 
	
	Когато наследяваме дадени класове, можем да пренаписваме методите им и да правят различна функционалност 
	Когато такъв метод се извиква от референция от родителски тип, JVM решава коя версия на метода да изпълни въз основа на реалния тип на обекта, а не на типа на референцията
	Този механизъм се нарича динамично свързване (dynamic binding)

	Понеже всички обекти в Java се наследяват от java.lang.Object, всяка референция към обет може да бъде присвоена от обект Object
	Това означава, че Object може да приема формата на абсолютно всичко 
	
* Разликата между method overriding и method overloading 

	Overriding е когато класът-наследник предефинира метод, който се намира в класът-родител
	overloading е когато в един клас се декларира метод, който е със същото име с друг, но имат различен брой или тип аргументи 
	
* Complile-time полиморфизим и Runtime полиморфизъм 

	Основната разлика между двете е кога се решава коя точно реализация да се изпълни - по време на компилация или по време на изпълнение на програмта
	
	Compile-time полиморфизъм
	Това е по-простия вид полиморфизъм, при който компилатора решава коя версия на метода да извика още преди програмата да се стартира, това се постига чрез претоварване на методи 
	Понеже сме създали методи с едни и същи имена но със различни сигнатури, когато е извикван един метод компилатора поглежда подадените аргумент и избира точната версия на метода
	Понеже това свързване става по време на компилация се нарича още и статично свързване (static binding)
	Виж CompilerTimePolymorphism.java
	
	Runtime полиморфизъм 
	Това е по-мощната форма на полиморфизъм, при която решението коя версия на метода да се изпълни се взима по време на изпълненеи на програмата от JVM. Това се случва чрез наследяване и overriding на методи 
	Нека имаме родител клас с метод и неговите наследници са пренаписали метода, за да има друга функционалност. Може да създадем референция от родителския тип, която да сочи към обект от типа на наследника.
	Когато извикаме метода през тази референция, JVM проверява какъв е реалният обект и извиква неговата версия на метода. Това се нарича динамично свързване (dynamic binding)
	
	Виж RuntimePolymorphism.java 
	
* Абстрактен клас 

	Абстракния клас е специален тип клас, който е като шаблон за други класове. Той не може да бъде инстанциран и е предназначен да бъде наследяван 
	
	Един асбтрактен клас се дефинира с abstract, като това казва на компилатора, че този клас е не пълен и не може да се използва за създаване директно 
	
	Абстракния клас има абстрактни методи, който са само декларирани и нямат имплементация.
	Всеки клс който наследи абстрактен клас е задължен да предостави имплементация всички негови абстрактни методи 
	
	Виж AbstractClassExample.java
	
* Интерфейс

	Интерфейсът описва какво трябва да прави един клас, обаче без да казва как точно го прави, тоест дефинира набор от задължителни поведения.
	
	Основните характеристики на един интерфейс:
	- Сувкупност от декларации на методи без имплементации: Основната цел на интерфейса е да декларира методи, които нямат имплементация.
	Тогава всеки клас който реши да имплементира този интерфейс, може сам да предостави реализация на декларирани методи
	
	- Описват формалното поведение, без да го имплементират
	- Може да съдържат static final член променливи: Всички променливи, които се дефинират в интерфейса стават автоматично final public static.
	Това означава че те са константи, които може да се достъпват чрез името на интерфейса и не могат да бъдат променяни.
	
	Виж InterfaceExample.java
	
* Допълнителни характеристики към интерфейсите 

	Ето няколко характеристики относно методите на интерфейсите:
	- Методите на интерфейса автоматично стават public и abstract. Компилатора автоматично приема, че този метод е public и abstract, така че не е нужно да се пише.
	Въпреки това тези модификатори могат и да се слагат експлицитно (тоест ръчно да си ги пишеш)
	- Понеже и самите методи на интерфейса са abstract, те не могат да бъдат и final 
	
	Няколко свойства относно наследяването на интерфейсите:
	- Един интерфейс може да наследи един или повече интерфейси, това се случва с extend 
	- Когато един интерфейс наследява друг, той наследява всички декларации на методи и константи от родителя.
	Всеки клас, който имплементира дъщерния клас, ще трябва и да имплементира методите от родителския клас 
	
	Между интерфейсите и техните имплементация може да се случат следните неща:
	- Един интерфейс не може да се инстанцира: Това е защото интерфейса е чиста абстрактна спецификация и не съдържа имплементации
	- Можме да инстанцираме класове, които имплементират тези интерфейси
	
	- Можем да присвояваме инстанция на клас на променлива от тип интерфейс, който класът имплементира:
	Това е реално полиморфизма при интерфейсите. Може да имаме променлива от типа на интерфейса, която сочи към обекти от кой да е клас, стига той да го имплементира 
	
	- Можем да проверяваме чрез instanceof дали даден клас имплементира интерфйес
	- Един клас може да имплементира множество интерфейси
	- Ако даден клас декларира че имплементира интерфейс той трябва ИЛИ да дефинира всичките методи на интерфейса ИЛИ да бъде деклариран като абстрактен 
	- Ако променим сигнатура на метода в клас, който имплементира интерфейс, трябва и да сменим самата декларация в интерфейса 
	
* Default методите в интерфейсите 

	default метода в интерфейс има имплементация по подрзбиране. Идеята е да може да се добавя функционалност към вече съществуващи интерфейси 
	
	Основни характеристики:
	- Има имплементация и default модификатор: За да декларираме такъв метод и после да го дефинираме трябва да използваме default като тя седи пред типа на връщане 
	- Наследяване и пренаписване: Класовете, които имплементират интерфейса, които имат дефинират default метод го наследяват автоматично.
	- Възможност за предефиниране: Ако дефиницията на метода не е подходяща за даден клас, тя винаги може да се пренапише (overriding)
	
	Ако един клас наследи две или повече еднакви default имплементации трябва да се направи друга версия на метода.
	Правила при конфликт на default метода:
	- Ако два или повече имплементирани интерфейси имат default метод с еднаква сигнатура, класът трябва задължително да предефинира този метод 
	- Може да се укаже от кой родителски интерфейс да се използва default метода като се използва <nameOfInterfaca>.super.<nameOfDefaultMethod>()
	
* Статични методи в интерфейсите 

	Статичният метод в интерфейс е свързан с интерфейса като цяло, а не с конректен обект на клас 
	
	Те са подобни на статичните методи в класовете, тоест те принадлежат на самият интерфейс и могат да се достъпват така <nameOfInterface>.<nameOfStaticMethod>();

	Разликата с default е, че статичните методи не се наследяват от класовете, които имплементират интерфейса и съответно не могат да бъдат пренаписани
	
* Private методи в интерфейсите 

	Позволяват преизползването на код и избягването на дублиране в рамките на самия интерфейс, без да се излага тази логика отвън 
	
	След като са добавили static и default методите в интерфейсите, самите интерфейси са почнали да имат по-сложна логика и се случва така, че
	един и същи интерфейс се нуждае от една и съща помощна функционалност, което води до повтаряне на код. Именно private методите решават точно този проблем
	
	Основна характеристика:
	- Този private метод е напълно скрит от външения свят. Той не може да бъде извикван от класовете, които имплементират интерфейсите
	Единственото място от което може да бъде извикан е от друг метод в същия интерфейс 
	
* Допълнителни термини относно интерфейсите 

	Интерфейс, който не съдържа нито един метод се нарича маркере 
	
	Интерфейс, който съдържа само един публичен абстрактен метод се нарича функционален, обаче може да съдържа колкото си иска default или static методи 