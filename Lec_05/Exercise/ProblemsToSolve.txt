* 1ва задача (Пример за Bridge метод + обяснение какво се случва на ниво компилатор)
	
	Да се направи:
	- Създай един генеричен клас с един тип <T>, който да се казва Box с един private T value и един setter 
	- Създай един клас BoxOfInt, който наследява Box<Integer> и в него да има една private Integer value и да се override-не setter от суперкласа 
	- Да се създаде референция от супер клас към дете и да се извика този сетър + обяснение какво се случва на комилаторно ниво 
	
* 2ра задача (Пример за генеричен клас който неговия тип наследява Number)

	Да се направи:
	- Създай един Container клас с един параметризиран тип, които наследява Number (не е нужно дори да има състояние или поведение)
	- В този клас да има main функция и създай няколко обекта с типове, който са наследици на Number 
	- Направи обект с тип, който не е наследник на Number и виж защо няма да се компилира + обяснение 
	
* 3та задача 

	Да се направи:
	- Един клас Pair с типове <K, V>, който ще има ключ, стойност и сетъри и гетъри и стринг метода
	- Да се направи друг клас в същия файл, който да се казва Util и да има статичен метод areEquals, който има параметърни типове <K,V> и да приема два Pair<K,V>
	да ги сравнява по ключове и стойности 
	- Създай и в Pair класа един main метода, в който да създадеш няколко обекта от Pair и да отговориш на въпроса защо не можем да извикаме Util.areEquals за Pair обекти с различни параметри
	
* Задача 4 

	Направи само прост generic record с типове K и V, като има елементи K key И V value 
	
* Задача 5

	Да се направи:
	- Интефейс Shape с един метод: double area();
	- Да се направи клас rectangle, който имплементира Shape и Comparable<Shape>, този клас да има състояние double length, widht.
	Допълнително да има getters, Конструктор и да имплементира toString метода 
	- Да се направи клас Square, който наследява Rectangle и в него да се пренапише toString метода и да има конструктор
	- Да се направи клас ShapeUtils, който да има функция с типизиран тип, който имлементира Shape и Comparable (тези който са имплементирали comparable да са негови родители),
	приема масив от T и да се намери елемента с най-голяма area и да се върне 
	- Да се тества 
	
* Задача 6 

	- Да се направи нормален клас LivingThing (в него може и нищо да няма)
	- Да имаме клас Human с име, конструктор и гетър като той наследява LivingThing 
	- Да имаме Student клас, който наследява Human И добавя към нето int fn, направи и консртруктор и пренапиши toString 
	- Да се направи клас FMIStudent, който наследява Student, но единствено има конструктор 
	
	- Да се направи клас GenericsPlayground 
	- да има private static void getHumans, който приема List от типове който наследяват Human.
	В този метод трябва да се принтира името на всеки един елемент и да се обясни защо можем само да взимаме, но не и да слагаме елементи 
	
	- Да се направи private static void putHumans, с List, който приема типове, който са или Human или негови наследници.
	В този метод добави различни елементи от Student, Human или FMIStudent и обясни защо може да се слагат елементи вътре
	Обяснение също защо не можем да вземем елементи от там 
	
	- Да се направи метод private static int neitherGetNorPut, който приема лист от неопределен тип
	Да се вземе нулевия елемтен в Object и да се добави null в него (да се обясни защо можем само това да вземем и само това да сложим)

	
