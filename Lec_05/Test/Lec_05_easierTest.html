<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест по Java Generics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
        }
        .quiz-card {
            background-color: white;
            border-radius: 16px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .answer-btn {
            border: 1px solid #d1d5db;
            transition: background-color 0.3s, border-color 0.3s, color 0.3s, transform 0.2s;
            text-align: left;
        }
        .answer-btn:hover:not(:disabled) {
            background-color: #f3f4f6; /* Lighter gray on hover */
            border-color: #60a5fa; /* Blue border on hover */
            transform: translateY(-2px);
        }
        .answer-btn:disabled {
            cursor: not-allowed;
            opacity: 0.9;
        }
        .correct {
            background-color: #d1fae5 !important; /* Green-100 */
            border-color: #10b981 !important; /* Green-500 */
            color: #065f46; /* Green-800 */
        }
        .incorrect {
            background-color: #fee2e2 !important; /* Red-100 */
            border-color: #ef4444 !important; /* Red-500 */
            color: #991b1b; /* Red-800 */
        }
        .rationale {
            background-color: #f9fafb; /* Gray-50 */
            border-left: 4px solid #60a5fa; /* Blue-400 */
        }
        .control-btn {
            transition: background-color 0.3s, transform 0.2s;
        }
        .control-btn:hover {
            transform: translateY(-2px);
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div id="quiz-container" class="quiz-card w-full max-w-3xl p-6 md:p-8">
        <div id="quiz-header" class="mb-6">
            <h1 class="text-3xl font-bold text-gray-800 text-center">Тест по Java Generics</h1>
            <div id="progress-container" class="mt-4 w-full bg-gray-200 rounded-full h-2.5">
                <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <p id="progress-text" class="text-center text-sm text-gray-500 mt-2">Въпрос 0 от 50</p>
        </div>

        <div id="question-area">
            <h2 id="question-text" class="text-xl font-semibold text-gray-700 mb-6 min-h-[6rem]">Зареждане...</h2>
            <div id="answer-buttons" class="grid grid-cols-1 gap-4">
                <!-- Answer buttons will be generated here -->
            </div>
        </div>

        <div id="rationale-container" class="mt-6 p-4 rounded-lg rationale hidden">
            <p id="rationale-text" class="text-gray-700"></p>
        </div>
        
        <div id="results-container" class="text-center hidden">
            <h2 class="text-2xl font-bold text-gray-800">Тестът приключи!</h2>
            <p id="score-text" class="text-4xl font-bold my-4 text-blue-600"></p>
            <p id="score-message" class="text-lg text-gray-600 mb-6"></p>
            <button id="restart-btn" class="control-btn bg-blue-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-600">
                Започни отначало
            </button>
        </div>

        <div class="mt-8 flex justify-end">
            <button id="next-btn" class="control-btn bg-gray-800 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-900 hidden">
                Следващ въпрос
            </button>
        </div>
    </div>

    <script>
        const quizData = { "questions": [ { "questionNumber": 1, "question": "Кое от изброените НЕ е ключово предимство на използването на Generics в Java?", "answerOptions": [ { "text": "По-добра производителност", "rationale": "Generics помагат за избягване на ненужни каствания по време на изпълнение, което може леко да подобри производителността.", "isCorrect": false }, { "text": "Безопасност на типовете (Type Safety)", "rationale": "Това е едно от основните предимства, тъй като грешките, свързани с типове, се откриват по време на компилация, а не по време на изпълнение.", "isCorrect": false }, { "text": "Автоматично управление на паметта", "rationale": "Управлението на паметта в Java се извършва от Garbage Collector и не е пряко свързано с Generics.", "isCorrect": true }, { "text": "Преизползване на код", "rationale": "Generics позволяват създаването на класове и методи, които работят с различни типове данни, без да се налага пренаписване на кода.", "isCorrect": false } ], "hint": "Помислете коя от функционалностите се управлява от друга част на Java екосистемата, а не от системата за типове." }, { "questionNumber": 2, "question": "Какъв проблем възниква често при работа с колекции преди въвеждането на Generics (преди Java 5)?", "answerOptions": [ { "text": " невъзможност за добавяне на null елементи", "rationale": "Добавянето на null стойности винаги е било възможно в колекциите.", "isCorrect": false }, { "text": "Нужда от изрично кастване (type casting) и риск от ClassCastException", "rationale": "Тъй като всички елементи са били третирани като Object, се е налагало постоянно кастване при извличането им, което е носело риск от грешки по време на изпълнение.", "isCorrect": true }, { "text": "Колекциите са имали фиксиран размер", "rationale": "Динамичният размер е характеристика на колекции като ArrayList, която съществува и преди Generics.", "isCorrect": false }, { "text": "Синхронизацията на нишки е била невъзможна", "rationale": "Синхронизацията се управлява с други механизми в Java и не е свързана с Generics.", "isCorrect": false } ], "hint": "Спомнете си какъв е бил общият тип на всички елементи в една колекция." }, { "questionNumber": 3, "question": "Какво представлява \"диамантеният оператор\" (<>) въведен в Java 7?", "answerOptions": [ { "text": "Синтаксис за създаване на анонимни класове", "rationale": "Анонимните класове се създават с различен синтаксис, обикновено при имплементиране на интерфейс или наследяване на клас.", "isCorrect": false }, { "text": "Начин за извикване на множество конструктори едновременно", "rationale": "Този оператор не е свързан с извикването на конструктори.", "isCorrect": false }, { "text": "Оператор за побитово сравнение", "rationale": "Операторите за побитово сравнение са други (напр. &, |).", "isCorrect": false }, { "text": "Съкратен синтаксис, при който компилаторът сам извежда генеричния тип при създаване на инстанция", "rationale": "Той позволява да се пропусне повторното изписване на типа отдясно на присвояването, тъй като компилаторът го знае от декларацията на променливата.", "isCorrect": true } ], "hint": "Този оператор улеснява и съкращава кода при инстанциране на генерични класове." }, { "questionNumber": 4, "question": "Според общоприетите конвенции, кой параметър за тип се използва за означаване на ключ (key) в структури като Map?", "answerOptions": [ { "text": "E", "rationale": " 'E' обикновено се използва за 'Element' в колекции.", "isCorrect": false }, { "text": "T", "rationale": "'T' се използва за 'Type', когато няма по-специфично наименование.", "isCorrect": false }, { "text": "V", "rationale": "'V' се използва за 'Value' (стойност) и обикновено върви в комплект с ключа.", "isCorrect": false }, { "text": "K", "rationale": "'K' е стандартното обозначение за 'Key' (ключ).", "isCorrect": true } ], "hint": "Помислете за двойката 'ключ-стойност'." }, { "questionNumber": 5, "question": "Каква е основната разлика между генеричен тип на клас (напр. `class Box<T>`) и генеричен тип на метод (напр. `<E> void myMethod(E element)`)?", "answerOptions": [ { "text": "Генеричният тип на метода е видим в целия клас, а този на класа - само в метода.", "rationale": "Всъщност е обратното - типът на класа е видим навсякъде в инстанциите на класа.", "isCorrect": false }, { "text": "Генеричният тип на класа (`<T>`) е видим в целия клас, докато този, дефиниран от метода, съществува само в рамките на метода.", "rationale": "Това е правилната дефиниция. Типът на метода има локална видимост само в самия метод.", "isCorrect": true }, { "text": "Само генеричните типове на класове могат да бъдат статични.", "rationale": "Всъщност методите могат да бъдат статични и генерични, но те не могат да използват генеричния тип на класа.", "isCorrect": false }, { "text": "Няма разлика, те са взаимозаменяеми.", "rationale": "Има фундаментална разлика в тяхната видимост (scope) и приложение.", "isCorrect": false } ], "hint": "Помислете за обхвата (scope) на видимост на параметъра за тип." }, { "questionNumber": 6, "question": "Какво означава понятието \"инвариантност\" (invariance) при генеричните типове в Java?", "answerOptions": [ { "text": "Ако `Dog` е наследник на `Animal`, то `List<Dog>` се счита за наследник на `List<Animal>`.", "rationale": "Това описва ковариантност, а не инвариантност.", "isCorrect": false }, { "text": "Ако `Dog` е наследник на `Animal`, то `List<Animal>` се счита за наследник на `List<Dog>`.", "rationale": "Това описва контравариантност.", "isCorrect": false }, { "text": "Дори `Dog` да е наследник на `Animal`, типовете `List<Dog>` и `List<Animal>` не са свързани и са несъвместими.", "rationale": "Точно това е определението за инвариантност. В Java генеричните типове са инвариантни по подразбиране.", "isCorrect": true }, { "text": "Типът `List<Dog>` може да се променя динамично към `List<Cat>` по време на изпълнение.", "rationale": "Генеричните типове са статични и се проверяват по време на компилация.", "isCorrect": false } ], "hint": "Това е най-стриктното правило за връзка между генеричните типове." }, { "questionNumber": 7, "question": "Как се постига ковариантност в Java и какво е основното ѝ ограничение?", "answerOptions": [ { "text": "Чрез `? super Type`. Ограничението е, че не може да се чете от структурата.", "rationale": "`? super` се използва за контравариантност.", "isCorrect": false }, { "text": "Чрез `? extends Type`. Ограничението е, че не може безопасно да се добавят (пишат) нови елементи в структурата.", "rationale": "Това е правилният отговор. Можем да четем елементи като по-общия тип, но не можем да добавяме, защото не знаем точния конкретен тип на колекцията.", "isCorrect": true }, { "text": "Чрез наследяване на класа. Няма ограничения.", "rationale": "Наследяването не променя инвариантността на генеричния тип по подразбиране.", "isCorrect": false }, { "text": "Чрез `?`. Ограничението е, че може да се работи само с `Object`.", "rationale": "Това описва неограничен wildcard, който има своите специфики, но ковариантността се дефинира с `extends`.", "isCorrect": false } ], "hint": "Ковариантността позволява да третираме `List<Dog>` като `List<Animal>`. Помислете какво можем безопасно да правим с такъв списък." }, { "questionNumber": 8, "question": "В кой от следните случаи е най-подходящо да се използва `List<? super Integer>`?", "answerOptions": [ { "text": "Метод, който изчислява сумата на всички числа в списъка.", "rationale": "За четене на стойности (producer) е по-подходящо да се използва `? extends Number`.", "isCorrect": false }, { "text": "Метод, който добавя поредица от цели числа (integers) в подадения списък.", "rationale": "Това е идеалният случай за `super`. Методът е консуматор (consumer) на цели числа и може безопасно да ги добавя в списък, който е `List<Integer>`, `List<Number>` или `List<Object>`.", "isCorrect": true }, { "text": "Метод, който намира най-голямото число в списъка.", "rationale": "Това е операция за четене и сравнение, за която `? extends Number` е по-подходяща.", "isCorrect": false }, { "text": "Метод, който копира елементите от един списък в друг.", "rationale": "За копиране често се използва комбинация от `extends` за източника и `super` за дестинацията.", "isCorrect": false } ], "hint": "Спомнете си правилото PECS. Кога се използва 'Super' - когато структурата е производител (producer) или консуматор (consumer)?" }, { "questionNumber": 9, "question": "Какъв е синтаксисът за дефиниране на генеричен тип `T`, който трябва да наследява класа `Number` и едновременно да имплементира интерфейса `Serializable`?", "answerOptions": [ { "text": "`<T extends Number, Serializable>`", "rationale": "За множество ограничения се използва `&`, а не запетая.", "isCorrect": false }, { "text": "`<T super Number & Serializable>`", "rationale": "Ключовата дума `super` се използва само при wildcards, не и при дефиниране на типови параметри.", "isCorrect": false }, { "text": "`<T extends Serializable & Number>`", "rationale": "Синтаксисът изисква класът (ако има такъв) да бъде посочен първи в списъка с ограничения.", "isCorrect": false }, { "text": "`<T extends Number & Serializable>`", "rationale": "Това е правилният синтаксис. Класът е пръв, последван от `&` и интерфейсите. Ключовата дума винаги е `extends`.", "isCorrect": true } ], "hint": "Има две важни правила: кое се изброява първо и какъв символ се използва за разделяне на множеството ограничения." }, { "questionNumber": 10, "question": "Какво е \"Type Erasure\" (изтриване на типове) в Java?", "answerOptions": [ { "text": "Процес, при който компилаторът премахва всички генерични типове, които не се използват.", "rationale": "Компилаторът премахва цялата генерична информация, не само неизползваната.", "isCorrect": false }, { "text": "Процес, при който генеричната информация се запазва в байткода, за да се използва по време на изпълнение.", "rationale": "Точно обратното, информацията се изтрива от байткода.", "isCorrect": false }, { "text": "Процес, при който компилаторът заменя генеричните типове с техните ограничения или с `Object` и добавя необходимите каствания.", "rationale": "Това е точното описание. След компилация `List<String>` се превръща в `List` в байткода, а компилаторът осигурява безопасността чрез проверки и каствания.", "isCorrect": true }, { "text": "Грешка по време на компилация, когато се използва невалиден генеричен тип.", "rationale": "Това е резултат от проверката на типовете, а не самият процес на Type Erasure.", "isCorrect": false } ], "hint": "Помислете какво се случва с информацията в `<...>` след като компилаторът си свърши работата." }, { "questionNumber": 11, "question": "Защо съществуват \"суровите типове\" (raw types) като `List` вместо `List<String>` в Java?", "answerOptions": [ { "text": "За да се подобри производителността на кода.", "rationale": "Използването на сурови типове всъщност може да доведе до грешки по време на изпълнение и не предлага предимства в производителността.", "isCorrect": false }, { "text": "За обратна съвместимост с код, писан преди Java 5.", "rationale": "Това е единствената причина. Позволява на по-стар код, който не е използвал generics, да работи с по-новите версии на Java.", "isCorrect": true }, { "text": "Защото са по-гъвкави от параметризираните типове.", "rationale": "Те са по-малко безопасни и изключват проверките на компилатора, което не е гъвкавост, а риск.", "isCorrect": false }, { "text": "Те са препоръчителният начин за работа с колекции.", "rationale": "Използването им е силно непрепоръчително и компилаторът генерира предупреждения.", "isCorrect": false } ], "hint": "Помислете какво се е случило с езика Java във версия 5." }, { "questionNumber": 12, "question": "Какво ще се случи, ако се опитате да изпълните следния код?\n`List<String> strings = new ArrayList<>();`\n`List<Object> objects = strings;`", "answerOptions": [ { "text": "Кодът ще се компилира успешно без предупреждения.", "rationale": "Този код няма да се компилира, защото генеричните типове са инвариантни.", "isCorrect": false }, { "text": "Кодът ще се компилира, но ще хвърли `ClassCastException` по време на изпълнение.", "rationale": "Грешката се хваща още по време на компилация, така че кодът изобщо няма да се изпълни.", "isCorrect": false }, { "text": "Кодът няма да се компилира поради несъвместими типове.", "rationale": "Правилно. Поради инвариантността на генеричните типове, `List<String>` не е подтип на `List<Object>` и присвояването е невалидно.", "isCorrect": true }, { "text": "Кодът ще се компилира с предупреждение за \"unchecked conversion\".", "rationale": "Предупреждение за \"unchecked conversion\" се появява при присвояване от суров към параметризиран тип, а тук и двата типа са параметризирани.", "isCorrect": false } ], "hint": "Спомнете си за принципа на инвариантност." }, { "questionNumber": 13, "question": "Кое е основното предимство на `List<E>` пред масивите `E[]` по отношение на типовата безопасност?", "answerOptions": [ { "text": "Списъците са по-бързи от масивите.", "rationale": "Масивите обикновено са по-бързи за достъп до елементи, но това не е свързано с типовата безопасност.", "isCorrect": false }, { "text": "Списъците хващат грешки с типовете по време на компилация, докато масивите ги позволяват по време на изпълнение.", "rationale": "Това е ключовата разлика. Списъците са инвариантни, а масивите са ковариантни, което позволява грешки като `ArrayStoreException` по време на изпълнение.", "isCorrect": true }, { "text": "Масивите не могат да съхраняват примитивни типове.", "rationale": "Масивите могат да съхраняват примитивни типове (напр. `int[]`), докато списъците изискват обвиващи класове (wrapper classes, напр. `Integer`).", "isCorrect": false }, { "text": "Няма разлика в типовата безопасност.", "rationale": "Има фундаментална разлика, която е една от основните причини да се предпочитат списъци.", "isCorrect": false } ], "hint": "Помислете за разликата между ковариантност (масиви) и инвариантност (списъци)." }, { "questionNumber": 14, "question": "Защо следният код няма да се компилира?\n`public static <E> void createInstance(List<E> list) { E elem = new E(); }`", "answerOptions": [ { "text": "Защото `new` не може да се използва в статични методи.", "rationale": "Операторът `new` може да се използва в статични методи за създаване на инстанции на конкретни класове.", "isCorrect": false }, { "text": "Защото типът `E` е неизвестен по време на изпълнение поради Type Erasure и компилаторът не знае кой конструктор да извика.", "rationale": "Това е точната причина. JVM не знае какъв е конкретният клас, който `E` представлява, и не може да създаде негова инстанция.", "isCorrect": true }, { "text": "Защото променливата `list` не се използва.", "rationale": "Неизползваната променлива би довела до предупреждение, но не и до компилационна грешка, която забранява операцията.", "isCorrect": false }, { "text": "Защото `E` може да е интерфейс, който не може да бъде инстанциран.", "rationale": "Това е част от проблема, но по-фундаменталната причина е Type Erasure, която прави типа напълно неизвестен по време на изпълнение.", "isCorrect": false } ], "hint": "Какво знае JVM за типа `E` след като компилаторът е приложил Type Erasure?" }, { "questionNumber": 15, "question": "Кое от следните е НЕВАЛИДНА декларация в Java?", "answerOptions": [ { "text": "`List<?> list = new ArrayList<String>();`", "rationale": "Това е валидно. Списък от низове може да бъде присвоен на променлива от тип 'списък от неизвестен тип'.", "isCorrect": false }, { "text": "`List<Object> list = new ArrayList<>();`", "rationale": "Това е стандартна и напълно валидна декларация на списък от обекти.", "isCorrect": false }, { "text": "`List<String>[] arrayOfLists = new List<String>[5];`", "rationale": "Това е невалидно. В Java не може да се създават масиви от параметризиран тип поради несъвместимостта между ковариантността на масивите и инвариантността на генериците.", "isCorrect": true }, { "text": "`List rawList = new ArrayList<Integer>();`", "rationale": "Това е валидно, макар и непрепоръчително. Параметризиран тип може да се присвои на суров тип (raw type), но това води до загуба на типова безопасност.", "isCorrect": false } ], "hint": "Спомнете си едно от основните ограничения при работа с генерични типове и масиви." }, { "questionNumber": 16, "question": "Какво означава принципът PECS?", "answerOptions": [ { "text": "Private Extends, Common Super", "rationale": "Това не са правилните термини.", "isCorrect": false }, { "text": "Producer Extends, Consumer Super", "rationale": "Това е мнемонично правило, което помага да се избере правилният wildcard: 'extends' за структури, от които четем (производители), и 'super' за структури, в които пишем (консуматори).", "isCorrect": true }, { "text": "Parameter Extends, Class Super", "rationale": "Това не описва правилото за wildcards.", "isCorrect": false }, { "text": "PECS не е свързан с Generics.", "rationale": "Това е един от най-важните ръководни принципи при работа с wildcards в Generics.", "isCorrect": false } ], "hint": "Това е мнемонично правило, което ви помага да решите кога да използвате `extends` и кога `super`." }, { "questionNumber": 17, "question": "Защо статично поле в генеричен клас не може да бъде от типа на параметъра (напр. `private static T myField;`)?", "answerOptions": [ { "text": "Защото статичните полета трябва да са винаги `final`.", "rationale": "Статичните полета не е задължително да са `final`.", "isCorrect": false }, { "text": "Защото всички инстанции на генеричния клас (напр. `Box<Integer>` и `Box<String>`) споделят едно и също статично поле, което би нарушило типовата безопасност.", "rationale": "Това е точната причина. След Type Erasure има само един клас `Box`, и ако полето беше позволено, `Box<Integer>` и `Box<String>` щяха да се опитат да споделят едно поле с несъвместими типове.", "isCorrect": true }, { "text": "Защото типовият параметър `T` може да бъде само `Object`.", "rationale": "Типовият параметър `T` се заменя с конкретен тип при инстанциране.", "isCorrect": false }, { "text": "Защото статичните полета не могат да бъдат `private`.", "rationale": "Статичните полета могат да бъдат с всякакъв модификатор за достъп.", "isCorrect": false } ], "hint": "Спомнете си, че статичните членове принадлежат на класа, а не на инстанцията. Какво се случва с класа след Type Erasure?" }, { "questionNumber": 18, "question": "Каква е разликата между `Collection<?>` и `Collection<Object>`?", "answerOptions": [ { "text": "Няма разлика, те са напълно еквивалентни.", "rationale": "Има важна разлика. `Collection<Object>` е колекция, която може да съдържа само обекти от тип `Object`, докато `Collection<?>` е колекция от някакъв неизвестен, но конкретен тип.", "isCorrect": false }, { "text": "В `Collection<Object>` може да се добавя всичко, а в `Collection<?>` не може да се добавя нищо (освен `null`).", "rationale": "Това е ключовата разлика. `Collection<Object>` приема всякакви обекти. При `Collection<?>`, компилаторът не знае какъв е конкретният тип (`?` може да е `String`, `Integer` и т.н.) и затова забранява добавянето на елементи, за да гарантира типова безопасност.", "isCorrect": true }, { "text": "`Collection<?>` може да съдържа само примитивни типове, а `Collection<Object>` само обекти.", "rationale": "Колекциите в Java не могат да съдържат директно примитивни типове.", "isCorrect": false }, { "text": "`Collection<Object>` е суров тип, а `Collection<?>` е параметризиран.", "rationale": "И двата са параметризирани типове. Суровият тип би бил просто `Collection`.", "isCorrect": false } ], "hint": "Помислете за операциите по запис (добавяне). Какво знае компилаторът за типа `?`?" }, { "questionNumber": 19, "question": "Кое твърдение за `instanceof` и генеричните типове е вярно?", "answerOptions": [ { "text": "Може да се използва `instanceof` за проверка на генеричния тип, напр. `list instanceof ArrayList<Integer>`.", "rationale": "Това е невалидно и ще доведе до компилационна грешка, защото информацията за `<Integer>` е изтрита по време на изпълнение.", "isCorrect": false }, { "text": "Операторът `instanceof` не може да се използва с параметризирани типове поради Type Erasure.", "rationale": "Това е вярно. По време на изпълнение JVM вижда само суровия тип (напр. `ArrayList`) и не може да различи `ArrayList<Integer>` от `ArrayList<String>`.", "isCorrect": true }, { "text": "`instanceof` работи само с wildcards, напр. `list instanceof ArrayList<?>`.", "rationale": "Използването на wildcard тук също е забранено от компилатора.", "isCorrect": false }, { "text": "Трябва да се използва специален метод `isGenericInstanceOf()`, за да се провери типът.", "rationale": "Такъв метод не съществува в стандартната библиотека на Java.", "isCorrect": false } ], "hint": "Каква информация за генеричния тип е налична по време на изпълнение (run-time)?" }, { "questionNumber": 20, "question": "Какво ще се случи при опит за компилация на следния клас?\n`public class MyClass {`\n`  public void process(List<String> list) {}`\n`  public void process(List<Integer> list) {}`\n`}`", "answerOptions": [ { "text": "Класът ще се компилира успешно, защото методите имат различни параметри.", "rationale": "Въпреки че параметрите изглеждат различни, помислете какво се случва с тях след Type Erasure.", "isCorrect": false }, { "text": "Класът няма да се компилира, защото след Type Erasure двата метода ще имат еднаква сигнатура `process(List list)`.", "rationale": "Това е правилният отговор. За JVM, след изтриването на типовете, двата метода стават неразличими, което е забранено.", "isCorrect": true }, { "text": "Класът ще се компилира, но ще има предупреждение.", "rationale": "Това не е предупреждение, а компилационна грешка, защото нарушава основно правило на езика.", "isCorrect": false }, { "text": "Класът ще се компилира, само ако единият метод е статичен.", "rationale": "Дори единият метод да е статичен, конфликтът в сигнатурите след Type Erasure остава.", "isCorrect": false } ], "hint": "Помислете как изглеждат сигнатурите на методите за JVM, след като компилаторът е свършил работата си." }, { "questionNumber": 21, "question": "Какво е предназначението на неограничения wildcard `<?>`?", "answerOptions": [ { "text": "Да позволи добавянето на всякакви обекти в колекцията.", "rationale": "Точно обратното, той ограничава добавянето на елементи, за да гарантира безопасност.", "isCorrect": false }, { "text": "Да се използва, когато логиката на метода зависи от конкретния тип на елементите.", "rationale": "Когато логиката зависи от типа, се използва ограничен wildcard (`extends`, `super`) или конкретен типов параметър (`<T>`).", "isCorrect": false }, { "text": "Да се използва, когато логиката работи с методи от клас `Object` или не зависи от типа на елементите.", "rationale": "Това е правилната употреба. Например, за методи като `size()`, `clear()` или `toString()` на елементите, които са общи за всички обекти.", "isCorrect": true }, { "text": "Да замести напълно нуждата от `List<Object>`.", "rationale": "`List<Object>` и `List<?>` имат различни семантики и случаи на употреба.", "isCorrect": false } ], "hint": "Кога не ни интересува какъв точно е типът в една колекция?" }, { "questionNumber": 22, "question": "Кой ред код ще предизвика компилационна грешка?\n`List<? extends Number> numbers = new ArrayList<Integer>();` // Ред 1\n`Number n = numbers.get(0);` // Ред 2\n`numbers.add(new Double(3.14));` // Ред 3\n`numbers.add(null);` // Ред 4", "answerOptions": [ { "text": "Ред 1", "rationale": "Ред 1 е валиден. `ArrayList<Integer>` може да се присвои на `List<? extends Number>`, защото `Integer` е наследник на `Number` (ковариантност).", "isCorrect": false }, { "text": "Ред 2", "rationale": "Ред 2 е валиден. Можем безопасно да четем елементи от списъка, защото знаем, че те със сигурност са от тип `Number` или негов наследник.", "isCorrect": false }, { "text": "Ред 3", "rationale": "Ред 3 ще предизвика грешка. Не можем да добавяме елементи (освен `null`) в ковариантна колекция, защото компилаторът не знае какъв е точният тип (`?` може да е `Integer`, а ние се опитваме да добавим `Double`).", "isCorrect": true }, { "text": "Ред 4", "rationale": "Ред 4 е валиден. `null` може да бъде добавен към всяка генерична колекция, тъй като не носи типова информация.", "isCorrect": false } ], "hint": "Припомнете си ограниченията на ковариантните колекции (`? extends`). Какво е позволено - четене или писане?" }, { "questionNumber": 23, "question": "Кой ред код е валиден?\n`List<? super String> list = new ArrayList<Object>();` // Ред 1\n`list.add(\"hello\");` // Ред 2\n`String s = list.get(0);` // Ред 3\n`Object o = list.get(0);` // Ред 4", "answerOptions": [ { "text": "Ред 3", "rationale": "Ред 3 не е валиден. Компилаторът не може да гарантира, че `get(0)` ще върне `String`, тъй като списъкът може да е `List<Object>`.", "isCorrect": false }, { "text": "Само Ред 1 и Ред 2 са валидни.", "rationale": "Ред 1 и 2 са валидни, но трябва да проверим и останалите.", "isCorrect": false }, { "text": "Само Ред 3 и Ред 4 са валидни.", "rationale": "Ред 3 не е валиден, което прави този отговор грешен.", "isCorrect": false }, { "text": "Ред 1, Ред 2 и Ред 4 са валидни.", "rationale": "Ред 1 е валиден. Ред 2 е валиден (можем да добавяме `String`, защото е съвместим с всеки родителски тип). Ред 4 е валиден (единственото, което можем да извлечем безопасно, е `Object`). Ред 3 е невалиден.", "isCorrect": true } ], "hint": "Припомнете си ограниченията на контравариантните колекции (`? super`). Какво е позволено - четене или писане?" }, { "questionNumber": 24, "question": "Ако имате метод `void copy(List<? extends T> src, List<? super T> dest)`, кое твърдение е вярно?", "answerOptions": [ { "text": "Методът копира елементи от `dest` в `src`.", "rationale": "Според PECS, `src` е producer (`extends`), а `dest` е consumer (`super`), така че копирането става от `src` към `dest`.", "isCorrect": false }, { "text": "Методът чете елементи от `src` и ги записва в `dest`.", "rationale": "Това е точното описание на принципа PECS в действие. `src` е източник (producer), от който само четем, а `dest` е дестинация (consumer), в която само пишем.", "isCorrect": true }, { "text": "И двата списъка трябва да са от абсолютно същия тип `T`.", "rationale": "Използването на wildcards позволява гъвкавост - `src` може да е `List<Integer>`, а `dest` - `List<Number>`, ако `T` е `Number`.", "isCorrect": false }, { "text": "Тази сигнатура е невалидна и няма да се компилира.", "rationale": "Това е класически и напълно валиден пример за използване на wildcards.", "isCorrect": false } ], "hint": "Приложете правилото PECS (Producer Extends, Consumer Super) към двата параметъра." }, { "questionNumber": 25, "question": "Какво е еквивалентът на `List<? extends Object>`?", "answerOptions": [ { "text": "`List<Object>`", "rationale": "`List<Object>` е по-ограничен; той не може да приеме `List<String>`, докато `List<? extends Object>` може.", "isCorrect": false }, { "text": "`List` (суров тип)", "rationale": "Суровият тип изключва проверките за типова безопасност, докато `List<?>` ги запазва.", "isCorrect": false }, { "text": "`List<?>`", "rationale": "Тъй като всеки клас в Java наследява `Object`, 'неизвестен тип, който е наследник на Object' е същото като 'неизвестен тип'. Двете декларации са семантично еквивалентни.", "isCorrect": true }, { "text": "Няма еквивалент.", "rationale": "Има пълен семантичен еквивалент сред другите видове wildcards.", "isCorrect": false } ], "hint": "Помислете какво наследява всеки един клас в Java." }, { "questionNumber": 26, "question": "Кой е основният проблем при присвояване на суров тип към параметризиран тип, например `Box<Integer> intBox = rawBox;`?", "answerOptions": [ { "text": "Винаги хвърля `ClassCastException` по време на компилация.", "rationale": "Грешката не е компилационна, а потенциална по време на изпълнение. Компилаторът само издава предупреждение.", "isCorrect": false }, { "text": "Компилаторът издава предупреждение `unchecked conversion`, защото не може да гарантира какво има в суровия тип.", "rationale": "Това е правилният отговор. Компилаторът ви предупреждава, че правите потенциално опасна операция, защото `rawBox` може да съдържа всичко, не само `Integer`.", "isCorrect": true }, { "text": "Операцията е напълно безопасна и не генерира никакви съобщения.", "rationale": "Операцията е опасна и компилаторът ще ви уведоми за това.", "isCorrect": false }, { "text": "Води до изтичане на памет (memory leak).", "rationale": "Този тип операция не е свързана с изтичане на памет.", "isCorrect": false } ], "hint": "Как компилаторът реагира на операции, чиято безопасност не може да провери?" }, { "questionNumber": 27, "question": "Какъв тип предупреждение се генерира при извикване на генеричен метод през инстанция от суров тип?", "answerOptions": [ { "text": "`unchecked conversion`", "rationale": "Това предупреждение е за присвояване между типове, а не за извикване на метод.", "isCorrect": false }, { "text": "`raw type usage`", "rationale": "Това е общо предупреждение за използване на суров тип, но има по-специфично за този случай.", "isCorrect": false }, { "text": "`unchecked invocation`", "rationale": "Това е точното предупреждение. Компилаторът не може да провери дали типът на аргумента, подаден на метода, е коректен, защото работи със суров тип.", "isCorrect": true }, { "text": "Не се генерира предупреждение.", "rationale": "Генерира се предупреждение, защото операцията е потенциално опасна.", "isCorrect": false } ], "hint": "Предупреждението е свързано с действието 'извикване' (invocation) на метод." }, { "questionNumber": 28, "question": "Какво ще се случи при изпълнение на следния код?\n`Object[] array = new Long[1];`\n`array[0] = \"I don't fit\";`", "answerOptions": [ { "text": "Компилационна грешка на втория ред.", "rationale": "Кодът ще се компилира, защото компилаторът е заблуден от типа `Object[]`, който позволява присвояване на `String`.", "isCorrect": false }, { "text": "Ще се изпълни успешно, но `array[0]` ще остане `null`.", "rationale": "Няма да се изпълни успешно, защото се прави опит за добавяне на грешен тип в масива.", "isCorrect": false }, { "text": "Ще хвърли `ArrayStoreException` по време на изпълнение.", "rationale": "Това е правилният резултат. Макар компилаторът да пропуска грешката, по време на изпълнение JVM знае, че масивът е предназначен само за `Long` и хвърля изключение.", "isCorrect": true }, { "text": "Ще хвърли `ClassCastException` по време на изпълнение.", "rationale": "`ClassCastException` се хвърля при невалидно кастване, докато `ArrayStoreException` е специфична за грешки при съхранение в масив.", "isCorrect": false } ], "hint": "Този пример илюстрира защо масивите са по-малко типово безопасни от списъците. Помислете за ковариантността на масивите." }, { "questionNumber": 29, "question": "Как се нарича процесът, при който компилаторът заменя `T` в `class Box<T extends Number>` с `Number` в крайния байткод?", "answerOptions": [ { "text": "Инстанциране", "rationale": "Инстанциране е създаването на обект от клас.", "isCorrect": false }, { "text": "Кастване (Casting)", "rationale": "Кастването е преобразуване на тип, но процесът на замяна на генеричния тип има специфично име.", "isCorrect": false }, { "text": "Наследяване", "rationale": "Наследяването е механизъм за създаване на йерархии между класове.", "isCorrect": false }, { "text": "Type Erasure (Изтриване на типове)", "rationale": "Това е част от процеса Type Erasure, при който ограничените типове се заменят с тяхното ограничение (bound).", "isCorrect": true } ], "hint": "Това е основният механизъм, по който работят Generics в Java." }, { "questionNumber": 30, "question": "Кое от следните твърдения за статичен генеричен метод е вярно?", "answerOptions": [ { "text": "Той може да използва параметъра за тип на класа, в който е дефиниран (напр. `T` от `Box<T>`).", "rationale": "Статичните методи принадлежат на класа, а не на инстанция, и затова не могат да достъпват типовия параметър на инстанцията.", "isCorrect": false }, { "text": "Той трябва да дефинира свои собствени типови параметри, които са независими от тези на класа.", "rationale": "Това е вярно. Един статичен генеричен метод има синтаксис като `public static <E> void doSomething(E element)`.", "isCorrect": true }, { "text": "Статичните методи не могат да бъдат генерични.", "rationale": "Те могат да бъдат генерични, но със свои собствени типови параметри.", "isCorrect": false }, { "text": "Той може да бъде извикан само през инстанция на класа.", "rationale": "Статичните методи се извикват през името на класа.", "isCorrect": false } ], "hint": "Помислете за връзката между `static` и инстанциите на обекти." }, { "questionNumber": 31, "question": "В `Map<K, V>`, какво представлява `V` според конвенцията?", "answerOptions": [ { "text": "Типът на самата карта (Map).", "rationale": "Типът на картата се определя от цялата декларация `Map<K, V>`.", "isCorrect": false }, { "text": "Типът на стойностите (values).", "rationale": "Правилно, `V` е стандартното обозначение за типа на стойностите, които се съхраняват в картата.", "isCorrect": true }, { "text": "Типът на ключовете (keys).", "rationale": "За ключове се използва `K`.", "isCorrect": false }, { "text": "Типът на елементите (elements).", "rationale": "За елементи в колекции обикновено се използва `E`.", "isCorrect": false } ], "hint": "Всеки запис в една карта се състои от двойка: ключ и...?" }, { "questionNumber": 32, "question": "Кое от следните е пример за контравариантност?", "answerOptions": [ { "text": "`List<Integer> list = new ArrayList<Integer>();`", "rationale": "Това е стандартна декларация, която показва инвариантност.", "isCorrect": false }, { "text": "`List<? extends Number> list = new ArrayList<Integer>();`", "rationale": "Това е пример за ковариантност (`extends`).", "isCorrect": false }, { "text": "`List<? super Integer> list = new ArrayList<Number>();`", "rationale": "Това е пример за контравариантност (`super`). Позволява на списък от по-общ тип (`Number`) да бъде третиран като списък, който може да приема по-специфичен тип (`Integer`).", "isCorrect": true }, { "text": "`List<Number> list = new ArrayList<Integer>();`", "rationale": "Това е невалидно поради инвариантността на генеричните типове.", "isCorrect": false } ], "hint": "Контравариантността е свързана с приемането на родителски типове и се дефинира с ключовата дума `super`." }, { "questionNumber": 33, "question": "Ако имате `List<?> list`, коя операция е позволена?", "answerOptions": [ { "text": "`list.add(new Object());`", "rationale": "Не е позволено. Компилаторът не знае какъв е типът `?` и не може да гарантира, че `Object` е съвместим.", "isCorrect": false }, { "text": "`int size = list.size();`", "rationale": "Позволено е. Методът `size()` не зависи от типа на елементите в списъка и може да бъде извикан безопасно.", "isCorrect": true }, { "text": "`String s = list.get(0);`", "rationale": "Не е позволено. Не можем да сме сигурни, че елементът е `String`. Можем да го присвоим само на `Object`.", "isCorrect": false }, { "text": "`list.add(\"hello\");`", "rationale": "Не е позволено по същата причина - типът `?` е неизвестен.", "isCorrect": false } ], "hint": "Помислете кои методи на колекциите не зависят от типа на елементите, които съдържат." }, { "questionNumber": 34, "question": "Кое от следните ограничения е ВАЛИДНО за генеричен тип `T`?", "answerOptions": [ { "text": "`<T extends String, Integer>`", "rationale": "Не може да се наследяват два класа едновременно.", "isCorrect": false }, { "text": "`<T extends Runnable & Thread>`", "rationale": "Невалидно е, защото класът (`Thread`) трябва да е пръв в списъка с ограничения.", "isCorrect": false }, { "text": "`<T extends Number & Comparable & Serializable>`", "rationale": "Това е валидно. Има един клас (`Number`) на първо място, последван от интерфейси, разделени с `&`.", "isCorrect": true }, { "text": "`<T implements Comparable>`", "rationale": "Винаги се използва ключовата дума `extends`, дори когато се указват интерфейси.", "isCorrect": false } ], "hint": "Спомнете си правилата за множество ограничения: ред, ключова дума и разделител." }, { "questionNumber": 35, "question": "Какъв е резултатът от Type Erasure върху `public <T> void doSomething(T param)`?", "answerOptions": [ { "text": "Остава непроменен.", "rationale": "Type Erasure винаги променя генеричния код.", "isCorrect": false }, { "text": "`public void doSomething(T param)`", "rationale": "`<T>` също се изтрива от дефиницията на метода.", "isCorrect": false }, { "text": "`public void doSomething(Object param)`", "rationale": "Правилно. Тъй като `T` няма ограничения (unbounded), той се заменя с `Object`.", "isCorrect": true }, { "text": "Кодът няма да се компилира.", "rationale": "Това е напълно валиден генеричен метод.", "isCorrect": false } ], "hint": "С какво се заменя неограничен (unbounded) типов параметър след компилация?" }, { "questionNumber": 36, "question": "Кога е подходящо да НЕ използвате wildcard (`?`) и вместо това да използвате конкретен типов параметър (`<T>`)?", "answerOptions": [ { "text": "Когато искате да четете и да пишете елементи в една и съща колекция в рамките на един метод.", "rationale": "Точно така. Когато се нуждаем от връзка между типа на елементите, които добавяме, и тези, които извличаме, се нуждаем от конкретен тип `T`.", "isCorrect": true }, { "text": "Когато методът приема само един параметър.", "rationale": "Броят на параметрите не е определящ.", "isCorrect": false }, { "text": "Когато методът е статичен.", "rationale": "Статичните методи могат да работят както с wildcards, така и със свои собствени типови параметри.", "isCorrect": false }, { "text": "Винаги е по-добре да се използва wildcard.", "rationale": "И двата механизма имат своите специфични случаи на употреба.", "isCorrect": false } ], "hint": "Помислете за ситуация, в която PECS не е приложим, защото трябва да правите и двете - да произвеждате и да консумирате." }, { "questionNumber": 37, "question": "Кое от следните твърдения описва най-добре връзката между `ArrayList<E>` и `List<E>`?", "answerOptions": [ { "text": "`ArrayList<E>` наследява `List<E>`.", "rationale": "`List<E>` е интерфейс, а не клас, затова не може да бъде наследен, а само имплементиран.", "isCorrect": false }, { "text": "`ArrayList<E>` имплементира `List<E>`.", "rationale": "Това е правилната връзка. `ArrayList` е конкретна реализация на интерфейса `List`.", "isCorrect": true }, { "text": "Те са напълно несвързани.", "rationale": "Те са тясно свързани чрез имплементация.", "isCorrect": false }, { "text": "`List<E>` е вътрешен клас на `ArrayList<E>`.", "rationale": "Това не е вярно, `List<E>` е самостоятелен интерфейс в `java.util` пакета.", "isCorrect": false } ], "hint": "Помислете какво представлява `List` в Java - клас или интерфейс?" }, { "questionNumber": 38, "question": "Какво е основното предимство на `void print(Collection<?> c)` пред `void print(Collection c)`?", "answerOptions": [ { "text": "Няма предимство, те са еквивалентни.", "rationale": "Не са еквивалентни. Едната версия използва параметризиран тип, а другата - суров тип.", "isCorrect": false }, { "text": "Версията със суров тип е по-бърза.", "rationale": "Няма разлика в производителността, но има голяма разлика в типовата безопасност.", "isCorrect": false }, { "text": "Версията с `<?>` запазва типовата безопасност и предотвратява предупреждения от компилатора за използване на суров тип.", "rationale": "Това е ключовото предимство. С `<?>` ние заявяваме, че сме наясно с генериците и работим безопасно, докато суровият тип изключва тези проверки.", "isCorrect": true }, { "text": "Версията с `<?>` позволява добавяне на елементи, докато другата не.", "rationale": "Всъщност и в двете е опасно или невъзможно да се добавят елементи безопасно, но по различни причини.", "isCorrect": false } ], "hint": "Как компилаторът третира код, който използва сурови типове, спрямо код, който използва параметризирани типове?" }, { "questionNumber": 39, "question": "Какъв тип параметър се използва по конвенция, когато типът трябва да бъде число?", "answerOptions": [ { "text": "T", "rationale": "`T` е общо за 'Type'.", "isCorrect": false }, { "text": "E", "rationale": "`E` е за 'Element' в колекции.", "isCorrect": false }, { "text": "V", "rationale": "`V` е за 'Value' в карти (maps).", "isCorrect": false }, { "text": "N", "rationale": "`N` е конвенцията за 'Number'.", "isCorrect": true } ], "hint": "Помислете за първата буква на английската дума за 'число'." }, { "questionNumber": 40, "question": "Защо конструкторите също могат да бъдат генерични?", "answerOptions": [ { "text": "За да могат да създават инстанции на други класове.", "rationale": "Конструкторите създават инстанции само на собствения си клас.", "isCorrect": false }, { "text": "За да могат да приемат параметри от тип, който е по-специфичен от този на класа.", "rationale": "Това е една от основните причини. Например, конструкторът може да приеме `List<Integer>` за създаване на `MyObject<Number>`.", "isCorrect": true }, { "text": "За да могат да бъдат извиквани статично.", "rationale": "Конструкторите не се извикват статично.", "isCorrect": false }, { "text": "Конструкторите не могат да бъдат генерични.", "rationale": "Те могат да бъдат генерични и да имат свои собствени типови параметри.", "isCorrect": false } ], "hint": "Помислете за случай, в който искате да създадете обект от един тип, като използвате данни от друг, свързан тип." }, { "questionNumber": 41, "question": "Кое от следните е НЕВЪЗМОЖНО да се направи поради ограниченията на Generics?", "answerOptions": [ { "text": "Да се създаде `List<List<String>>`.", "rationale": "Вложени генерични типове са напълно възможни и често използвани.", "isCorrect": false }, { "text": "Да се използва `catch (Exception<T> e)` в `try-catch` блок.", "rationale": "Не може да се хващат изключения от генеричен тип, тъй като по време на изпълнение `T` е изтрит и JVM не знае какъв тип да хване.", "isCorrect": true }, { "text": "Да се дефинира метод `<T> T identity(T arg)`.", "rationale": "Това е класически пример за валиден генеричен метод.", "isCorrect": false }, { "text": "Да се създаде клас, който имплементира `Comparable<T>`.", "rationale": "Това е стандартен начин за правене на класове сравними.", "isCorrect": false } ], "hint": "Помислете кои операции разчитат на информация за типа по време на изпълнение (run-time)." }, { "questionNumber": 42, "question": "Кой е най-точният тип за параметъра на метод, който трябва да приеме `List<Integer>`, `List<Double>` или `List<Number>` и да намери сумата на елементите?", "answerOptions": [ { "text": "`List<Number>`", "rationale": "Това е твърде ограничаващо. Няма да приеме `List<Integer>` или `List<Double>` поради инвариантността.", "isCorrect": false }, { "text": "`List<?>`", "rationale": "Това е твърде общо. Няма да можем да извикаме методи като `doubleValue()`, защото елементите ще се третират като `Object`.", "isCorrect": false }, { "text": "`List` (суров тип)", "rationale": "Това е опасно и непрепоръчително, защото губим всякаква типова безопасност.", "isCorrect": false }, { "text": "`List<? extends Number>`", "rationale": "Това е най-точният и гъвкав тип. Той приема списък от всякакъв тип, който е наследник на `Number`, и ни позволява безопасно да четем елементите като `Number`.", "isCorrect": true } ], "hint": "Методът е 'производител' (producer) на данни - той чете от списъка. Кой wildcard се използва в този случай?" }, { "questionNumber": 43, "question": "Ако `Box<T>` е генеричен клас, кое от следните е вярно?", "answerOptions": [ { "text": "`Box<String>` е подтип на `Box<Object>`.", "rationale": "Не е вярно поради инвариантността.", "isCorrect": false }, { "text": "`Box<String>` и `Box<Integer>` споделят един и същ `.class` файл по време на изпълнение.", "rationale": "Вярно е. Поради Type Erasure, по време на изпълнение съществува само един `Box.class` файл.", "isCorrect": true }, { "text": "Можем да създадем инстанция `new Box<T>()` вътре в класа.", "rationale": "Не е вярно, не можем да инстанцираме типовия параметър `T`.", "isCorrect": false }, { "text": "`Box<String>` заема повече памет от `Box<Integer>`.", "rationale": "Обектът `Box` ще заема еднакво количество памет, разликата ще е в обектите (`String` или `Integer`), които се съхраняват вътре.", "isCorrect": false } ], "hint": "Как се отразява Type Erasure на генеричните класове след компилация?" }, { "questionNumber": 44, "question": "Какъв е основният проблем на следния код?\n`void addToList(List<Object> list) {`\n`  list.add(\"text\");`\n`}`\n`List<String> myStrings = new ArrayList<>();`\n`addToList(myStrings);`", "answerOptions": [ { "text": "Методът ще хвърли `ClassCastException`.", "rationale": "Проблемът ще бъде хванат още преди изпълнението на метода.", "isCorrect": false }, { "text": "Няма проблем, кодът работи коректно.", "rationale": "Има сериозен проблем с типовете.", "isCorrect": false }, { "text": "Последният ред (`addToList(myStrings)`) ще предизвика компилационна грешка.", "rationale": "Това е проблемът. Поради инвариантността, `List<String>` не може да бъде подаден на метод, който очаква `List<Object>`.", "isCorrect": true }, { "text": "Методът трябва да е деклариран като `void addToList(List<?> list)`.", "rationale": "Ако се промени на `List<?>`, тогава `list.add(\"text\")` ще стане невалидно. Проблемът е в извикването.", "isCorrect": false } ], "hint": "Помислете за съвместимостта на `List<String>` и `List<Object>`." }, { "questionNumber": 45, "question": "Каква е целта на метода, деклариран като `public static <T extends Comparable<T>> T max(T a, T b)`?", "answerOptions": [ { "text": "Да провери дали двата обекта са еднакви.", "rationale": "За проверка на еднаквост се използва `.equals()`.", "isCorrect": false }, { "text": "Да намери по-големия от два обекта, които могат да бъдат сравнявани.", "rationale": "Точно така. Ограничението `extends Comparable<T>` гарантира, че обектите имат метод `compareTo()`, който позволява да се намери по-големият.", "isCorrect": true }, { "text": "Да копира стойността от `a` в `b`.", "rationale": "Методът връща стойност, а не променя параметрите си.", "isCorrect": false }, { "text": "Да сравни дължините на два низа.", "rationale": "Методът е генеричен и работи за всякакви сравними обекти, не само за низове.", "isCorrect": false } ], "hint": "Какво позволява интерфейсът `Comparable`?" }, { "questionNumber": 46, "question": "В Java, генеричните типове осигуряват безопасност по време на:", "answerOptions": [ { "text": "Изпълнение (Run-time)", "rationale": "По време на изпълнение информацията за генеричните типове е изтрита (Type Erasure).", "isCorrect": false }, { "text": "Компилация (Compile-time)", "rationale": "Това е ключовата роля на Generics - да позволят на компилатора да провери за грешки с типовете, преди кодът да бъде изпълнен.", "isCorrect": true }, { "text": "И компилация, и изпълнение", "rationale": "Безопасността се гарантира по време на компилация.", "isCorrect": false }, { "text": "Зареждане на класа (Class loading)", "rationale": "Проверките се случват по-рано, по време на компилация.", "isCorrect": false } ], "hint": "Кога се хваща грешка, ако се опитате да добавите `Integer` в `List<String>`?" }, { "questionNumber": 47, "question": "Кое твърдение е вярно за `List<String>` и `List<Integer>`?", "answerOptions": [ { "text": "Те са подтипове един на друг.", "rationale": "Те са напълно несвързани и несъвместими типове.", "isCorrect": false }, { "text": "Имат различни представяния в байткода след компилация.", "rationale": "Поради Type Erasure, и двата се превръщат в суров тип `List` в байткода.", "isCorrect": false }, { "text": "Те са несъвместими, въпреки че и `String`, и `Integer` са наследници на `Object`.", "rationale": "Това е вярно и е директен резултат от инвариантността на генеричните типове.", "isCorrect": true }, { "text": "Могат да се присвояват един на друг без кастване.", "rationale": "Присвояването им един на друг ще доведе до компилационна грешка.", "isCorrect": false } ], "hint": "Припомнете си основното правило за връзката между генерични типове по подразбиране (инвариантност)." }, { "questionNumber": 48, "question": "Каква е целта на следния код?\n`List list = new ArrayList<Integer>();`\n`list.add(\"error\");`", "answerOptions": [ { "text": "Да демонстрира безопасната употреба на Generics.", "rationale": "Този код е пример за опасна употреба, която заобикаля проверките на компилатора.", "isCorrect": false }, { "text": "Кодът няма да се компилира.", "rationale": "Кодът ще се компилира, но с предупреждение, защото се използва суров тип.", "isCorrect": false }, { "text": "Да покаже как използването на суров тип (`List`) премахва защитата на компилатора и позволява добавяне на грешен тип.", "rationale": "Това е точната илюстрация. Въпреки че `ArrayList` е създаден за `Integer`, променливата от суров тип `List` позволява добавянето на `String`, което ще доведе до грешка по-късно.", "isCorrect": true }, { "text": "Да покаже как работи автоматичното кастване (autoboxing).", "rationale": "Този код не е свързан с autoboxing.", "isCorrect": false } ], "hint": "Защо компилаторът позволява втората операция, въпреки че е грешна?" }, { "questionNumber": 49, "question": "Какво означава, че ковариантните типове (`? extends`) са 'read-only'?", "answerOptions": [ { "text": "Че можем само да добавяме нови елементи, но не и да ги четем.", "rationale": "Това описва 'write-only', което е характеристика на контравариантните типове.", "isCorrect": false }, { "text": "Че можем безопасно да извличаме (четем) елементи, но не и да добавяме нови (с изключение на `null`).", "rationale": "Това е правилното значение. Можем да четем, защото знаем, че всеки елемент е поне от базовия тип, но не можем да пишем, защото не знаем точния конкретен тип.", "isCorrect": true }, { "text": "Че елементите в колекцията не могат да бъдат променяни.", "rationale": "Това се отнася до неизменността (immutability) на самите обекти, а не до операциите с колекцията.", "isCorrect": false }, { "text": "Че можем да четем и пишем, но само ако типовете съвпадат точно.", "rationale": "Това е характеристика на инвариантните типове.", "isCorrect": false } ], "hint": "Помислете за примера с `List<? extends Animal>`. Можем ли да добавим `new Dog()` в него?" }, { "questionNumber": 50, "question": "Какво означава, че контравариантните типове (`? super`) са 'write-only'?", "answerOptions": [ { "text": "Че можем само да четем елементи, но не и да ги добавяме.", "rationale": "Това описва 'read-only' (ковариантност).", "isCorrect": false }, { "text": "Че не можем нито да четем, нито да пишем.", "rationale": "Можем да извършваме една от операциите безопасно.", "isCorrect": false }, { "text": "Че можем безопасно да добавяме (пишем) елементи, но не можем да ги четем безопасно (освен като `Object`).", "rationale": "Това е правилното значение. Можем да добавяме елементи от конкретния тип или негови наследници, но при четене не знаем какъв е точният родителски тип и единствената сигурна опция е `Object`.", "isCorrect": true }, { "text": "Че можем да четем и пишем без ограничения.", "rationale": "Винаги има ограничения при използването на wildcards.", "isCorrect": false } ], "hint": "Помислете за примера с `List<? super Integer>`. Можем ли да добавим `new Integer(5)` в него? А какво ще получим, ако извикаме `get(0)`?" } ] };

        // DOM Elements
        const questionArea = document.getElementById('question-area');
        const questionTextElement = document.getElementById('question-text');
        const answerButtonsElement = document.getElementById('answer-buttons');
        const nextButton = document.getElementById('next-btn');
        const restartButton = document.getElementById('restart-btn');
        const resultsContainer = document.getElementById('results-container');
        const scoreTextElement = document.getElementById('score-text');
        const scoreMessageElement = document.getElementById('score-message');
        const rationaleContainer = document.getElementById('rationale-container');
        const rationaleTextElement = document.getElementById('rationale-text');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');

        let currentQuestionIndex = 0;
        let score = 0;
        const totalQuestions = quizData.questions.length;

        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            resultsContainer.classList.add('hidden');
            questionArea.classList.remove('hidden');
            rationaleContainer.classList.add('hidden');
            nextButton.classList.add('hidden');
            document.getElementById('quiz-header').classList.remove('hidden');
            showQuestion();
        }

        function showQuestion() {
            resetState();
            const currentQuestion = quizData.questions[currentQuestionIndex];
            const questionNumber = currentQuestionIndex + 1;
            
            questionTextElement.innerHTML = `<span class="text-gray-500 font-medium">${questionNumber}.</span> ${currentQuestion.question}`;
            
            // Update progress
            progressText.innerText = `Въпрос ${questionNumber} от ${totalQuestions}`;
            progressBar.style.width = `${(questionNumber / totalQuestions) * 100}%`;

            currentQuestion.answerOptions.forEach(answer => {
                const button = document.createElement('button');
                button.innerText = answer.text;
                button.classList.add('answer-btn', 'w-full', 'p-4', 'rounded-lg', 'font-medium');
                if (answer.isCorrect) {
                    button.dataset.correct = "true";
                }
                button.dataset.rationale = answer.rationale;
                button.addEventListener('click', selectAnswer);
                answerButtonsElement.appendChild(button);
            });
        }
        
        function resetState() {
            nextButton.classList.add('hidden');
            rationaleContainer.classList.add('hidden');
            while (answerButtonsElement.firstChild) {
                answerButtonsElement.removeChild(answerButtonsElement.firstChild);
            }
        }

        function selectAnswer(e) {
            const selectedButton = e.target;
            const isCorrect = selectedButton.dataset.correct === "true";
            
            if (isCorrect) {
                score++;
            }
            
            // Show rationale
            rationaleTextElement.innerText = selectedButton.dataset.rationale;
            rationaleContainer.classList.remove('hidden');

            Array.from(answerButtonsElement.children).forEach(button => {
                setStatusClass(button, button.dataset.correct === "true");
                button.disabled = true; // Disable all buttons after an answer is selected
            });

            if (totalQuestions > currentQuestionIndex + 1) {
                nextButton.classList.remove('hidden');
            } else {
                // This is the last question, show results directly
                setTimeout(showResults, 1500); // Wait a bit before showing results
            }
        }

        function setStatusClass(element, correct) {
            clearStatusClass(element);
            if (correct) {
                element.classList.add('correct');
            } else {
                element.classList.add('incorrect');
            }
        }

        function clearStatusClass(element) {
            element.classList.remove('correct');
            element.classList.remove('incorrect');
        }
        
        function showResults() {
            questionArea.classList.add('hidden');
            rationaleContainer.classList.add('hidden');
            nextButton.classList.add('hidden');
            document.getElementById('quiz-header').classList.add('hidden');

            scoreTextElement.innerText = `${score} / ${totalQuestions}`;
            
            const percentage = (score / totalQuestions) * 100;
            let message = "";
            if (percentage === 100) {
                message = "Отлично! Всички отговори са верни!";
            } else if (percentage >= 80) {
                message = "Много добър резултат! Познавате материала отлично.";
            } else if (percentage >= 50) {
                message = "Добър опит! Имате нужда от още малко преговор.";
            } else {
                message = "Не се отказвайте! Преговорете материала и опитайте отново.";
            }
            scoreMessageElement.innerText = message;
            
            resultsContainer.classList.remove('hidden');
        }

        nextButton.addEventListener('click', () => {
            currentQuestionIndex++;
            showQuestion();
        });
        
        restartButton.addEventListener('click', startQuiz);

        // Start the quiz on page load
        startQuiz();
    </script>
</body>
</html>
