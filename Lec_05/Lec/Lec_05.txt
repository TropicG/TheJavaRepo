* Накратко какво представляват Generics

	Generics е начин да пишеш клас или метод, който е гъвкат и може да работи с различни типове данни, без да се налага да се пренаписва всеки път.
	
	Ключови предимства на тези generics:
	- Преизползване на код: не се налага да пишеш един и същи метод многократно за различни типове данни 
	- Безопастност на типовете (Type Safety): Когато примерно се създаде List<String> компилатора вижда, че в този лист има само текст, и ако добавим число
	ще се получи грешка веднага.
	- По-добра производителност 
	
* Преди използването на Generics 

	Преди е било възможно да се направи списък, но без да се уточняват данните и това не е било проблем за компилатора, защото всичко е било Object
	Ако е бил добавен елемент от int, след като се извика .next компилатора е връщал Object и този Object не може да присвуи тази данна напримерно в Integer.
	Това е карало компилатора да прави грешка и да прекрати работата си.
	
	Естествено решение на това е било да се каства при всяко усвояване, но това е досадно да го правиш всеки път.
	Но нали представи си, че примерно в този лист бе указан тип се е добавил String и после е направен опит за кастване към Integer е това ще хвърли ClassCastException
	
	Generics решават следния проблем:
	- Програмистът изразява намерението си и казва на компилатора, че създава списък, който ще съдържа само числа 
	- Компилатора гарантира коректността, ако е казано че този списък, приема само числа, при опит за вкарване на нещо друго няма да се компилира проекта 
	
	Един вид с кода List<Integer> компилатора разбира, че това е лист, който приема само числа и нищо друго 
	
* Синтаксис за писане на Generics 

	List<E> това се чете "списък от Е"
	Това показва, че генерирания клас или интерфейс е просто "шаблон", който използваме заместители като <E> за бъдещи типове данни 
	
* Пример за създаване на генеричен клас 

	public class Box<T> {
		private T value;
		
		public T getValue() {
			return value;
		}
		
		public void setValue(T value) {
			this.value = value;
		}
	}
	
	<T> е параметър за тип (type parameter), той е като заместител, който казва "Когато някой създаде обект от този клас Box, ще трябва да се уточни какъв
	тип данни ще съдържа кутията"
	
	Предимства:
	- Може да се прави повторно използване на код 
	- Има безопастност на типа (Type Safety), защото компилаторът знае какъв тип данни трябва да има във всяка генеричен клас/метод

* Създаване на инстанции 

	Box<Integer> integerBox = new Box<Integer>();
	Това е оригиналния, по-стар синтаксис, изрично посочваме типа (Integer) и отляво и отдясно, след Java 7 това писане отдясно е излишно, понеже компилатора знае
	какъв ще бъде типа на обекта 
	
	Box<Integer> integerBox = new Box<>(); (Диамантен оператор)
	Оператора <> се нарича диамантен оператор, когато се използва компилатора вижда типа на променливата отляво и сам разбера, че обекта от дясно също трябва да е Integer

* Конвенции за именуване на параметрите за тип 

	Това са следните общоприети конвенции за именуване на параметрите за тип:
	- Е означава element, използва се, когато генеричният клас представлява колекция от нещо, примерно използва се в ArrayList<E>
	- Т означава type, използва се, когато няма по-специфична връзка икли конвенция.
	- К означава key, използва се за типа на ключовете в структури от данни, които работят с двойки ключ-стойност
	- V означава value, използва се за типа на тойностите в структури от данни, които имат ключ и стойност. Винаги вървят в комплект с K
	- N означава number, използва се, когато параметъртът за тип трябва да бъде ограничен само за числови типове 
	- S,U,V се използват се, когато няма какво друго да сложим 
	
* Generic методи 

	Това са методи, които могат да работят с различни типове данни, като типът се определя при извикването на метода, а не при дефинирането на класа 
	
	Генеричните методи могат да използват типовете параметри на класа, тоест, ако имаме генеричен клас (например Box<T>), методите вътре в него могат свободно 
	да използват T като тип за своите параметри или за типа на връщаната стойност 
	
	Генеричните методи могат да добаявт нови параметри за тип, недекларирани от класа. Един метод може да бъде генеричен, дори ако класът, в който е не е.
	
	Новите параметрри за тип са видими единствено за метода, дефинирания параметър за тип от самия метод съществува само и единствено в рамките на този метод.
	
	Generic методите могат да са статични, нестатични или конструкторни:
	- нестатични: това са обикновеннните методи на един обект
	- статични: един статичен генеричен метод не може да използва параметъра за тип на класа (например Т от Box<T>), защото статичните методи не принадлежат на обект, а на клас.
	Затова винаги трябва да дефинират свои собствени типове параметри 
	- конструкторни: Един конструктор също може да бъде генеричен примерно public <N extends Number> MyObject(N numberValue)
	
* Пример за генерични методи 

	Виж Pair.java
	
	Виж Util.java
	
	Pair<Integer, String> p1 = new Pair<>(1, "apple");
	Pair<Integer, String> p2 = new Pair<>(2, "pear");
	
	Пълния начин, по който може да извикваме един generic static method 
	boolean areEqual = Util.<Integer, String>areEqual(p1, p2);
	
	По-краткия начин за извикване на статичен метод 
	boolean areEqual = Util.areEqual(p1,p2); 
	
* Ковариантност, контравариантност и инвариантност 

	Вариантността е понятие, свързано с това, как наследяването между по-сложни типове е свързано с наследяването между техните компоненти 

	Нека да имаме примерен базов клас Animal и негов наследник Dog 
	
	Инвариантност - стриктното правило 
	Инвариантността означава, че няма никаква връзка на наследяване между генеричните типове, дори ако базовите им типове имат такива.
	В Java генеричните типове като List<T> са инвариатни по подразбиране, това означава, че List<Dog> НЕ Е List<Animal>
	Инвариатността е най-сигурния, но и най-ограничаващият режим, обаче гарантира пълна безопастност на типовете 
	
	Ковариатност - приема наследник 
	Ковариатността позволява да третира една по-специфична стурктура (List<Dog>) като по-обща (List<Animal>)
	В Java ковариантността се постига чрез wildcards: ? extends, примерно List<? extends Animal> означа списък с някакъв тип, който наследява Animal 
	
	Контравариантност - приема родители
	Контравариатността е обратното на ковариантността, тя приема типове-родители. В Java това са постига чрез ? super
	Синтаксиса List<? super Dog> означава че това е списък с неизвестен тип, който е родител на Dog 

* Видове грешки срещани с инвариатност, ковариантност и контравариантност 

	Грешката, която се получава при инвариатността, е грешка при компилация поради несъвместими типове (type mismatch)
	За компилатора, типовете List<Dog> и List<Animal> са напълно не свързани и различни, дори и когато Dog наследява Animal.
	Присвояването List<Animal> animals = dogs се проваля защото List<Animal> не съвпада с List<Dog>
	Това се случва, защото генеричните типове в Java са инвариантни по подразбиране 
	
	Ковариатността позволява по-гъвкаво, но безопасно третиране на генерични типов в ситуации само за четене, нека имаме List<? extends Animal> someanimals
	Read операциите са безопасни, защото когато извикваме someAnimal.get(0) компилатораът знае, че какъвто да е точния тип (Dog или Cat) върнатия обект със сигурност е Animal
	Write операциите са пасни, защото компилатора не може да гарантира че операцията someAnimals.add(new Dog()) е безопасна, защото не знае дали оригиналния обект е List<Dog> или List<Cat>;
	
	Проблема при ковариантността е че се губи всякаква полезна информация, когато се чете от колекция. Тя става безопасна само за писане 
	Write операциите са безопасни, защото ако се извиква dogDestination.add(new Dog()) всичко ще бъде наред, компилатора знае, че Dog е валиден слой за всеки родителски тип
	Read операциите са опасни, защото компилатора не знае какъв тип ще бъде извикан от dogDestionation.get(0). Списъка може да е List<Animal> и няма никаква гаранция, освен за List<Object>

* Generic типовете и наследяване 

	Подтип на generic клас или интерфейс получаваме чрез наследяване или имплементираме или с други думи може да се създаде клас-наследник на генеричен клас, точно както би се направило с обикновен клас 
	Това ознчава, че може да се създаде GiftBox<T> който наследява Box<T>
	
	Връзката е is-a relatinship между два генерични обекта, ако техният тип е абсолютно еднакакъв, пример: ArrayList<E> имплементира List<E>
	
* Ограничения (bounded/restircted) generic типове 

	Това е начин да кажем на generic метода или клас, приема само определини типове, а не абсолютно всякакви 
	
	Единично ограничение: public <T extends Number> List<T> fromArrayToList(T[] a)
	<T extends Number> онзачава "Типът Т трябва да бъде класът Number или който и да е негов наследник"
	
	Множество ограничения (Multiple Bounds)
	public <T extends Number & Comparable> List<T> anotherMethod(T[] a)
	<T extends Number & Comparable> това означава че "Типът Т трябва да бъде наследник на Number и да имплементира Comparable"
	Важни правила относно този вид:
	- В списъка с ограничения трябва да има май-много един клас и той винаги да е първия изброен 
	- Всички останали ограничения след класът трябва да се изписват с & 
	- Винаги ключовата дума е extend въпреки че има изброени интерфейси
	
* Два примера за не генеричен код и генеричен код + обяснение за wildcard 

	private void pringCollection(Collection c) {
		for (Object e : c) {
			System.out.println(e);
		}
	}
	Този код приема всякакъв вид Collection, защото ArrayList и други го имплементиран. Обаче всеки елемент вътре в цикъла се третира като Object.
	Това нали работи за всяка колекция, но се губи информация за конкретния тип на елементите в колекцията, защото компилатора вижда че са само Object 
	
	void printCollection(Collection<Object> c) {
		for (Object e : c) {
			System.out.println(e);
		}
	}
	Този код е много по-ограничен от горния, защото се очаква Collection<Object>, тоест декларирана колекция точно да съдържа обекти от тип Object 
	Ако на този метод се подаде Collection<Integer> ще има грешка при компилация 
	
	Използвайки ? (wildcard) може да подадем към метода Collection от всякакъв тип 
	void printCollection(Collection<?> c) {
		for(Object e : c) {
			System.out.printline(e);
		}
	}
	Collection<?> се чете като колекция от неизвестен тип, това казва на компилатора, че този метод може да вземе всякакъв вид колекция, но понеже не знаем и какъв ще бъде типът,
	за по-сигърно ще третираме елементите просто като Object 
	
* Wildcards ограничени отгоре 

	Това List<? extends Number> казва на компилатора "не знам какъв точно е типът, но гарантирам, че е или Number, или негов наследник"
	Понеже компилатора знае, че всеки елемент в списъка е поне Number, тогава е напълно безопасно да си го обходиш и да третираш всеки елемент като Number 
	
	За разлика от стандартните генерични типове (<T extends ...>), които могат да имат няколко ограничения (<T extends Number & Serializable>), wildcard-ът може да има само едно ограничение 
	С други думи това няма да се компилира: List<? extends Number & Serializable> list 
	
	Пример:
	public static sumOfList(List<? extends Number> list) {
	
		double sum = 0.0f;
		for(Number current : list) {
			sum += current.doubleValue();
		}
	}
	
* Wildcards ограничени отдолу

	Концепцията за wildcards ограничена отдолу (? super Type) е предназначена да направи методите по-гъвкави, когато трябва да се добавят елементи в колкеция 
	
	List<? super Integer> казва на компилатора "Не знам какъв точно е типът, но гарантирам, че е или Integer или негов родител (като NUmber или Object)"
	
	public static void addNumber(List<? super Integer> list) {
		for(int i =0 ; i < 10; i++){
			list.add(i);
		}
	}
	
	Този тип wildcard е идеален, когато трябва да пишем стойности в една структура, обаче не може безопасно да се чете от такъв списък, защото не се знае дали списъка е List<Integer> или нещо друго 
	
* Неограничени wildcards

	Неограниченият wildcard (<?>) се използва, за да създадат методи, които работят с всякакви типове колекции, това означава "списък от някакъв неизвестен тип"
	
	Има няколко начина по който да използваме <?>:
	- Когато логика изисква само методи от Object: това е ситуация, в която искаме да извършим някакво действие върху елемените на списъка, но това действие е толкова общо, че работи за абсолютно всеки обект.
	Понеже типът е неизвестен (?) единствената гаранция, която се има е, че всеки елемент е наследник на Object. Поради това може безопасно да се използват методите на класа Object като toString(), hashCode() и equals()
	
	- Когато не се интересуваме от типа на елементите: това е ситуация, в която трябва логиката на колекцията, а не с нейните елементи.
	За пример може да се иска да се провери нейния размер или да се види дали е празна.
	
* PECS (Producer Extends, Consumer Super)

	Това е едно от най-важните правила при работа с generics в Java, то помага да се реши кога да се използва extends и кога super.
	
	Използвай wildcard с extends, когато структурата от данни е източник от който само ще се взема или четат стойности 
	Ако имаш списък от числа (List<? extends Number>), не се интересуваме дали са Integer или Doublе, но каквото и да вземем то със сигурност ще е Number 
	
	Използвай wildcard със super, когато структурата от данни е дестинация, в която само ще се слагат или записват стойности 
	Ако примерно имаме числото 7 и искаме да бъде добавено в List<? super Integer>, всички тези List<Integer> или List<Number> или List<Object> ще са достатъчно големи, за да се консумират едно Integer число 
	
	Не пишем wildcard когато едновременно искаме да вземем и да слагаме елементи в една и съща колекция, защото се нуждаем от точно определен тип
	В такъв случай, че използва стандартния generic параметър като List<T>, защото това дава гранция, че какво се сложи на T, точно такова Т ще се вземе обратно 
	
	С други думи Ковариантните типове са read-only, a контравариатните типове са write-only
	
* Разлики между различни генерични типове 

	List<Object> е списък, който може да съдържа елементи само от конкретния тип Object. В него може да се добавят елементи от всякакви обекти, тъй като всичко в Java наследява Object 
	Важното е, че на метод, който очаква List<Object> не може да се подаде List<String> или List<Integer>, защото е списък предназначен само за Object 
	
	List<T> е списък, който съдържа елементи от Т, защото Т е заместител за конкретен тип. Главно се използва, когато пишем генеричн клас или метод
	
	List<?> е списък от конкретен, но е неизвестен тип, можем да пишем гъвкави методи, който работят със всякакъв вид списък (List<String> или List<Integer>)
	Не можем безопасно да добавим елементи в List<?> (освен null), защото компилаторът не знае какъв точно е типът ? и не може да гарантира безопастността.
	
	List<? extends Object> това означава списък от неизвестен тип, който е наследник на Object. Понеже всеки клас е наследник на Object тази декларация е напълно еквивалентна с List<?>
	
* Какво прави компилатора когато види generic 

	В Java генеричните типове съществуват само по време на компилация. Компилаторът ги използва, за да рповери дали кодът е типово безопасен. След като проверката приключи, компилаторът изтрива тази информация
	
	В крайния байткод (.class файла) List<String> и List<Integer> изглеждат просто като List, защото всички генерични типове са заменени с Object и необходимите преобразувания на типовете:
	- В случая на неограничените типове или ограничени отдолу (като Т в class Box<T>) се замества с Object 
	- Ограничените типове (като T в class Box<T extends Number>) се заместват с тяхното ограничение (Number в случая)
	Цялата тази процедура се нарича Type Erasure
	
	Пример когато имаме ограничение отгоре:
	public static <T extends Shape> void draw(T shape) --(след type erasue)--> public static void draw(Shape shape)
	
* Суров тип 
	
	Суров тип е, когато използваме името на генеричен клас (като Box<T>) без да се посочва типовия аргумент в скобите <> 
	Единствената причина суровите типове да съществуват е за обратна съвместимост с по-стари версии на java (преди java 5)
	Когато обаче се използва един суров тип се изключва системата за проверка на генерични типове на компилатора 
	
	Безопасно може да се присво обект от параметризиран тип (Box<String>) на променлива от негов суров тип (Box), това е главно позволено заради обратната съвместимост.
	Примерно:
	Box<String> stringBox = new Box<>();
	Box rawBox = stringBox; това тук е позволено
	Обаче rawBox губи защитата на компилатора тук, компилатора няма да спре тя да съдържа String, но при опит за добавяне на друг тип в нея ще се счупи програмата 
	
	По принцип, може да се присвои обект от суров тип (Box) на променлива от параметризиран тип (Box<Integer>), но компилатора ще даде предупреждени unchecked conversion
	Примерно:
	Box rawBox = new Box();
	Box<Integer> intBox = rawBox; тук ще има предупреждение от компилатора 
	Има предупреждение тук, защото компилатора няма как да знае какво има в rawBox, ако примерно в rawBox после се сложи String, и после се опиташ да ги сложиш в intBox, ще имаш ClassCastException
	
	Генерира се предупреждение, ако се опитаме да изпълним generic метод през инстанция на суров тип, това предупреждение е unchecked invocation
	Box<String> stringBox = new Box<>();
	Box rawBox = stringBox;
	rawBox.setValue(8); тук ще се генерира warning-a 
	Не забравяй, ако после искаш да вземеш някаква стойност от rawBox ще ти се хвърли 
	
* Raw types и съвместимост на типовете 

	Един параметризиран тип е съвместим със своя суров тип, но не е съвместим с параметризиран тип с друг аргумент, дори и да е родителски 
	
	List<String> string = new ArrayList<>();
	List raw;
	raw = strings;
	Това е позволено, заради обратната съвместимо, всеки List<String> е в основата си List, затова може да се присвои на променлива от суров тип List.
	С това обаче, се губи типовата безопастност и компилатора ще издаде предупреждение, че се използва суров тип 
	
	Този код отдолу е забранен, защото не спазва типовата безопастност. Дори и String да е подтип на Object, List<String> не е подтип на List<Object>
	List<String> strings = new ArrayList<>();
	List<Object> objects = strings; // Представете си, че това е позволено
	objects.add(123); // Добавяме Integer в List<Object>, което е валидно
	
* Предпочитай List<E> пред масивите 

	Един от най-важните причини да се предпочита List<E> пред масивите в Java е типовата безопастност 
	Списъците хващат грешки по време на компилация, докато масивите позволяват грешки, които се хващат чак по време на изпълнение 
	
	Масивите са по-рисковани
	Object[] array = new Long[1];
	array[0] = "I dont fit in"; тук файлва runtime и се хвърля грешка ArrayStoreException
	Масивте в Java са ковариантни, тоест ако Long е подтип на Object, то Long[] се счита за подтип на Object[]
	Пъвият ред се компилира успешно, защото Long[] е вид Object[], обаче променливата array в паметта сочи към масив, който е създаден да съхранява само Long стойности.
	Обаче, когато се опитаме да добавим String (на долния ред код), компилатора е заблуден от променливата (Object[]) и пропуска грешката. Вече чак по време на изпълнеие JVM-a хвърля ArrayStoreException
	
	List<E> е по-безопасен 
	Този ред код няма да се компилира: List<Object> list = new ArrayList<Long>(); заради incompatible types.
	Грешката се хваща на секундата, защото генеричните типове в Java са инвариатни
	
* Ограничения при generic класове и интерфейси 

	Ето от някой от ограниченията, който са свръзани с generic класовете и интерфейсите:
	- Не могат да се създават инстанции от от типове параметер, защото компилатора не знае какъв конкретен клас ще замести Е по време на изпълнение.
	Поради type erasure, E се изтрива и се замества с Object, в резултат на това по време на изпълнение JVM не знае, кой конструктор да извика, защото няма гаранция че типът Е има конструктор по подразбиране изобщо
	public static <E> void append(List<E> list) {
		E elem = new E();
	}
	
	- Не могат да се декларират статични полета на клас от типа на типов параметър, защото всички инстанции на един клас споделят едно и също поле. 
	След type erasure, примерните генерични класове MobileDevice<Apple> и MobileDevice<Android> ще споделят един и същ .class файл по време на изпълнение - този на MobileDevice
	Ако беше позволено да се декларират статични полета, тогава тези два примерни класа трябваше да едно и също статично поле, но това нарушава типовата безопастност 
	public class MobileDevice<T> {
		private static T os;
	}
	
	- Не може да се правят конвертирани между типове (casts), не може да се прилага instanceof оператора с generic типове 
	instanceof извършва проверката run-time, но заради type erasure, run-time цялата информация за генеричния тип е изтрита, за JVM един ArrayList<Integer> е просто един суров тип ArrayList 
	JVM не може да направи разлика между ArrayList<Integer> и друг тип, защото информацията в <...> не съществува след компилация, следователно самата проверка list instanceof ArrayList<Integer> е невъзможна за изпълнение 
	
	- Не може да се създават масиви от параметризиран тип 
	List<Integer>[] arrayOfList = new List<Integer>[2]; това ще генерира компилационна грешка 
	
	- Не може да се дефинират два метода с формални параметри, които след изтриването на типовете (type erasure) имат еднакви сигнатури 
	public class Example {
		public void print(Set<String> strSet) {...}
		public void print(Set<Integer> intSet) {...}
	}
	Проблема тук е че след type erasure, компилатора премахва генеричниата информация (<String> и <Integer>) в резултат на това от гледна точка на JVM и дватама метода имат еднаква сигнатура
	

	
	