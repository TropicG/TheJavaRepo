* Накратко какво представляват Generics

	Generics е начин да пишеш клас или метод, който е гъвкат и може да работи с различни типове данни, без да се налага да се пренаписва всеки път.
	
	Ключови предимства на тези generics:
	- Преизползване на код: не се налага да пишеш един и същи метод многократно за различни типове данни 
	- Безопастност на типовете (Type Safety): Когато примерно се създаде List<String> компилатора вижда, че в този лист има само текст, и ако добавим число
	ще се получи грешка веднага.
	- По-добра производителност 
	
* Преди използването на Generics 

	Преди е било възможно да се направи списък, но без да се уточняват данните и това не е било проблем за компилатора, защото всичко е било Object
	Ако е бил добавен елемент от int, след като се извика .next компилатора е връщал Object и този Object не може да присвуи тази данна напримерно в Integer.
	Това е карало компилатора да прави грешка и да прекрати работата си.
	
	Естествено решение на това е било да се каства при всяко усвояване, но това е досадно да го правиш всеки път.
	Но нали представи си, че примерно в този лист бе указан тип се е добавил String и после е направен опит за кастване към Integer е това ще хвърли ClassCastException
	
	Generics решават следния проблем:
	- Програмистът изразява намерението си и казва на компилатора, че създава списък, който ще съдържа само числа 
	- Компилатора гарантира коректността, ако е казано че този списък, приема само числа, при опит за вкарване на нещо друго няма да се компилира проекта 
	
	Един вид с кода List<Integer> компилатора разбира, че това е лист, който приема само числа и нищо друго 
	
* Синтаксис за писане на Generics 

	List<E> това се чете "списък от Е"
	Това показва, че генерирания клас или интерфейс е просто "шаблон", който използваме заместители като <E> за бъдещи типове данни 
	
* Пример за създаване на генеричен клас 

	public class Box<T> {
		private T value;
		
		public T getValue() {
			return value;
		}
		
		public void setValue(T value) {
			this.value = value;
		}
	}
	
	<T> е параметър за тип (type parameter), той е като заместител, който казва "Когато някой създаде обект от този клас Box, ще трябва да се уточни какъв
	тип данни ще съдържа кутията"
	
	Предимства:
	- Може да се прави повторно използване на код 
	- Има безопастност на типа (Type Safety), защото компилаторът знае какъв тип данни трябва да има във всяка генеричен клас/метод

* Създаване на инстанции 

	Box<Integer> integerBox = new Box<Integer>();
	Това е оригиналния, по-стар синтаксис, изрично посочваме типа (Integer) и отляво и отдясно, след Java 7 това писане отдясно е излишно, понеже компилатора знае
	какъв ще бъде типа на обекта 
	
	Box<Integer> integerBox = new Box<>(); (Диамантен оператор)
	Оператора <> се нарича диамантен оператор, когато се използва компилатора вижда типа на променливата отляво и сам разбера, че обекта от дясно също трябва да е Integer

* Конвенции за именуване на параметрите за тип 

	Това са следните общоприети конвенции за именуване на параметрите за тип:
	- Е означава element, използва се, когато генеричният клас представлява колекция от нещо, примерно използва се в ArrayList<E>
	- Т означава type, използва се, когато няма по-специфична връзка икли конвенция.
	- К означава key, използва се за типа на ключовете в структури от данни, които работят с двойки ключ-стойност
	- V означава value, използва се за типа на тойностите в структури от данни, които имат ключ и стойност. Винаги вървят в комплект с K
	- N означава number, използва се, когато параметъртът за тип трябва да бъде ограничен само за числови типове 
	- S,U,V се използват се, когато няма какво друго да сложим 
	
* Generic методи 

	Това са методи, които могат да работят с различни типове данни, като типът се определя при извикването на метода, а не при дефинирането на класа 
	
	Генеричните методи могат да използват типовете параметри на класа, тоест, ако имаме генеричен клас (например Box<T>), методите вътре в него могат свободно 
	да използват T като тип за своите параметри или за типа на връщаната стойност 
	
	Генеричните методи могат да добаявт нови параметри за тип, недекларирани от класа. Един метод може да бъде генеричен, дори ако класът, в който е не е.
	
	Новите параметрри за тип са видими единствено за метода, дефинирания параметър за тип от самия метод съществува само и единствено в рамките на този метод.
	
	Generic методите могат да са статични, нестатични или конструкторни:
	- нестатични: това са обикновеннните методи на един обект
	- статични: един статичен генеричен метод не може да използва параметъра за тип на класа (например Т от Box<T>), защото статичните методи не принадлежат на обект, а на клас.
	Затова винаги трябва да дефинират свои собствени типове параметри 
	- конструкторни: Един конструктор също може да бъде генеричен примерно public <N extends Number> MyObject(N numberValue)
	
* Пример за генерични методи 

	Виж Pair.java
	
	Виж Util.java
	
	Pair<Integer, String> p1 = new Pair<>(1, "apple");
	Pair<Integer, String> p2 = new Pair<>(2, "pear");
	
	Пълния начин, по който може да извикваме един generic static method 
	boolean areEqual = Util.<Integer, String>areEqual(p1, p2);
	
	По-краткия начин за извикване на статичен метод 
	boolean areEqual = Util.areEqual(p1,p2); 
	
* Ковариантност, контравариантност и инвариантност 

	Вариантността е понятие, свързано с това, как наследяването между по-сложни типове е свързано с наследяването между техните компоненти 

	Нека да имаме примерен базов клас Animal и негов наследник Dog 
	
	Инвариантност - стриктното правило 
	Инвариантността означава, че няма никаква връзка на наследяване между генеричните типове, дори ако базовите им типове имат такива.
	В Java генеричните типове като List<T> са инвариатни по подразбиране, това означава, че List<Dog> НЕ Е List<Animal>
	Инвариатността е най-сигурния, но и най-ограничаващият режим, обаче гарантира пълна безопастност на типовете 
	
	Ковариатност - приема наследник 
	Ковариатността позволява да третира една по-специфична стурктура (List<Dog>) като по-обща (List<Animal>)
	В Java ковариантността се постига чрез wildcards: ? extends, примерно List<? extends Animal> означа списък с някакъв тип, който наследява Animal 
	
	Контравариантност - приема родители
	Контравариатността е обратното на ковариантността, тя приема типове-родители. В Java това са постига чрез ? super
	Синтаксиса List<? super Dog> означава че това е списък с неизвестен тип, който е родител на Dog 

* Видове грешки срещани с инвариатност, ковариантност и контравариантност 

	Грешката, която се получава при инвариатността, е грешка при компилация поради несъвместими типове (type mismatch)