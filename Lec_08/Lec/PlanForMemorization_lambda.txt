Неща, които да се запомнят:
- Функционалните интерфейси се интерфейси с точно един абстрактен метод (може да има default методи или static методи), отбелязва се с @FunctionalInterface анотацията

- Ламбда функцията е функцията, която няма име и не е метод на клас, още могат да се нарекът и анонимна функция

- Ето така изглежда една ламбда функция: (параметри) -> тяло
# Примери: () -> System.out.println("HelloWorld");  (a) -> System.out.println(a); (a,b) -> System.out.println(a + b)

- Типът на параметрите могат да бъдат или експлицитно или имплицитно зададени
# експлицитния начин изрично казва какъв е типът на данните: (String a, String b) -> a.compareTo(b)
# при имплицитния начин (още наречен inferred) компилатора сам се сеща за типа и може да се пише (a,b) -> a.compareTo(b) 
# Може даже когато имаме един параметър изобщо да се пропуснат скобите

- Когато има само един израз на ламбда функцията, не е нужно да бъде заобградена със {}, но ако има повече statements трябва да има return накрая

- Всяка една функция (или метод), която променя външно състояние за самата функция се нарича страничен ефект, примери за това са промяна на данни, I/O операции, хвърлняне на изключения, вика друга функция със страничен ефект
# Реално всяка една функция от тип void извършва страничен ефект

- Една функция е чиста ако: 1) няма страничен ефект 2) връща един и същи резултат за едни и същи данни
# Допълнителни характеристики към чистите функции е че резултата им може да се запазва и да се използва както и да се композират

- Функция от по-висок ред е функция, която приема функция като аргумент или връща функция като резултат

- Java е типизиран език, това означава, че и lambda изразите трябва да имат тип и техният тип е някакъв функционален интерфейс
# Реално по време на компилация ламбда изразът трябва да съответства на метод на функционален интерфейс
# Компилатора като види какви аргументи приема ламбдата и какво се връща той разбира какъв е тупа на ламбдата 

- Типовете на ламбдите (който са функционални интерфейси) се намират в пакета java.util.function и са няколко вида:
# Supllier<T> () -> T
# Consumer<T> T -> void
# Predicate<T> -> boolean
# Function<T,R> -> (T) -> R

- Supplier<T> е името на интерфейса, а Т е генеричния тип, като ламбадата функция е от вида () -> Т, тоест връща аргумент Т
# Supplier<T> има единствен абстрактен метод T get() и когато дефинираме ламбда израз, ние даваме имплементация на този метод T get()

- Consumer<T> e името на интерфейса, а T е генеричния тип, като ламбда функцията е от вида (T) -> void, тоест не връща аргумент
# Този метод взима някаква данна и извършва резултат с нея и ще е със страничен ефект, когато се дефинираме ламбдата се пиша имплементацията на void accept(T t) метода 
# Има и метода andThen(Consumer<? super T> after) който позволява да се chain-нат няколко Consumer обекта един след друг

- Predicate<T> е името на интерфейса, а T е генерияният тип, като ламбда функцията е от вида (T) -> boolean, тоест връща boolean
# Този метод взима някакви данни и извършва boolean проверка с тях, когато се дефинира ламбдата всъщност се пише имплементация на boolean test(T t) метода
# Има методи от срота на default Predicate<T> and(Predicate<? super T> other) или default Predicate<T> or(Predicate<? super T>), който позволвяат правенето на по-сложни проверки


- Function<T,R> е името на интерфейса, а T е input генеричния тип, докато R е output генеричния тип, ламбда израза има вида (T) -> R
# Този метод взима данни T и извършва R, когато се дефинира ламбдата всъщност се пише имплементация на R apply(T t) метода

- Освен тези споменатите типове за ламбда функции съществуват и други като примерно BiFunction<T,U,R> или IntFunction<R>
# BiFunction<T,U,R> има входни аргументи T,U и изходен тип R
# IntFunction<R> има входен тип int И връща R тип

- Target typing е механизма, който се ползва, когато се задава тип на ламбда израз, тоест гледа се този ламбда израз за какво се използва и как се използва

- Една ламбда функция може да достъпва променливи извън нейното тяло, това са:
    - локални променливи дефинирани във същищ метод, в които е дефинирана и ламбдата
    - член-променливи на обхващащия клас, където е дефинирана и ламбда функцията
    - статичнините член променливи на обхващащия клас
# Важно приволо е, ако се използва локална променлива дефинирана извън съотната ламбда функция тя да бъде ефективно final (тоест да не се променя стойността и след инициализиране)
# Причина това да е правило, понеже ламбда изразите доста се използват за нишки и ако има един такъв ресурс ще стане race condition между много нишки
# Друга причина е, че когато има такава локална променлива във ламбда тя е копирана върху стека на функцията, не е същата референция

- Ламбда изразите наследяват this и super контекста от обхващащия клас, тоест чрез тях могат да се достъпват член променливи

- Добри практики за ламбда функциите:
    - да са one-liners
    - да не модифицират данните за източника (това става дума когато се работи със streams)
    - да не модифицират външени променливи

- Използваме референция към функция като по-кратък начин да се напише ламбда израз
# Пример Predicate<String> filter = "Ivan"::equalsIgnoreCase();