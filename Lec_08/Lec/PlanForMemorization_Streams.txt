Важни неща, които трябва да се запомнят по тази тема:
- Интерфейсите и класовете намиращи се във java.util.Stream (Stream API-то) се предназначени за паралелна или последователна обработка на крайни или безкрайни потоци от данни
# Те са оптимизирани за бързо действие, могат да обработват данни в последователна или параллена обрабтока, има безкрайни или крайни потоци
# Един Stream може да поде разглеждай като pipeline, който притежава няколко стъпки, през който данните трябва да минат през него

- Има много различни начини, по които можем да инициализираме поток
# Stream.empty() инициализира празен поток
# Stream.of(T... values) създава поток съдържащ данните намиращи се в масива values
# Collection.stream() прави stream с данните които се намират в тази колекция
# Collection.paralllelStream() прави stream, който може да бъде достъп параллено от няколко нишки 

- Понеже Stream<T> е генеричен интерфейс, той не може да се използва за примитивни типове, затова има и streams като IntStream, LongStream, DoubleStream
# Споменават се за avarage() функцията, която връща средната стойност на числата в потока, за max(), за min() и за sum(), не забравяй те връщат Optimal

- Stream API позволява и работа със файлове и директории, като данните на файл или съдържанието на една директория могат да бъдат вакрани в обработката на един Stream
# Stream<String> lines(Path path) ще върне stream, който всеки елемент съдържа един ред от файла посочен в Path path
# Steram<Path> list(Path dir) ще върне stream, който съдържа всичко файлове и под-файлове които се намират в подадената директория, този метод не е рекурсивен
# Steram<Path> walk(Path star, FileVisitOption... options) ще върне stream, който съдържа всичко файлове който се намират от тази директория, този метод е рекурсивен

- Възможно е да се генерира безкрайн поток от псевдослучайни числа, използвайки: DoubleStream doubles(); IntStream ints();  LongStream longs();
# Не забравяй това са interfaces

- Метода Stream<T> generate(Supplier<T> supplier) може да ни създаде безкраейн стриим, който ще ни прилага само подадения supplier
- Метода static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b) може да ни създаде поток, който конкатенира подадените два потока

- Операция в един поток се нарича стъпката през която данните минават във stream pipeline-a, с други думи методите от Stream API, които приемат функциоален интерфейс, се наричат операции
# Примери са добре познатите операции .filter(), .limit(), .toMap(), .sorted()

- Операции се делят на терминиращ и междинни
# Междинните връщат нов stream обект като резултат, докато терминиращи връщат обект различен от Stream но могат и да не връщат резултат

- Фазите през които минава една обработка на stream са: 1) инициализиране на stream-a 2) данните от stream-a минават през различни междинни операции и stream резултатите се предават нататъка по веригата 3) накрая се прикючва със терминираща операция

- Междинните операции връщат нов Stream, Който съдържа същите или модифицирани елементи, като типът на елементите може да е същия или различен от предходната стъпка, делят се на:
    - филтриращи
    - сортиращи
    - map-ващи, това са операции които променят типа на потока 

- Примери за междинните операции:
    - Stream<T> filter(Predicate<? super T> predicate) взима всички данни от потока, които удовлетворяват условието подадено
    - Stream<T> limit(int limit) взима първите limit данни от stream-a 
    - Stream<T> distinct() взима discint елементите в streamа, базирано на Object.equals(Object) метода

- Map операцията е единствената междинна операция, която променя елементите на входния поток и връща нов поток с променен тип на данните
# Реално map-ващите функции приемат Function<T->R>

- FlatMap работи на принципа, че от един елемент може да се трансформира stream-a в друг поток с повече лементи

- Sorted операцията сортира елементите на дадения stream и връща нов, в които са сортирани
# Stream<T> sorted() сортира елементите по техния естествен ред, това става чрез наследяване на Comparable, но Stream sorted(Comparator<? super T> comparator) сортира по подадения компаратор

- void foreach(Consumer<? super T> action) е терминална операцията, която прилага consumer върху всеки един елемента на потока

- reduce е терминираща операцията, която може да комбинира всичките елементи на потока в един-единствен резултат
# За да работи един reduce, той примеа BinaryOperator<T,T> -> T, който върху двата тъпа T връща отново тип

- collect е терминираща операцията, която събира елементите на потока в една колекция
# Може да се подаде 

- Short-Circuiting операците са тези, които прекратяват обхождането си, когато намерят даден резултат
# Примери за това са findFirst(), findAny(), allMathc() и така нататък

- count() също е терминираща операцията, която връяа колко елемента има в потока

- Optional<T> е генеричен клас, който има за цел да подскаже дали се съдържа данна или няма данна, някои от самите методи от Stream API връщата optional, идеята е да се избегне null и NullPointerException
# примери от класа: isPresent, .get(), orElse(T default)

- Двата вида основни операции, които могат да се извършва върху потоци са Statefull и Stateless
# Някой операции като filter(), map() не им е нужно да съхраняват данни между обработката на отделните елементи на потока, тоест са Stateless
# Други методи като distinct(), limit() е нужно да запазят елементи, за да могат да сравнят, тоест са Statefull

- Изпълнението на потоците може да бъде паралелно или последователно използвайки parallel() или sequential(), но самите операции се разделят на lazy и eager изпълнение
# междинните операции са lazy, защото операции като filter() и map() не се изпълняват веднага, когато се извикват
# терминиращите операции са eaga защото те се изпълняват веднага при тяхното извикване и задействат целият pipeline

- Паралелното изпълнение е безопасно и ефективно само при statelessоперациите, защото всеки елемент се обработва независимо
- При statefull операциите като sorted() или distinct() паралелизмът създава проблеми