* Фунцкионални интерфейси 
  
    Функционланите интефейси са интерфейси с точно един абстрактен метод, понякога се наричат още и SAM (Single Abstract Method) интефейси 

    Няма проблем, освен абстракния си метод, да имат произволен брой статични или default методи
    # Един интерфейс все още се брои за функционален, дори и ако има 10 default и 5 static метода, стига да има точно един абстрактен метод

    Могат да се анотират с незадължителната анотация @FunctionInterface
    # Не е задължителна, защото Java компилатора е достатъчно умен, за да разбере, че един интерфейс е функционален, стига да има само един абстрактен метод
    # Ако решим да поставим тази анотация, компилатора ще следи това, защото ако се добави втори абстрактен метод към интерфейса, компилатора веднага ще даде грешка

    - Виж FunctionalInterfaceExample.java
    - Виж AnonymousClassExample.java 
    - Виж LambdaFunctionExample.java

* Ламбда изрази 

    Функция, която няма име и не е метод на клас, се нарича ламбда функция или ламбда израз
    # Ламбда израза е просто анонимна фунцкия, функция която се пише бързо и кратко

    Терминът идва от ламбда смятането - универсален метод за описание на изчисления (алгоритъм), който може да се използва за опсание на произволна машина на Тюринг
    
    # Ламбда изразите в съвременното програмиране са практическото приложение на много по-стара и фундаментална математическа идея

* Ламбда изрази - синтаксис 

    Ламбда функциите винаги имат тази форма: параметри -> тяло

    Списъкът с параметри се огражда с кръгли скоби (), а параметрите се разделят със запетаи. Може да е празен ()
    Примери:
    - Ако нямаме параметри () -> System.out.println("Hello");
    - Ако имаме само един параметър  (a) -> a *a;
    - Ако имаме няколко параметъра (a,b) -> a * b;

    Типът на параметрити може да бъде:
    - експилицитно зададен: Тоест изрично се казва какъв е типа (String a, String b) -> a.compareTo(b)
    - inferred: тоест компилатора сам се сеща за типа, така че не е нужно да го пишем: (a,b) -> a.compareTo(b)

    Когато има един-единствен параметер и неговият тип може да бъде пропуснат, може да се пропуснат и скобите 
    Пример:
    - Вместо да се пише (x) -> x + 1, може да се напише x -> x + 1
    # ВНИМАВАЙ: това е само за един параметър без изрично зададен тип, ако са нула или повече тогава скобите ще бъдат задължителни

    Тялото на ламбда израз се огражда с фигурни скоби {}:
    - Когато има само единствен израз, return клаузата може да се изпусне, за пример (a+b) -> a + b, компилатора автоматично ще добави return 
    - Когато имаме повече от един израз, трябва експилицитно да предоставим return клаузата. Щом се наложи да пишем {} ще трябва и да върнем стойност с return 
    
    - Виж MoreLambdaFunctionExamples.java

* Странични фунцкии 

    Накратко, това е всяко действие, което една функция (или метод) извършва, което променя някакво състояние извън самата функция
    Примери за странични ефекти:
    - Промяна на данни (външни за функцията) 
    - I/O операция 
    - Хвърляне на изключения
    - Извикване на друга функция със страничен ефект

    Може да се каже, че всеки метод в Java, който е от тип void, извършва страничен ефект
    # void методите съществуват именно за да предизвикват някакъв страничен ефект 

    - Виж SideEffectExample.java

* Чисти функции 

    Една функция е чиста, ако спазва две много стриктни правила:
    - Няма страничен ефект: Функцията не може да променя някакво състояние извън себе си, тоест не може да променя полетата на клас, да пише във файл или да печата на конзолата
    - Винаги връща един и същ резултат за един и същи аргумент: Резултатът от функцията винаги трябва да зависи от входните и параметри

    Още допълнителни характеристики:
    - Резултата и може да се запази и да се преизползва: този процес се нарича мемоизация и може драстичйо да подобри производителността
    - Извикването на функцията може да бъде заменено с резултата (referential transparency): резултата add(2,3) може да се замени с 5ца
    - Чистите функции са лесно композируеми: "Композиция" е процесът на вграждането на функции една в друга, за да се изгради по-сложна функционалност
    - Чистите функции са лесни за анализ на проблеми
    - Позволяват изчислението да се паралелизира: понеже чистите функции не променят споделеното състояние можем да ги пускаме едновременно (паралелно) на различни ядра и няма да очакваме конфликт

    Пример за чиста функция:
    public static int add(int a, int b) {
        return a + b;
    }

* Функции от по-висок разделят

    Функции от по-висок ред е концепция, която означава, че функциите се третират точно както числата или тексовите низове.
    Може да ги подаваме, да ги запазваме в променливи и да ги използваме като градивни елементи 

    Функции, които приемат като аргумент функция или връщат функция като резултат, се наричат функции от по-висок ред

    Функциите от по-висок ред предоставят средство, с което да компизираме логика, комбинирайки функции 
    Това прави кода да става много по-гъвкав, преизползваем и лесен за четен и тестване 

* Тип на ламбда изрази 

    Java е статично типизиран език, следователно и ламбда изразите също имат тип 
    # Както всяка променлива има ясно дефиниран тип още по време на компилация, ламбда изрази също имат такива типове, защото компилатора трябва да какъв е неговия тип и дали се използва правилно


    Типът на ламбда израза е някакъв функционален интерфейс
    # Тоест типът на един ламбда израз не е просто ламбда, а е функционален интефейс 
    
    По време на компилация, ламбда изразът трябва да съответства на абкстракния метод на функционалния интерфейс
    # За да можем да присвоим ламбда израз на променлива от тип "функционален интерйес", ламбда израза трябва да пасва на единствения абстрактен метод в този интерфейс

    Следвоателно, се знае типът и на праметрите на функцията, и на връщания резултат
    # Когато компилаторът види къде се използва ламвда израза, той веднага разбира какви трябва да са типовете 

    Двата основни начина за ипозлваме на ламбда изрази са:
    - Присвояване на променлива, тоест може да се декларират променливи от тип функционален интерфейс и да им се присвояват ламбда изрази
    - Подаване като аргумент на метод, отест деклариране на метод с формални параметри и го подаваме ламбда израза като аргумент 

* Стандартните функционални интерфейси 

    Типът на всеки алмбда израз е функционален интерфейс, Java ни дава готови шаблони в пакеа java.util.function
    
    Четирите най-важни и често използвани стандартни функционални интерфейси в Java са:
    - Supplier<T> () -> T
    - Consumer<T> (T) -> void
    - Predicate<T> (T) -> boolean
    - Function<T,R> -> (T) -> R 

* Suplier<T>: () -> T 

    Suplier<T> е името на интерфейса, а Т е генеричен тип, като самата ламбда функция е от вида () -> T
    Представлява операция без аргументи, която връща резултат
    Съдържа един абстрактен метод Т get() 
    # Ламбда изразът, който дефинираме, е всъщност имплементация на този единствен метдо - get()

    Пример:
    Supplier<Ingeter> supplyYear = () -> 2025;
    System.out.println(supplyYear.get()); // 2025

    Какво правим в горния пример:
    - Декларираме променлива supplyYear и казваме на Java че тази променлвиа ще е от тип Supplier
    - Самият ламбда израз връща просто годината 2025
    - За да изпълним ламбда изразът и да получим стойността от него се извиква неговия абстрактен метод .get()

    # Накратко, Supplier е като кутия, която ти дава нещо, когато я попиташ (чрез .get()) без да се налага да и даваш нищо в замяна 

* Consumer<T>: (T) -> void

    Consumer<Т>: (T) -> void означава: 
    - Консуметор като T е генеричния тип, тоест този интерфейс приема вход
    - (T) -> void e ламбда нотацията, като приема само един аргумент Т и -> void означава, че не връща никакъв резултат 
    
    Този функционален интерфйес не връща резултат като работи чрез странични ефекти
    # Понеже Consumer не връща стойност, единствената цел да извърши някакво действие с подадените му данни, именно това се нарича страничен ефект
    # Често срещан пример за страничен ефект е отпечатването на конзолата 

    Съдържа един абстрактен метод, void accept(T t )
    # Consumer има .accept() метода, точно както Supplier има .get() метода
    # реално албда израза, който се пише е имплементацията на този accept метод 
    
    Съдържа и един default метод andThen(Consumer<T> after)
    # Това е функция, която позволява свързването на няколко Consumer-a един след друг

    Пример:
    - Consumer<Double> inEUR = s -> System.out.println("EUR: " + s);
    - Consumer<Double> inUSD = s -> System.out.println("USD: " + s);
    - inEUR.accept(10.0) // EUR: 10.0
    - inEUR.andThen(USD).accept(10.0) // EUR: 10.0 USD: 10.0
    # inEUR.andThen(USD).accept(10.0) създава нов комбиниран Consumer, тогава първо се извиква accept() функцията и след това се извиква accept() на  inUSD
    
    # Накратко Consumer е интерфйес за всяка операция, която изяжда стойността и прави нещо с нея, без да връща отговор 

* Predicate<T>: T -> boolean 

    Predicate<T>: (T) -> boolean означава:
    - Т е типът на данните, които този интерфейс ще тества 
    - Приема се един аргумент Т като този интерфейс винаги връща boolean резултат

    Основни методи в този интерфейс:
    - boolean test(T t) е абстракния метод, самият ламбда израз е неговата имплементация
    - default Predicate<T> and(Predicate<? super T> other) ни позволява да комбинираме два предиката с логическо И
    - default Predicate<T> or(Predicate<? super T> other) ни позволява да комбинираме два предиката с логическо ИЛИ
    - default Predicate<T> negate() обръща самата логика на предиката, тоест логическо НЕ
    - static <t> Predicate<T> isEqual(Object targetRef) теста дали два предиката са equal базирано на Objects.equals(Object targetRef)

    Пример:
    - Predicate<Integer> isLessThan10 = i -> i < 10;
    - Predicate<Integer> isGreaterThan10 = i -> i > 0;
    - System.out.prinln(isLessThan10.and(isGreaterThan10).test(5));

* Function<T,R>: (T) -> R

    Function<T,R> : (T) -> R означав:
    - интерфейс, който описва трансформацията на данни, като Т е входния тип, докато R е изходния тип 

    Основните методи:
    - R apply(T t) е абстракния метод, ламбда изразът, който се пише е всъщност имплементацията на .apply(), който извършва информацията
    - default <V> Function<T,V> andThen(Function<? super R,? extends V>) позволява свързване на функцията, като първо се вика сегашната функция и после се вика after
    - default <V> Function<V,R> compose(Function<? super V, ? extends T> before)  позволява свързване на функцията, като първо се вика before и после apply
    - static <T> Function<T,T> identify();  която винаги връща нейния input argument 

    Пример:
    - Function<Integer, Integer> square = i -> i * i;
    - Function<Integer, Integer> subtractOne = i -> i - 1;
    - System.out.println(square.andThen(subtractOne).apply(3)); // 8
    - System.out.println(square.compose(subtractOne).apply(3)); // 4

* Други стандартни функционални интерфейси 

    Има още много (39+ интерфейси) функционални интерфейси в пакета java.util.function освен основните четири, те не са нови концепции, но са специализирани варианти на основните четири:
    - имат по-голямо бързодействие 
    - работа с два аргумента 

    Освнотните интерфейси като Function<T,R> работят само с обекти, тоест ако се подадат примитивните типове ще трябва дасе опаковат и само товари Java
    За да се справи с този проблем е предоставен интерфейса IntFunction<R> като входа е бетониран да бъде int, само изходът ще бъде от тип R 
    # Съществуавт всякакви компинации IntPredicate (приема int и връща boolean), DoubleToIntFunction (приема double и връща int) и така

    Function, Consumer, Predicate приемат само един аргумент, но съществува такива интерфейси, които приемат повече и тяхното име започва с Bi 
    BiFunction<T,U,R> приема два аргумента (T,U) и връща R като отново има абстракния метод R apply(T t, U t)
    # Естествено съществуват и BiConsumer<T,U> както и BiPredicate(T,U)

    BinaryOperator<T> е интерфейс, който приема два входа и изход от един и същи тип, реално е еквивалентен на BiFunction<T,T,T>

* Конкеткст на ламбда израз 

    Ламбда изразите нямат собствени вградени типове, тяхния тип се определя изцяло от контекста, в който се използват именно този механизъм се нарича "target typing" (типизиране според целта)
    # С други думи компилатора определя типът на ламбда израз в зависимост от контекста на употретебата му

    Това означава, че един ламбда израз като () -> System.out.prinln("Test") не е нито Runnable, нито ActionListener, докато не се опита да се използва за нещо
    Компилатора реално гледа каква е целта на ламбда израза, за да разбере какъв функционален интерфейс трябва да стане 

    Основните контекста, по който компилатора търси 'целта':
    - Инициализация или присвояване на променлива: Runnable r = () -> .. тук компилатора проверява дали ламбда израза съвпада с метода void run()
    - Параметър на метод или конструктор: myList.sort( (a,b) -> a.compareTo(b)), реално тук се вижда че се очкава методът sort() на Comparator, така че минава
    - Връщане на резултата от метдо: public Supplier<String> createSupplier() {return () -> "Hello";} компилатора вижда, че методът трябва да върне Supplier<String>
    - Cast операции

    Възможно е един и същи лабда израз да има различен тип:
    - Function<String, Integer> func = x -> 1;
    - Comparable<Double>        comp = x -> 1;

* Variable Capture 

    Един ламбда израз не е напълно изолиран, понеже той може да вижда и използва променливите които са дефинирани извън него

    Има три вида променлива, които един ламбда израз може да прихване:
    - локални променливи, които са дефинирани в същия метод, в който е дефиниран и израза
    - член-променливи на обхващащия клас, тоест променливите на класа, в който се намира метода 
    - статични член-променливи на обхващащия клас, тоест static полетата на класа 

    Ако ламбда израз използва локална променлива, декларирана извън него, тази променлива трябва да е final или ефективно final (тоест да не си променя стойността в този контекст)
    # Не може да се използва локална променлива в ламбда израз, ако тази променлива променя стойността си след като е била дефинирана
    # Ефективно final означава, че ти не си написал final, но компилатора вижда, че никога не се използва тази променлива 

    Причина за това ограничение е, че ламбда функцията може да се предава като аргумент и изпълнява в различни контексти и резултатът от изпълнението й не трябва да зависи от контекста
    # Ламбда изразите често се използват за асонхронни операции на някакви нишки, следователно ако го нямаше това ограничение щеше да се получи race condition между нишки, който искат да пипнат дадена променлива
    # Обаче когато се наложи final, Java гарантира, че ламбда изразът винаги ще вижда един и съща, непроменлвиа стойност

    Също е възможно ламбда изразът да се изпълни след като локалната променлвиа е унищожена (ако примерно метод връща такъв ламбда израз като резултат)
    # Локалните променливи живеят в stacka-a, докато ламбдите живеят в heap-a, защото са обекти
    # Напълно възможно е един ламбда израз да се опита да достъпи локална променлива след като някакъв метод е приключил, но тази памет вече е невалидна
    # Затова когато Java компилира ламбда израз, той не запазва референцията към оригиналната променлива на стека а вместо това и копира стойността и се запазва в lambda

    Пример за грешка при компилация:
    - int x = 7;
    - Function<Integer, Integer> multiply = i -> i * x;

* Ключовите думи this и super 

    Ламбда изразите нямат собствени this или super контекст, те наследяват контекста на мястото, където са дефинирани

    Ключовата дума this в ламбда израз реферира инстанцията на обхващащия клас, която се нарича още обхващаяа инстанцищ
    # Когато се изпозлва this вътре в ламбда, то не се отася за самия ламбда обект, а за инстанцията на класа, в чийто метод е написан този лмабда израз
    # Това се нарича още лексикален обхват

    Ключовата дума super в ламбда израз реферира инстанцията на родителя на обхващащия клас 
    # Следвайки същата логика, super не се отнася за родител на лмабдата(тя няма такъв), а за родителя на класа, в който е дефиниран ламбда изразът

* Ламбда изрази: добри практики

    Добри практики, когато използва ламбда изрази:
    - Препоръчва се ламбда изразите да не модифицират данните на източника 
    # Това е много важно правило, когато работим с потоци, тоест да не се променя оригиналната колкеция, от която е дошъл този поток
    # Не спазването на това правило може да доведе до ConcurrentModificationException

    - Препоръчва се ламбда изразите да не модифицрат външни променлвии
    # Резултатът от един ламбда израз трябва да зависи само от неговите входни параметри

    - Препоръчва се ламбда изразите да са one-liners

* Референции към методи 

    Референцията към метод е по-кратък и по-ясен начин да се напише ламбда израз, когато този ламбда израз просто извиква вече съществуващ метод 

    Много често в ламбда изразите просто делегираме параметрите на някой същестуващ метод 
    Пример: Comparator<String> comp1 = (s1,s2) -> s1.compareTo(s2);
    # Тук се създава един Comparator, и не прави нищо сложно, самият ламбда израз просто е делегатор, тоест е посредник

    Реферанциите към методите са удобен синтаксис, с който може да се реферира съществуващ метод на клас, използва се синтаксис ::
    Пример: Comparator<String> comp2 = String::compareTo;
    # Това се чете 'използвай метода compareTo на String класа', понеже Comparator<String> очаква 2 String параметъра, Java е достатъчно умен да се досети, че върху първия обект ще извикваме нещо за втория
    Пример: Prediate<String> filter = "Ivan"::equalsIgnoreCase();
    # Референциите са синтактична захар, не добавят нова функционалност, но правят кода по лесен за четен 
    Пример: super::equals
    Пример: String::new, String[]::new