* Java Stream API 

    Ламбда изразите, заедно с функционалните интерфейси, разширяват възможността на Java с елементи на функционалното програмиране 
    # Това означава, че ламбда изразите и функционалните интерфейси са основните инструменти, които позволяват на Java да използва концепции от функционалното програмирне

    Te позволяват предаването на поведение (функции) като параметри на библиотеки, оптимизирани за бързодействие при обработка на данни
    # Вече вместо да се подават само данни към метод, може и да му се подаде поведение, тоест какво да прави с тези данни 

    По този начин, един app developer може да се фокусира върху бизнес логиката на приложението си, оставяйки аспекти като бързодействието на авторите на въпросните библиотеки
    Една такава основна библиотека е java.util.stream

* java.util.streams 

    Интерфейсите и класовете от пакета java.util.stream (които наричаме Java Stream API) са предназначени за ефективна последователна или паралелна обработка на крайни или безкрайни потоци от данни
    Клочви характеристики:
    - Ефективна, защото е оптимизирана за бързодействие
    - Последователна или паралелна: Могат да се обработват данни елемент по елемент или Java автоматично да раздели работата на няколко нишки, за да изпозлва всички ядра на процесора
    - Крайни или безкрайни потоци: Може да се работи с колекции с краен брой или с безкраейн поток от данни, примерно всички четни числа

    Алгоритмите, работещи с данни във вид на потоци, се реализират като последователност (pipelines) от операции върху елементите на потока 
    # Вместо да се пишат for цикли или да се влагат if-cases, в Stream API-то се изгражда pipeline от операци
    # Данните влизат в единия край на Pipeline-a и преминават през всяка стъпка последователно 

* Инициализиране на поток от колекции, низове и масиви 

    Има много начини, по които може да инициализираме поток:
    - Stream.empty() 
    # Това е статичен метод, който създава поток, който не съдържа никакви елементи

    - Stream.of(T... values)
    # Този метод позволява ръчно да се създаде поток от един или няколко елемента, който му се подават директно
    
    - Collection.stream() 
    # Във всяка Java колекция като ArrayList, HashSet и други има .stream() метод, който създава последователен поток от нейните елементи

    - Collection.parallelStream() 
    # Този метод създава паралелен поток, това позволява на Java да управлява елементите в няколко нишки едновременно, което може да ускори процеса

    - Arrays.stream(T[] array)
    # Използва се този статичен метод, за да зададем поток от елементи от даден масив

    - IntStream streamOfChars = "abc".chars();
    # Този елемент връща специален поток от IntStream, където всяко число представлява даден ascii код

    - Stream<String> streamOfStrings = Pattern.compile(", ").splitAsStream("a, b, c");
    # Позволява да се вземе един низ и да се раздели на части въз основа на подадения Pattern, резултата е Stream<String> който съдържа елементите като са разделени

* Потоци от елементи от примитивен тип 

    Stream<T> е generic интерфейс и няма как да се използва за примитивни типове като параметър, затова същестуват тези три интерфейса:
    - IntStream
    - LongStream
    - DoubleStream

    Инстанция на примитивните потоци се създават със статичните of, range() и rangeClosed() методи на интерфейсите или индиректно, от API-та:
    - of() създава поток от елементите, които са му подадени
    - range() създава поток от числа в даден обхват, без да включва горната граница
    - rangeClosed() създава поток от числа в даден обхват, включително горната граница

    Примери:
    - IntStream intStream = IntStream.of(1,2,3);
    - int[] intArray = {1,2,3};
    - IntStream intStraemFromArray = IntStream.of(intArray);
    - LongStream longsRange = LongStream.range(1,3);
    - LongStream longsRangeClosed = LongStream.rangedClosed(1,3);

    Съответните интерфейси за примитивни типове имат и допълнителни статически методи:
    - avarage() изчислява средната стойност на числата в потока
    - max() намира най-големия елемент в потока
    - min() намира най-малкия елемент в потока
    - sum() изчислява сумата на всички елементи в потока 

* Инициализация на поток от съдържание на файл или директория 

    Mогат да се създадат потоци (Streams) директно от файловата система използвайки java.nio.files.Files
    Този инструмент позволява използването на всички операции на Stream API върху редове от файл или върху списък с файлове в директория

    Ето няколко метода:
    - Stream<String> lines(Path path)
    # Този метод връща Stream<String>, където всеки елемент от потока е един ред от текстовия файл, посочен от path

    - Stream<Path> list(Path dir)
    # Този метод връща Stream<Path> като съдържа всички файлое и под-директори, които се намира в dir, ТОЗИ МЕТОД НЕ Е РЕКУРСИВЕН

    - Stream<Path> walk(Path start, FIleVisitOption... options)
    # Това вече е рекурсивният варият, като се започва от start се обхожда цялото дърво на директорията, резултата е Stream<Path> като съдържа всички файлове и директориии под start

* Инициализация на поток от псевдослучайни числа

    DoubleStream doubles()
    # Създава безкраен поток от случайни double числа в интервала [0,1)

    IntStream ints()
    # Създава безкраен поток от псевдослучайни int числа

    # Създава безкраен поток от случайни long числа
    LongStream longs()
    
* Инициализация на поток чрез итерация 

    Stream<T> iterate(T seed, UnaryOperator<T> f)
    # Създава безкраен последователен поток чрез итеративно прилагане на втория аргумент към първия

    Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> f)
    # Създава краен последователен поток чрез итеративното прилагане на третия аргумент към първия докато втория параметър връща true

* Инициализация на поток чрез Supplier 

    Stream<T> generate(Supplier<T> supplier)
    # създава безкраен поток, всеки елемент на който се генерира от подадената Supplier функция
    # този метод създава безкраен поток, generate извиква една и съща функция отновно и отново за всеки елемент 
    Пример: Stream.generate(() -> 1);

* Конкатенация на потоци 

    static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
    # Създава се поток, който представлява конкатенация на подадените два потока 

    Примери:
    - Stream<Integer> stream1 = List.of(1,2,3).stream();
    - Stream<Integer> stream2 = List.of(4,5,6).stream();
    Stream.concat(stream1, stream2);

* Операции върху потоци 

    Много от методите на stream интерфейса - онези, които имат параметър функционален интерфейсен тип, се наричат операции
    # Общо взето методите, които приемат поведение като параметър, това поведение се подава като ламбда израз

    Stream API-то предоставя набор от функции от по-висок ред, чрез които декларативно можем да обработим данните
    # Не забравяй, че функция от по-висок ред е функция, която приема друга функция като параметър или връща функция като резултат
    # Под декларативно разбирай, че се описва КАКВО се иска да се постигне, а не КАК да се случи точно

    Операциите са потоци от два вида:
    - Междинни - връщат stream обект като резултат
    # Това са операции, които извършват някаква трансформация (като филтриране или преобразуване) и винаги връщат нов поток като резултат
    # Понеже връщат поток, ние можем да chain-нем няколко междинни операции една след друга 
    - Терминални - връщат обект, различен от Stream Или не връщат резултат
    # Това са операциите, които приключват потока. Те или връщата краен резултат или консумират потока, но никога не връщат нов Stream

    Обработката на потоци типично се организира като pipeline:
    - потокът се задава с инициализираща операция 
    - поредица от междинни операции обработват потока, като резултатът от всяка ства вход за следващата във веригата
    - накрая терминална опреация продуцира резултат или страничен ефект и преиключва потока 

    Пример:
    List<Person> people;
    List<Person> result = people.stream()
                .filer(p -> p.getFirstName().equals("Nikolay")) # потока се филтира и се допускат само обектите с име Nikolay
                .sorted(Comparator.comparing(Person::getLastName)) # сортират се хората по нормално име
                .toList(); # това е терминиращата операция 

* Междинни операции върху потоци 

    Междинните операции връщат Stream Обект. който съдържа същите или модифицирани елементи, като типът на елементите може да е същият или различен от тияа на елементите във входния поток 
    # Всяка междинна операция, която се прилага като filter или map връща като резултат нов Stream 
    # Например filter премахва някои елементи, но map ги трансформира

    Според техните функционалности се разделят на:
    - филтриращи, тоест тези които намаляват броя на елементите
    - map-ващи, тоест тези които променят всеки елемент
    - сортиращи, тези които подреждат елементите 

* Филтриращи междинни операции: filter 

    # Междинна операция, която приема предикат (Т -> boolaen) и връща поток само от елементи, за които е верен предиката
    employees.filter(e -> e.getAge() < 25>)

* Филтриращи междинни операции: limit 
    
    # Mеждинна операция, която приема цяло число N и връща краен поток само сп ървите N елемента на входния поток
    employees.limit(100);

* Филтриращи междинни операции: distinct

    # Междинна операция без аргументи, връща елементите на входния поток като премахва дублиращите се
    employees.distinct();

* Филтриращи междинни операции: skip, dropWhile, takeWhile

    # Междинна операция, приема цяло число N и връща поток игнорирайки първите N елемента на входния поток
    employees.skip(10);

    # Пропуска първите елементи на потока, докато предикатът връща true
    employees.dropWhile(e -> e.getAge < 18>);

    # Допуска само първите елементи на потока, докато предикатът връща true
    employees.takeWhile(e -> e.getName().startsWith("A"));

* Map-ващи междинни операции: map 

    Map-ващите операции са единствените междинни операции, които променнят елемнтите на входния поток 
    # map е операципта, кояо фундаментално трансформира всеки елемент в нещо друго 

    Те map-ват всеки елемент на входния поток към нов елемент
    # За всеки един елемент, който влиза в map операцията излиза точно един нов елемент 

    Map е междинната операция, приема функция (T -> V) и връща поток със същия брой елементи, но от новия тип V 

    Примери:
    - employees.map(e -> e.getName());
    # Взима потока от employees и прилага ламбда функцията e -> e.getName() като резултата е нов поток, който вече не съдържа само Employee обекти, а само техните имена, тоест Stream<String>

    - emoployees.mapToInt(e -> e.getAge())
    - employess.mapToDouble(e -> e.getSalary())
    # Това са специални метод които трансформират потока от обекти в поток от примитивни типове 

    - employees.mapToDouble(Employee:getSalary())
    # Същата логика като горното просто се използва рефернция към метод 

* Map-ващи междинни операции: flatMap 

    # flatMap се използва, когато искаш да трансформираш един елемент в нула, един или много елементи в крайния поток 

    Междинна операция, приема функция (Т -> Stream[V]) и връща поток с линейна структура (flat), вместо поток от потоци
    # flatMap приема функция (T -> Stream[V]) като трансформира 1 елемент в цял нов поток 

    Пример:
    employees.flatMap(e -> Stream.of(e.getSalary(), e.getBonus()));
    # Ще се поличо един общ поток с всички заплати и всички бонуси на всички служители, тоест ако служител1 има данните (1000,100), a служител2 има данните (1200, 150), крайния поток ще е 1000,100, 1200, 150

* Сортираяи междинни операции: sorted 

    emoployees.sorted();
    # Когато се извиква без аргументи sorted() се опитва да сортира елементите в потока според техния естествен ред, обаче за да работи това елементите в потока трябва да са имплементирали Comparable

    emoployees.sorted((e1,e2) -> e1.getSalary() < e2.getSalary())
    # Дефинираме собствена логика за сортиране като подаваме Comaprator като ламбда израз, самият ламбда израз казва на sorted() как да се сравняват данните 

    Да се обърне внимание, че тези операции не могат да прикюлчат, докато не се обработят всичките елементи на потока, те са скъпи откъм ресурси и бавни откъм performace, така че трябва да се използват само за малки потоци 

* Терминални операции: обработка елемент по елемент с forEach 

    # forEach е терминалан операция, която се изпозлзва за извръшване на действие (side effect) върху всеки елемент от потока 
    Това е терминална опреация, която приема функция (T -> void) и не връща резулта
    # Терминалната операция е метод, който приключва потока и задейства цялата верига от междинни операции преди него

    Пример:
    - employess.forEach(e -> System.out.prinln(e.getName() + " " + e.getAge()));

* Терминални операции: reduce 

    # reduce е една от най-важните терминални операции, която служи за агрегиране (комбиниране) на всички елементи в един поток до един-единствен резултат
    Това е терминална операция, която приема функция (T,T) -> Т и връща единичен резултат 
    # фунцкията (T,T) -> T се нарича BinaryOperator и описва как се комбинира два елемента от тип Т и в един тип Т
    # reduce прилага тази функция многократно, докато целият поток не бъде reduce-нат до една-единствнеа стойност

    employees.mapToDouble(Employee::getSalary) # тук потока от Stream<Employee> се превръща в DoubleStream 
        .reduce((res, el) -> res + el); # res е акумулатора (временен резултат, който се натрупва) и el е следващия елемент от потока 

    Реално методите min(), max(), sum() и avarage() са специализирани и по-удобни форми на reduce 
    
    # reduce операцията позволява типът на крайния резултат да бъде различен от типа на елементите в потока 
    reduce има и по-обща форма, която дава възможнсот да се върне резултат, различен от типа на потока ((V,T) -> V)
    Пример:
    double result = employees.reduce(
        0.0, # intial value
        (res, ek) -> res + el.getSalary(), # accumulator
        (left, right) -> left + right # combiner it is used in paralel 
    );

* collect 

    Възможно е reduce операцията да върне резултат, който не е единичен обект, а колекция, обаче collect предоставя възможност за акумулиране на резултата в колекцията 
    # collect е реално специализирана, по-ясна и по-ефективна операция, проектирана точно за тази цел, тя събира елементите в контейнер 

    List<Integer> list = Stream.of(1,2,3,4,5)
                    .collect(ArrayList::new, // supplier 
                            ArrayList::add, // accumulator
                            ArrayList::addAll); // combiner
    # ArrayList::new е функцията, която казва на collect как да създаде нов, празен контейнер в началото
    # ArrayList::add  е функцията, която казва как да добавим елемент от потока в контейнера 
    # ArrayList::addAll е функцията, която казва как да се слееят два частични контейнера, ако потокът се обработва паралелно 