* Java Stream API 

    Ламбда изразите, заедно с функционалните интерфейси, разширяват възможността на Java с елементи на функционалното програмиране 
    # Това означава, че ламбда изразите и функционалните интерфейси са основните инструменти, които позволяват на Java да използва концепции от функционалното програмирне

    Te позволяват предаването на поведение (функции) като параметри на библиотеки, оптимизирани за бързодействие при обработка на данни
    # Вече вместо да се подават само данни към метод, може и да му се подаде поведение, тоест какво да прави с тези данни 

    По този начин, един app developer може да се фокусира върху бизнес логиката на приложението си, оставяйки аспекти като бързодействието на авторите на въпросните библиотеки
    Една такава основна библиотека е java.util.stream

* java.util.streams 

    Интерфейсите и класовете от пакета java.util.stream (които наричаме Java Stream API) са предназначени за ефективна последователна или паралелна обработка на крайни или безкрайни потоци от данни
    Клочви характеристики:
    - Ефективна, защото е оптимизирана за бързодействие
    - Последователна или паралелна: Могат да се обработват данни елемент по елемент или Java автоматично да раздели работата на няколко нишки, за да изпозлва всички ядра на процесора
    - Крайни или безкрайни потоци: Може да се работи с колекции с краен брой или с безкраейн поток от данни, примерно всички четни числа

    Алгоритмите, работещи с данни във вид на потоци, се реализират като последователност (pipelines) от операции върху елементите на потока 
    # Вместо да се пишат for цикли или да се влагат if-cases, в Stream API-то се изгражда pipeline от операци
    # Данните влизат в единия край на Pipeline-a и преминават през всяка стъпка последователно 

* Инициализиране на поток от колекции, низове и масиви 

    Има много начини, по които може да инициализираме поток:
    - Stream.empty() 
    # Това е статичен метод, който създава поток, който не съдържа никакви елементи

    - Stream.of(T... values)
    # Този метод позволява ръчно да се създаде поток от един или няколко елемента, който му се подават директно
    
    - Collection.stream() 
    # Във всяка Java колекция като ArrayList, HashSet и други има .stream() метод, който създава последователен поток от нейните елементи

    - Collection.parallelStream() 
    # Този метод създава паралелен поток, това позволява на Java да управлява елементите в няколко нишки едновременно, което може да ускори процеса

    - Arrays.stream(T[] array)
    # Използва се този статичен метод, за да зададем поток от елементи от даден масив

    - IntStream streamOfChars = "abc".chars();
    # Този елемент връща специален поток от IntStream, където всяко число представлява даден ascii код

    - Stream<String> streamOfStrings = Pattern.compile(", ").splitAsStream("a, b, c");
    # Позволява да се вземе един низ и да се раздели на части въз основа на подадения Pattern, резултата е Stream<String> който съдържа елементите като са разделени

* Потоци от елементи от примитивен тип 

    Stream<T> е generic интерфейс и няма как да се използва за примитивни типове като параметър, затова същестуват тези три интерфейса:
    - IntStream
    - LongStream
    - DoubleStream

    Инстанция на примитивните потоци се създават със статичните of, range() и rangeClosed() методи на интерфейсите или индиректно, от API-та:
    - of() създава поток от елементите, които са му подадени
    - range() създава поток от числа в даден обхват, без да включва горната граница
    - rangeClosed() създава поток от числа в даден обхват, включително горната граница

    Примери:
    - IntStream intStream = IntStream.of(1,2,3);
    - int[] intArray = {1,2,3};
    - IntStream intStraemFromArray = IntStream.of(intArray);
    - LongStream longsRange = LongStream.range(1,3);
    - LongStream longsRangeClosed = LongStream.rangedClosed(1,3);

    Съответните интерфейси за примитивни типове имат и допълнителни статически методи:
    - avarage() изчислява средната стойност на числата в потока
    - max() намира най-големия елемент в потока
    - min() намира най-малкия елемент в потока
    - sum() изчислява сумата на всички елементи в потока 

* Инициализация на поток от съдържание на файл или директория 

    Mогат да се създадат потоци (Streams) директно от файловата система използвайки java.nio.files.Files
    Този инструмент позволява използването на всички операции на Stream API върху редове от файл или върху списък с файлове в директория

    Ето няколко метода:
    - Stream<String> lines(Path path)
    # Този метод връща Stream<String>, където всеки елемент от потока е един ред от текстовия файл, посочен от path

    - Stream<Path> list(Path dir)
    # Този метод връща Stream<Path> като съдържа всички файлое и под-директори, които се намира в dir, ТОЗИ МЕТОД НЕ Е РЕКУРСИВЕН

    - Stream<Path> walk(Path start, FIleVisitOption... options)
    # Това вече е рекурсивният варият, като се започва от start се обхожда цялото дърво на директорията, резултата е Stream<Path> като съдържа всички файлове и директориии под start

* Инициализация на поток от псевдослучайни числа

    DoubleStream doubles()
    # Създава безкраен поток от случайни double числа в интервала [0,1)

    IntStream ints()
    # Създава безкраен поток от псевдослучайни int числа

    # Създава безкраен поток от случайни long числа
    LongStream longs()
    
* Инициализация на поток чрез итерация 

    Stream<T> iterate(T seed, UnaryOperator<T> f)
    # Създава безкраен последователен поток чрез итеративно прилагане на втория аргумент към първия

    Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> f)
    # Създава краен последователен поток чрез итеративното прилагане на третия аргумент към първия докато втория параметър връща true

* Инициализация на поток чрез Supplier 

    Stream<T> generate(Supplier<T> supplier)
    # създава безкраен поток, всеки елемент на който се генерира от подадената Supplier функция
    # този метод създава безкраен поток, generate извиква една и съща функция отновно и отново за всеки елемент 
    Пример: Stream.generate(() -> 1);

* Конкатенация на потоци 

    static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
    # Създава се поток, който представлява конкатенация на подадените два потока 

    Примери:
    - Stream<Integer> stream1 = List.of(1,2,3).stream();
    - Stream<Integer> stream2 = List.of(4,5,6).stream();
    Stream.concat(stream1, stream2);

* Операции върху потоци 

    Много от методите на stream интерфейса - онези, които имат параметър функционален интерфейсен тип, се наричат операции
    # Общо взето методите, които приемат поведение като параметър, това поведение се подава като ламбда израз

    Stream API-то предоставя набор от функции от по-висок ред, чрез които декларативно можем да обработим данните
    # Не забравяй, че функция от по-висок ред е функция, която приема друга функция като параметър или връща функция като резултат
    # Под декларативно разбирай, че се описва КАКВО се иска да се постигне, а не КАК да се случи точно

    Операциите са потоци от два вида:
    - Междинни - връщат stream обект като резултат
    # Това са операции, които извършват някаква трансформация (като филтриране или преобразуване) и винаги връщат нов поток като резултат
    # Понеже връщат поток, ние можем да chain-нем няколко междинни операции една след друга 
    - Терминални - връщат обект, различен от Stream Или не връщат резултат
    # Това са операциите, които приключват потока. Те или връщата краен резултат или консумират потока, но никога не връщат нов Stream

    Обработката на потоци типично се организира като pipeline:
    - потокът се задава с инициализираща операция 
    - поредица от междинни операции обработват потока, като резултатът от всяка ства вход за следващата във веригата
    - накрая терминална опреация продуцира резултат или страничен ефект и преиключва потока 

    Пример:
    List<Person> people;
    List<Person> result = people.stream()
                .filer(p -> p.getFirstName().equals("Nikolay")) # потока се филтира и се допускат само обектите с име Nikolay
                .sorted(Comparator.comparing(Person::getLastName)) # сортират се хората по нормално име
                .toList(); # това е терминиращата операция 

* Междинни операции върху потоци 

    Междинните операции връщат Stream Обект. който съдържа същите или модифицирани елементи, като типът на елементите може да е същият или различен от тияа на елементите във входния поток 
    # Всяка междинна операция, която се прилага като filter или map връща като резултат нов Stream 
    # Например filter премахва някои елементи, но map ги трансформира

    Според техните функционалности се разделят на:
    - филтриращи, тоест тези които намаляват броя на елементите
    - map-ващи, тоест тези които променят всеки елемент
    - сортиращи, тези които подреждат елементите 

* Филтриращи междинни операции: filter 

    # Междинна операция, която приема предикат (Т -> boolaen) и връща поток само от елементи, за които е верен предиката
    employees.filter(e -> e.getAge() < 25>)

* Филтриращи междинни операции: limit 
    
    # Mеждинна операция, която приема цяло число N и връща краен поток само сп ървите N елемента на входния поток
    employees.limit(100);

* Филтриращи междинни операции: distinct

    # Междинна операция без аргументи, връща елементите на входния поток като премахва дублиращите се
    employees.distinct();

* Филтриращи междинни операции: skip, dropWhile, takeWhile

    # Междинна операция, приема цяло число N и връща поток игнорирайки първите N елемента на входния поток
    employees.skip(10);

    # Пропуска първите елементи на потока, докато предикатът връща true
    employees.dropWhile(e -> e.getAge < 18>);

    # Допуска само първите елементи на потока, докато предикатът връща true
    employees.takeWhile(e -> e.getName().startsWith("A"));
