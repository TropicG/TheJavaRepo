* S.O.L.I.D принципите

    Целта на S.O.L.I.D. дизайна е да се създава код, който е лесен за разбиране, поддържане и тестване

    Следните принципи са:
    - Single responsibility principle: Един клас/компонент трябва да върши точно една конкретна задача
    - Open/Closed principle: Класовете/компонентите трябва да са отворени за разширение, но затворени за модификация
    # Ако примерно трябва да се напише нова функционалност, трябва да се напише нов код, а не да се променят вече съществуващ
    - Liskov Substituion Principle: Обектите от дъщерния клас трябва да могат да заместват обектите от родителския клас, без това да нарушава самата програма
    - Interface Segregation Principle: Класовете не трябва да бъдат принуждавани да зависят от методи, които не използват. По-добре малки и специфични интерфейси, отколкото един общ
    # Идеята тук е ако даден клас да не имплементира метод, ако той няма да го използва, по-добре да се направи друг клас/интерфейс
    - Dependency Inversion Principle: Модулите на високо ниво не трябва да зависят от модули на ниско ниво, и двете трябва да зависят от интерфейси
    # Идеята тук е, че едан програма не може да зависи от конректна имплементация на интерфейс, по добре да зависи от интерфейс, защото после ще е нужно да направим нова програма
    # Не да сменяме целият код

* Desing patterns 

    Desing patters са шаблони, които предоставят решения на често срещани проблеми по време на софтуерната разработка

    Ползи:
    - Използвайки доказни решение, може да се избегнат често срещани проблеми
    - Позволяват reusability на кода, което води до по-качествен код и по-лесен за поддръжка
    - Предоставя обща терминология, която помага на програмистите да се разберат лесно

    Видове:
    - Creational Patterns, тези шаблони се занимават със създаването на обекти
    # Осигуряват създаване на обекти, скривайки логиката на самото им създаване чрез new, видове такива са: Factory, Builder, Singleton
    - Structural Patterns, тези шаблони помагат за организиране на класове и обекти в по-сложни структури
    # Осигуряват различни начини за създаване на по-сложни класове чрез наследяване и композиция на прости класове, видове: Decorator
    - Behavioral Patterns, тези шаблони се фокусират върху комуникацията между обектите
    # Видове: Observer, Command, Strategy

* Factory (Creational)

    Factory шаблона позволява да се ъздава обект без да се expose-не логиката по създаването му

    Използва се и когато имаме родителски клас или интерфейс с няколко наследници/имплементиращи класове и трябва да се създадат наследници според подадения параметър

    Пример за имплементация:
    - Нека да имаме общ интерфейс Shape
    - Искаме да има три наследника: Circle, Square, Rectangle.
    - Ще се направи клас ShapeFactory, който взима решението кой от тези три наследника да се създаде, базирано на подадения параметър

    Примери от практиката: valueOf(), of()
    
* Builder (Creational)

    Този шаблон позволява ръчното създаване на един клас, който потенциално може да съдържа много атрибути
    # Вместо factory шаблона да създаде цял обект, този ни позволява освен да си го приемем, но и да кажем тези атрибути какви стойности да имат
    Примери от практиката: HttpRequest, StringBuilder

    Стъпки за имплементация:
    - Създаваме static вложен клас и копираме всички параметри от външния клас в builder класа
    - builder класът трябва да има публичен конструктор с всички задължителни атрибути като параметри
    - setter методи за всички опционални параметри, които връщат същата builder инстанция
    - build() метод, който връща обекта ( this )

* Singleton (Creational)

    Единствената цел на този шаблон е да гарантира, че имаме клас, от който може да съществува най-много една инстанциa
    # Важен note: трябва да се внимава при многонишков код, за да се избегнат thread-safety проблеми, понеже е възможно два нишки едновременно да създадат два различни обекта

    Стъпки за имплементация:
    - Дефинира се private конструктор, за да спре другите класове от използване на new ClassName()
    - Нужна е private static член-променлива от тип същия клас, която реферира единствената инстанция на класа
    - Трябва да се осигури public static метод, който връща инстанцията на класа 

    Този шаблон се използва на места, къде е нужно само един централизиран контролер

* Flyweight (Structural)

    Flyweight решава проблама с препълването на RAM паметта при работа с огромен брой обекти

    Този шаблон позволява да се съберат повече обекти в наличната памет чрез споделяне на общите части на state-а между множество обекти и така намалява memory footprint-a на програмата 

    Друга полза на този шаблон е неговата производителност, защото може да подобри бързината в приложения, където инстанцирането на обектите е скъпа операция

    Ключовото изискване за тпзо шаблон е обектите да бъдат immutable, като всяка операция, която променя състоянието им трябва да се изпълнява от factory-то

    Примери за работа на това приложение могат да бъдат:
    - String pool-a като JVM не пази в паметта два обекта със един и същи String
    - Integer.valueOf(int) отновно е пример как само една инстанция на една стойност може да същестувва в програмата 

    План за имплементация:
    - създаване на интерфейс, който дефинира операциите, които клиентския код може да извършва върху flyweight обектите
    - конкретните класове могат да бъдат една или повече имплементации на този интерфейс
    - Трябва да има и един Factory клас, който да отговаря за инстанцирането и кеширането 

* Decorator (Structural)

    Този шаблон позволвяа динамично добавяне на нова функционалност към обект, без да променяме същестуващите класове 
    # Разширяването на функционалност става чрез wrapping на един бект с друг около него, с идеята да добави нова функционалност
    
    Пример от JDK: BufferedInputStream, DataInputStream

    Стъпки за имплементация:
    - създава се абстрактен клас или интерфейс, който дефинира основния функционален интерфейс
    - създава се конкретен клас декоратор, който също имплементира интерфейса и съдържа референция към обекта, който декорира
    - декораторът добавя нова функционалност, но не променя основния обект

* Iterator (Behavioral)

    Този шаблон позволява последователното обхождане на поредица от обекти
    # Пример за практиката е java.util.Collection API-то

* Command (Behavioral)

    Този шаблон се използва за имплементиране на loose coupling (слабо свързване) в модела заявка-отговор
    # Примерно вместо директно да се извика една команда към компонент директно, самата команда се опакова и се праща към компонента

* Observer (Behavioral)

    Този шаблон решава проблема с постояннот проверява дали една информация е готова, вместо това даден обект се информира за състоянието вместо постоянно да наблюдава
    
    При този шаблон се използва следната терминология:
    - Observer е обектът, който наблюдава за промяна на състоянието на друг обект
    - Subject е наблюдаваният обект

* Strategy (Behavioral)

    Този шаблон се прилага, когато имаме множество алгоритми за дадена задача и клиентът решава по време на изпълнение, коя имплементация на алгоритъм да се използва 