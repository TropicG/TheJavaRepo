* java.nio

    nio реално означава Non-blocking I/O

    Идеята е да се стартира задачата и веднага да се върши някоя другата работа, а когато първата задача е готова тя известява съответния сървър

    В Java се използва библиотеката java.nio като една нишка може да управлява стотици връзки чрез Selector, една нишка проверява всичките връзки и като види, че един клиент има данни го обработва

    Използва се java.nio, когато се прави приложение, което скоростта и паметта са много критични 

* java.nio и неговите основни обекти 

    Ето основните обекти:
    - Буфер (Buffer), това е блок от паметта, който се използва за временно съхранение на данни за четене или писане
    # В сравнение с java.net данните се предаваха байт по байт, тук данните се пренасят чрез буфери
    - Канал (Channel) е абстракцията за цялата комуникационна връзка 
    # Това тук е заместител на Socket-a, това е реално един вид тръбата по която се движат буферите, но каналите не могат да бъдат блокиращи
    - Селектор (Selector) е компонент, в който се регистрират множество канали, позволяващ обработката им в една нишка 

* буферите в java.nio 

    Буферът е контейнер, който съдържа временно данни, които ще бъдат записани или прочетени, той представлява масив от примитивен тип с фиксиран размер, който пази състояния:
    - докъде е запълнен
    - колко свободно място има
    - докъде са прочетени или записани данните

    Реално класът Buffer е абстрактен, но има наследници за всички не-булеви примитивни типове като: ByteBuffer, CharBuffer, IntBuffer и други 
    
    Реално java.nio комуникацията се основава на буфери, за разлика от java.io комуникацията, която се случва с входно-изходни потоци 

* java.nio.Buffer 

    Състоянието на буфера се определя от четири атрибута:
    - капацитет (capacity): максималния брой елементи, които може да съдържа буферът, капацитета се задава при създаването му и не може да бъде променен
    - лимит (limit): първият индекс на буфера, който не трябва да се достъпва за четене или писане
    # това е реално индексът, след който нямаш право да правиш нищо, значението на лимит се промяна в зависимост от това дали се пълни буфера или се чете в него 
    - позиция (position): индексът на следващия елемент на буфера за прочитане или за записване
    - маркер (mark): индекс, в който може да запомним текущата позиция, за да се върнем към нея по-късно

    Четирите индекса се намират в следната зависимост: 0 <= mark <= position <= limit <= capacity

    Методи в този клас:
    - int capacity()
    # Връща размера на буфера, тоест колко общо елемента побира
    - int position()
    # ръща текущия индекс, на който се намираш в момента, тоест къде ще се пише/чете следващия байт
    - Buffer position(int newPosition)
    # Премества курсора ръчно на ново място, в случай ако трябва да се прескочат данните или да се прочете нещо отначало 
    # Връща референция към същия buffer върху които се работи просто с променено състояние
    - int limit()
    # Връща индекса на лимита, тоест докъде има право да се пише и да се чете
    - Buffer limit(int newLimit)
    # Мести се лимита на ново място, отново връща същия буфер с променено състояние
    - Buffer mark()
    # запомня къде е последния mark, отново връща същия буфер с променено състояние
    - Buffer reset()
    # Връща позицията там където е последно бил mark(), отново връща същия буфер с променено състояние

    Допълнтелни методи: # Тук и трите буфера връщат същия буфер
    - Buffer flip(), тоест превключване Write -> Read
    # Подготвя буфера за прочитане като лимита става равен на позицията, а позицията на нула, използва се след channel.read(buffer) и преди buffer.get()
    - Buffer clear(), тоест превключване Rread -> Write
    # Използва се, когато е приключено с четенето на данните и трябва да се използва буфера наново за нови данни
    # Тук limit се връща до capacity и position става 0, въпреки че се казва clear ТОЙ НЕ ИЗТРИВА ДАННИТЕ, само връща индексите в начало
    - Buffer rewind() това прави повторно Re-Read
    # Подготвя буфера за повторно прочитане на данните, които вече съдържа. Лимита остава без промяна, докато позицията се нулира 
    
* java.nio.ByteBuffer 

    Това са основните методи за четене и писане на данните в буфера, трябва да се направи разграничението:
    - между методите, които използват текущата позиция
    - и тези, които използват конкретен индекс

    (Относителни методи):
    # Тези методи зависят от това къде се намира position, те са автоматични, защото след като свършат работа, сами местят курсора напред.
    - byte get() прочита байта, който се намира на текущата позиция и автоматично увеличава position с +1.
    # ако позицията е стигнала лимита, се хвърля грешка BufferUnderflowException
    - ByteBuffer put(byte b) записва байта b на текущата позиция и автоматично увеличава position + 1, отново се връща ByteBuffer със променено състояние
    # aко няма място (позицията е равна на капацитета), хвърля грешка BufferOverflowException.

    (Абсолютни методи):
    # Тези методи работят с конкретен адрес като не местят курсора
    - byte get(int index) рочита байта, който се намира на определен index
    - ByteBuffer put(int index, byte b) записва байта b на точно определен index

* java.nio | Как работи буферът

    Виж изображението LifeCycleOfBuffer.png то илюстрира жизнения цикъл на един буфер и как limit, position и capacity индексите се сменят

    Изображението има три етапа:
    - Еmpty buffer (Празен буфер)
    - Writing mode (Режим на писане)
    - Reading mode (Режим на четене)

    (Empty Buffer)
    Състоянието веднага след като създадеш буфера примерно чрез ByteBuffer.allocate(10) като:
    - position = 0
    - limit = 10
    - capacity = 10

    (Writing mode)
    В изображението се пишат пет байта чрез put() метода като:
    - position = 5
    - limit = 10
    - capacity = 10
    
    В изображението се вика buffer.flip(), което превключва от писане към четене и limit = posiion (5) и position сега е 0

    (Reading mode)
    Сега вече може да се изпратят данните или да се прочетат като:
    - position = 0
    - limit = 5
    - capacity = 10
    # Сега лимита е до 5, защото няма никакви данните след този индекс

    Всичкото може да се рестартира чрез buffer.clear(), тогава:
    - limit = 10
    - position = 0 
    # Сега вече буфера изглежда като празен буфер готов за писане 

* java.nio Индиректни и директни буфери 

    Става дума не как се ползва буферът, а къде физически се намира паметта му

    (Индиректни буфери) използва се ByteBuffer.allocate(1024)
    Този буфер JVM Heap-а като ОС няма директен достъп до Java паметта

    (Директни буфери) използва ByteBuffer.allocateDirect(1024)
    Този буфер жиевее в native system memory (с други думи паметта на компютъра) и ОС вижда директно тази памет, не е нужно копиране
    # Позволява на DMA (Direct Memory Access), тоест хард дискът или мрежовата карта могат да четат/пишат директно в тази памет, без изобщо да занимават процесора (CPU).

    Директните буфери ще използват при възможност native I/O операции за четене и запис директно през операционната система
    Директният буфер представлява непрекъснат регион на постоянно място в паметта, индиректният е Java масив, може да не е непрекъснят регион и може да се мести от garbage collector-a
    Директният буфер е по-скъп за създаване, но ще работи по-ефективно за големи размери и ако живее дълго в паметта
    Индиректният буфер не е толкова ефективен като директният за повечето операции, но управлението на паметта му се осъществява от JVM-a (garbage collector-a) и е по-предсказуемо

* Канали (Channels)

    Каналите са абстракция за връзка за ефективно транспортиране на данни между byte буфери и обект на другия край на канала (най-често файл или сокет)
    # Не може да се прати само един байт директно в канала, първо трябва да се сложат данните в Буфер и след това да се дадена на канала да се изпрати

    Каналите са минимално overhead (минимално допълнително натоварване), защото са напревени така, че да комуникират директно с ОС (native I/O APIs)
    # реално буферите са вътрешните крайни точки, които каналите използват за изпращане и получаване на данни

* java.nio.channels.ServerSocketChannel

    Тук ще се представят методи от класа ServerSocketChannel това е NIO еквивалента на стандартния ServerSocket
    # Ролята на класа е да бъде listener той да стой отворен и да чака клиентите да се свържат

    Ето методи от този клас:
    - static ServerSocketChannel open() създава и отваря нов канал за сървърски сокет
    # Това е еквивалента на new конструктора без него не можеш да създадеш обект
    - SocketChannel accept() приема входяща връзка от клиент и връща нов SocketChannel, чрез който да си говориш с този конкретен клиент
    # В Non-blocking IO този метод може да върне null веднага, ако няма чакащ клиент вместо да блокира програмата 
    - ServerSocketChannel bind(SocketAddress local) 
    # Свързва канала към конкретен IP адрес и порт на компютъра, за да почне да слуша заявки 
    - ServerSocket socket() 
    # Връща класическия обект java.net.ServerSocket, който стои зад този канал, използва се ако трябва настройки от старите API-та

* java.nio.channels.SocketChannel

    SocketChannel е активната връзка (тоест клиентът), тоест това е кабелът, който свързва двете страни

    Има следните методи в този клас:
    - static SocketChannel open() Създава нов сокет канал, но без да го свързва веднага
    - static SocketChannel open(SocketAddress remote) създава канала и автоматично го свързва към посочения адрес
    - boolean connect(SocketAddress remote) използва се само ако си създал канел с чисто open(), свързва се към отсрещната страна
    - Socket socket() Връща стандартния обект java.net.Socket, който е скрит зад канала, ползва се когато трябва да се настроят някой неща
    - int read(ByteBuffer dst) чете данни от мрежата и ги налива във твоя буфер dst, тоест броя на прочетените байтове
    - int write(ByteBuffer src) взима данните от твоя буфер src и ги праща към мрежата 

    Ключово нещо за помнене е че каналите винаги подаваш Буфер като аргумент, данните не минават директно, те винаги се возят в буфера

* Selector и Selection Key

    Това е компонента, който позволява на една нишка единствена нишка да управлява стотици или хиляди връзки 

    Селекторите осигуряват възможността за избор (селектиране) на канали според готовността им за I/O операции (readiness selection)
    # Readiness selection представлява постоянната проверка от селектора дали някой канал е готов за преглед на данни 
    Това реално е предпоставка за multiplexed I/O, тоест с една нишка да се обслужва голям брой канали
    # Това и реално е крайната цел с една нишка да се управляват много канали

    Виж изображението SelectorAndChannels.png:
    - SelectableChannel са реално връзките (SocketChannel), те са избираеми и могат да работят в non-blocking io режим
    - SelectionKey е връзката между канала и селектора, когато се регистра канал в селектора се получава key, като този ключ пази интереса на канала, тоест за какво следим
    # Можем да следим за писане примерно Interest: Write можем да следим за четене примерно Read може и да е заедно като Read & Write
    - Selector е обекта, който държи всички тези ключове, когато се извика примерно метода selector.select() той преглежда всичките ключове и връща само тези, които са светнали в зелено

    Стъпките, през който работи един Selector и това трябва да се следва, когато се пише код:
    - Регистрираме един или повече вече създадени канали с инстанция на селектор
    - Регистрирането връща ключ, който представлява релацията между канала и селектора
    # Именно този върнат ключ е SelectionKey обект
    - Ключът "помни" операциите върху даден канал, от които се интересуваме и следи готовността на канала да ги изпълнява
    # Именно в ключа е записано какво точно чакаме да се случи, дали някой да се обади (OP_ACCEPT) или чакаме да четем (OP_READ)
    - При извикване на select() метода на селектора, се актуализират всички асоциирани с този селектор ключове на канали
    # Когато се извика този метод програмата спира и се проверяват каналите, ако нищо не се случва се чака, а ако някъде е готово за четене/писане се прави операцията
    - От селектора може да получим множеството от ключове, чиито канали са готови за операция
    # Един вид селектора ни връща set съдържат всички ключове, които са готови за обработване на тяхното събитие (четене/писане на данни)
    - Итерираме това множество и обслужваме всеки от готовите канали
    # Това всичкото е завъртяно в един for each/while цикъл и се върши работата

* java.nio.channels.Selector

    Класа Selector има много важни, които служат за управление на каналите:
    - static Selector open() отваря селектора
    # Винаги се използва този статичен метод
    - int select() е метода който спира програмата и почва да гледа докато някой канал не е готов
    # Този метод е блокиращ, ако никой не се обажда програмата стой на този ред и чака, ще се събуди само ако види някой да е готов
    # Числото върното показва колко канала всъщност са готови за обработка
    - Set<SelectionKey> selectedKeys()
    # Този метод връща списъкът със задачите, които ще трябва да се направят 

    Важният алгоритъм:
    - open() го викаш само веднъж в началото
    - while(true) влизаш в такъв цикъл
    - select() 
    - взимаш резултата от selectedKeys() и почваш да работиш 

* java.nio.channels.SelectionKey

    Това е обекта, който свързва канала със селектора, като съдържа цялата информация на връзката
    
    В класа има константи, които служат за флагове и казваш с тях какво трябва да се гледа
    - public static final int OP_READ
    - public static final int OP_WRITE
    - public static final int OP_CONNECT
    - public static final int OP_ACCEPT
    # Тези събития представляват събитията четене, писане, успешно свързване на клиент и приемане на нова връзка за сървъра

    Ето следните методи в класа:
    - SelectableChannel channel() връща канала, за който се отнася този ключ
    # Когато селекторът ти даде ключ, ти не знаеш от кой точно клиент е, но с този метод знаеш
    - Selector selector() връща селектора, при който е регистриран този ключ 
    - int interestOps() връща набора от операции, които са поискани да се следят в момента
    - int readyOps() връща набора от операции, които са готови в момента
    
    - boolean isReadable() проверява дали канала е готов за четене
    - boolean isWritable() проверява дали канала е готов за писане
    - boolean isConnectable() проверява дали клиентът е успял да се свърже със сървъра
    - boolean isAcceptable() проверява дали има нов клиент който чака да се свърже 

* регистирране на SocketChannel

    Когато регистрираме SocketChannel, трябва да укажем, за какви операции да бъдем известени:
    - OP_READ: когато се получи нещо за четене от канала
    - OP_WRITE: когато каналът е готов за запис
    - OP_CONNECT: когато каналът е готов да завърши последователността си за свързване към отдалечената система
    - OP_ACCEPT: когато пристигне заявка за нова конекция

* java.nio изпращане на данни 

    Виж изображението javaNioSendingData то визуализира стъпка по стъпка как едан единствена нишка (Thread) използва Селектора, за да изпрати данните по неблокиращ начин
    Описание на процесите (Write Ready), (Put Data), (Send Data)

    (Write Ready)
    Селектора събужда нишката, защото селектора е видял, че мрежовата карта е свобовна и каналът е готов да приеме данни
    # Преди събуждането на нишката, канала е бил регистриран с флаг OP_WRITE 
    # Реално това е момента, в който key.isWritable() би върнал true

    (Put Data)
    Нишката взима данните, които иска да изпрати (примерно отговор към клиента) и ги слага в буфераа
    # Към буфера може да се използват следните методи buffer.clear() (да изчисти буфера), buffer.put(data) (да пълним буфера), buffer.flip() (да го превключи за писане/четене)
    
    (Send Data)
    Данните (които са в жълто) ще се прехвърлят към Socket Channel-a използвайки channel.write(buffer)
    # Понеже сме в неблокиращ режим, този метод може да не изпрати всички данни наведнъж, затова връща число колко байта са изпратени

* java.nio получаване на данни 

    Виж изображението javaNioReceivingData.png то илюстрира как thread получава данни от мрежата използвайки Selector и Buufer 
    Oписание на процесите (Receive Data), (Read Ready), (Get Data)

    (Receive Data)
    По мрежовия кабел пристигат пакети данни и влизат в SocketChannel-a като данните стоят в буфера и чакат

    (Read Ready)
    Тук селектора забелязва, че в канала има чакащи данни, тогава селектора събужда нишката (тоест метода select() спира и блокира) и предупреждава сървъра
    # Това е възможно понеже сме регистирали с OP_READ

    (Get Data)
    Нишката започва работата си, за да прехвърли данните от канала в Java паметта
    # Реално нишката заделя или изчиства един Buffer (изпоолзвайки clear) и извиква channel.read(buffer) това действие реални взима данните от канала и ги пълни в буфера 

* java.nio архитектура 

    Този архитектурен стил има 3 основни предимства:
    - Централизирано управление (Selector)
    # Вместо да се следи всяка връзка поотделно има само една специална нишка selektor, която обработва множество канали
    - Пестене на ресурси (тоест по-малко нишки)
    # Премахва самата нужда да има по отделна нишка за всяка възка, може сега да се обслужат 10 000 клиенти с една единствена нишка 
    - Асинхронност (Non-blocking)
    # Понеже операциите не са блокиращи това означава, че процесорът никога не спи, докато чака бавната мрежа. Той винаги работи по нещо полезно

    Виж изображението javaNioArchitecture.png тя илюстрира Event Loop, като е много важен модел за високопроизводителен сървър
    Процеса следва стъпките:
    - WorkerThread-a е единствната нишка, която се върти в безкраен цикъл (да кажем while(true)) и върши цялата работа сама
    - Нишката отива до Selector-a (в жълтия правоъгълник) и вижда дали има нещо нова, това е момента, в който се вика selector.select()
    - В този момент има 4 различни сценария, който се случват
    # В сличая на клиент 1 селектора вижда че няма никакви данни, който очаква следователно не се занимава с него това е идеята за да не се губят ресурси
    # В случая на клеинт 2 и 3 селектора вижда че се прехвърлят данни, но ги пропуска, защото данните се предават от канала към буфера и от там във business логиката
    # В случая на клиент 4 селектора вижда отчиета събитието OP_ACCEPT, нишката приема връзката и я регистрира, за да може да я следи при следващото завъртане на цикъла
    - След като данните са в буфера, програмата (business logic) прави изчисленията и връща отговор обратно през буфера към канала 

    Реално идеята на това изображение е да се покаже как една нишка успява да управлява 4ри клиента едновременно като пропуска пасивните (без да блокира) и обръща внимание на активните
    