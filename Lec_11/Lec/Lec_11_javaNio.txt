* java.nio

    nio реално означава Non-blocking I/O

    Идеята е да се стартира задачата и веднага да се върши някоя другата работа, а когато първата задача е когато тя известява съответния сървър

    В Java се използва библиотеката java.nio като една нишка може да управлява стотици връзки чрез Selector, една нишка проверява всичките връзки и като види, че един клиент има данни го обработва

    Използва се java.nio, когато се прави приложение, което скоростта и паметта са много критични 

* java.nio и неговите основни обекти 

    Ето основните обекти:
    - Буфер (Buffer), това е блок от паметта, който се използва за временно съхранение на данни за четене или писане
    # В сравнение с java.net данните се предаваха байт по байт, тук данните се пренасят чрез буфери
    - Канал (Channel) е абстракцията за цялата комуникационна връзка 
    # Това тук е заместител на Socket-a, това е реално един вид тръбата по която се движат буферите, но каналите не могат да бъдат блокиращи
    - Селектор (Selector) е компонент, в който се регистрират множество канали, позволяващ обработката им в една нишка 

* буферите в java.nio 

    Буферът е контейнер, който съдържа временно данни, които ще бъдат записани или прочетени, той представлява масив от примитивен тип с фиксиран размер, който пази състояния:
    - докъде е запълнен
    - колко свободно място има
    - докъде са прочетени или записани данните

    Реално класът Buffer е абстрактен, но има наследници за всички не-булеви примитивни типове като: ByteBuffer, CharBuffer, IntBuffer и други 
    
    Реално java.nio комуникацията се основава на буфери, за разлика от java.io комуникацията, която се случва с входно-изходни потоци 

* java.nio.Buffer 

    Състоянието на буфера се определя от четири атрибута:
    - капацитет (capacity): максималния брой елементи, които може да съдържа буферът, капацитета се задава при създаването му и не може да бъде променен
    - лимит (limit): първият индекс на буфера, който не трябва да се достъпва за четене или писане
    # това е реално индексът, след който нямаш право да правиш нищо, значението на лимит се промяна в зависимост от това дали се пълни буфера или се чете в него 
    - позиция (position): индексът на следващия елемент на буфера за прочитане или за записване
    - маркер (mark): индекс, в който може да запомним текущата позиция, за да се върнем към нея по-късно

    Четирите индекса се намират в следната зависимост: 0 <= mark <= position <= limit <= capacity

    Методи в този клас:
    - int capacity()
    # Връща размера на буфера, тоест колко общо елемента побира
    - int position()
    # ръща текущия индекс, на който се намираш в момента, тоест къде ще се пише/чете следващия байт
    - Buffer position(int newPosition)
    # Премества курсора ръчно на ново място, в случай ако трябва да се прескочат данните или да се прочете нещо отначало 
    # Връща референция към същия buffer върху които се работи просто с променено състояние
    - int limit()
    # Връща индекса на лимита, тоест докъде има право да се пише и да се чете
    - Buffer limit(int newLimit)
    # Мести се лимита на ново място, отново връща същия буфер с променено състояние
    - Buffer mark()
    # запомня къде е последния mark, отново връща същия буфер с променено състояние
    - Buffer reset()
    # Връща позицията там където е последно бил mark(), отново връща същия буфер с променено състояние

    Допълнтелни методи: # Тук и трите буфера връщат същия буфер
    - Buffer flip(), тоест превключване Write -> Read
    # Подготвя буфера за прочитане като лимита става равен на позицията, а позицията на нула, използва се след channel.read(buffer) и преди buffer.get()
    - Buffer clear(), тоест превключване Rread -> Write
    # Използва се, когато е приключено с четенето на данните и трябва да се използва буфера наново за нови данни
    # Тук limit се връща до capacity и position става 0, въпреки че се казва clear ТОЙ НЕ ИЗТРИВА ДАННИТЕ, само връща индексите в начало
    - Buffer rewind() това прави повторно Re-Read
    # Подготвя буфера за повторно прочитане на данните, които вече съдържа. Лимита остава без промяна, докато позицията се нулира 
    
* java.nio.ByteBuffer 

    Това са основните методи за четене и писане на данните в буфера, трябва да се направи разграничението:
    - между методите, които използват текущата позиция
    - и тези, които използват конкретен индекс

    (Относителни методи):
    # Тези методи зависят от това къде се намира position, те са автоматични, защото след като свършат работа, сами местят курсора напред.
    - byte get() прочита байта, който се намира на текущата позиция и автоматично увеличава position с +1.
    # ако позицията е стигнала лимита, се хвърля грешка BufferUnderflowException
    - ByteBuffer put(byte b) записва байта b на текущата позиция и автоматично увеличава position + 1, отново се връща ByteBuffer със променено състояние
    # aко няма място (позицията е равна на капацитета), хвърля грешка BufferOverflowException.

    (Абсолютни методи):
    # Тези методи работят с конкретен адрес като не местят курсора
    - byte get(int index) рочита байта, който се намира на определен index
    - ByteBuffer put(int index, byte b) записва байта b на точно определен index

* java.nio | Как работи буферът

    Виж изображението LifeCycleOfBuffer.png то илюстрира жизнения цикъл на един буфер и как limit, position и capacity индексите се сменят

    Изображението има три етапа:
    - Еmpty buffer (Празен буфер)
    - Writing mode (Режим на писане)
    - Reading mode (Режим на четене)

    (Empty Buffer)
    Състоянието веднага след като създадеш буфера примерно чрез ByteBuffer.allocate(10) като:
    - position = 0
    - limit = 10
    - capacity = 10

    (Writing mode)
    В изображението се пишат пет байта чрез put() метода като:
    - position = 5
    - limit = 10
    - capacity = 10
    
    В изображението се вика buffer.flip(), което превключва от писане към четене и limit = posiion (5) и position сега е 0

    (Reading mode)
    Сега вече може да се изпратят данните или да се прочетат като:
    - position = 0
    - limit = 5
    - capacity = 10
    # Сега лимита е до 5, защото няма никакви данните след този индекс

    Всичкото може да се рестартира чрез buffer.clear(), тогава:
    - limit = 10
    - position = 0 
    # Сега вече буфера изглежда като празен буфер готов за писане 
