* SocketAddress 

    Това е абстрактен клас, който съдържа информация за да намери програма в мрежата:
    - IP адрес
    - Порт

    Наследник на този клас е InetSocketAddress

* java.net 

    Java.net представлява синхронно мрежово програмиране, идеята е че една задача трябва да се приключи, за да се прехвърли на другата
    В този модел и при тази библиотека се използва по една нишка за всяка връзка и когато нишката чете данни тя замръзва и чака докато данните не дойдат 

    Главно се използва java.net за бързо и лесно приложение, което няма да използва много клиенти 

* java.net.ServerSocket

    ServerSocket клас е основополагащ в мрежовото програмиране с Java и се използва за създаване на сървъри, които слушат за входящи връзки

    Този клас има следните конструктури:
    - ServerSocket() създава обект ServerSocket, но не го свързва (bind) към порт или IP адрес, трябва да се извиква bind() преди да се използва
    - ServerSocket(int port) създава сокета и го свързва към посеочения port, ако се сложи 0 системата автоматично избира свободен порт
    # Стойността на един порт е от 0 до 65535
    - ServerSocket(int port, int backlog) задава порта както и опашката (backlog), backlog задава максимален брой чакащи заявки за свързване
    - ServerSocket(int port, int backlog, InetAddress bindAddr) освен порта и backlog-a този конструктор позволява да се посочи на кой адрес (bindAddr) ще слуша сървъра
    
    Този клас има следните методи:
    - void bind(SocketAddress endpoint) свързва към конкретния IP адрес + порт-а 
    - void bind() е същото като горното просто има размер на зададената опашка за свързване
    - Socket accept() когато програмата стигне до този метод тя спира докато някой клиент не се свърже, чак когато това стане методът връща нов обект от тип Socekt
    # Socket е самата връзка с конкретния клиент, през която текат данните 

* java.net.Socket

    Този клас се използва за свързване към сървър и за обмен на данни

    Този клас има следните конструктури:
    - Socket() създава празен сокет обект, който не е свързан към нищо
    - Socket(String host, int port) създава сокет и се опитва да се свърже към посочения host (това е име на домейн или IP) и port
    # Пример Socket socket = new Socket("google.com", 80);
    - Socket(InetAddress address, int port) като горния конструктор, но вместо да приеме string приема предварително подготвен InetAddress обект 

    Този клас има следните методи:
    - void connect(SocketAddress endpoint) взима сокета и инициира връзка към сървъра (endpoint), това се прави за да се направи TCP handshake-a
    - void connect(SocketAddress endpoint, int timeout) като горното просто ако не се направи контакт до timeout време ще се хвърли грешка
    # Този метод всъщност предпазва прогрмата от замръзване

    Този методи са за IO:
    - InputStream getInputStream() това е входящия поток като от тук се чете това, което сървъра праща
    - OutputStream getOutputStream() това е изходящия поток като тук се пише това, което ще се прати към сървъра 

* Клиент-сървър комуникацията между TCP/IP 

    Виж диаграмата ClinetServerTCPIPConnection.png защото илюстрира фундаменталния процес на Client-Server комуникация чрез TCP/IP сокети
    # Показва се как се създава връзката и как данните текат между двете страни

    Тази връзка има два етапа: (Инициализиране на връзката) и (Установена връзка и обмен на данни)

    (Инициализиране на връзката):
    - Сървърът е в очакване и слуша на порт 80, тоест той просто чака да го потърсят (това е ролята на ServerSocket и метода accept())
    - Клиентът, за да се свърже, компютърът мъ автоматично назначава произволно свободен порт (нарича се ефимерен порт)
    # ако да кажем порта е 41232 той ще е нужен само за да може сървъра да знае къде да върне отговора
    - Клиента инициализира връзката (примерно new Socket("ip", 80)) и търси порт 80 на сървъра 

    (Установена връзка и обмен на данни)
    - Тук има създадена обекти Socket и от двете страни
    # Това е момента след като сървърът е приел (accept) връзката
    - Client OutputStream ➔ Server InputStream, тук всичко което клиента прати през порт 41232 ще бъде получен на порт 80 при сървъра
    - Server OutputStream ➔ Client InputStream, тук всичко което сървъра ще прати през порт 41232 ще бъде получен на порт 80 на клиента 

* TCP - Three way handshake 

    TCP установява връзка чрез процес наречене three-way handshake като се състои от три съобщения между 2-ма участника

    Един разговор между Клиента и сървъра представлява това:
    - SYN (syncrhonize): “I want to connect and here’s my sequence number”
    - SYN-ACK (Synchronize-Acknowledge): "I agree, here’s mine"
    - ACK (Acknowledge): "Confirmed, we’re synchronized"

    Когато първоначално се прави handshake клиента си измисля рандъм число (Sequence number) и го праща към сървъра (това число е скрито в пакета)
    Сървъра получава този пакет вижда числото, инкрементира го с 1 и така си измисля той скрито число и го праща скрито в сегмента
    Когато клиента отново получи сегмент той вижда че е получил инкрементираното число и вижда как да инкрементира числото на сървъра
    # Причината на това е заради сигурност, ако това число не съответства клиента/сървъра няма да приеме комуникацията

* TCP: Full-Duplex комуникации 

    TCP е двупосочен байтов поток, като това означава, че данните текат едновременно в двете посоки
    # И клиента и сървъра пращат ACK-ове за да гарантират доставянето

    Често се случва тези ACK (тоест съответното число, което се инкрементира) да се piggyback-не
    # Piggyback е термин, който казва, че това скрито число се предава заедно с пакета с данни вместо да се праща отделно

* TCP комуникация чрез java.net 

    Тази глава разглежда как да се направи TCP комуникация използвайки java.net, разгледай снимката javaNetTCPCommunication
    Има две различни линии: (Сървър) и (Клиент)

    (Сървър):
    - Сървърът винаги трябва да стартира пръв
    - Създаване на сървъра и bind-ване чрез ServerSocket serSock = new ServerSocket(4444)
    # тук се създава сървъра с порт 4444 и е активен за слушане 
    - Сървъра блокира като стигне Socket sock = serverSocket.accept() и чака докато не се направи връзка с клиент
    - Когато връзката стане, се създават потоците out и in, за да може сървъра да чете от клиента и да праща към клиента 

    (Клиент):
    - Клиентът се включва, когато сървърът вече слуша.
    - Изпълнява се Socket sock = new Socket("hostname", 4444), тук клиента се свързва с сървъра и се случва тази three-way handshake
    - Когато връзката стане, се създават потоците out и in, за да може клиента да чете от сървъра и да праща към сървъра
    
    Накрая самите потоци в клиента и в сървъра трябва да се затворят както и самите sockets 

* java.net: blocking мрежова комуникации 

    Виж изображението BlockingNetworkCommunication.png, то представлява как двата края си разменят данни и къде точно програмата спира за да чака 
    
    Вижда се как след успешна връзка има отновно IO връзките за сървъра и клиента, за да обменят своята информация

    // Blocking call в изображението обяснява точно какво може да се случи:
    - при in.read(data) е възможно програмата да спре и да не продължи надолу, докато не пристигнат някакви данни по мрежата, ако примерно другият компютър мълчи тогава програмата е замръзнала
    - при out.write(...) също е възможно да се блокира приложението, ако примерно мрежовият буфер е пълен и данните не могат да бъдат изпратени веднага 

    При този класически модел програмата е зависима от скоростта на мрежата и отзивчивостта на другата страна, ако няма данните програмата чака 

* java.net клиент-сървър архитектура 

    Виж изображението javaNetMultiThread.png в него се решава проблема свързани с блокирането на комуникацията от горната точка
    # Общо взето това изображение илюстрира многонишкова архитектура 

    В ляво на изображението се вижда ServerSocket (която си върви на нишка) като единствената задача на този ServerSocket е да слуша за нови клиенти и да се свърже с тях
    Когато се появи нов клиент, сървъра автоматично стартира нова нишка към този клиент (тази нишка е отделна), за да може да си комуника с него
    # Възможно е да има много клиенти към сървъра, това позволява на сървъра да има едновременни комуникации с много клиента 

    Как това решава проблема:
    - Не блокира останалите нишки, ако първата нишка е запецнала или е в режим на чакане, така всеки клиент си е на отделна комуникация 

* java.net Архитектура 

    Погледни изображение javaNetFixedThreadPool.png то илюстрира ограничението на модела нишка за всеки клиент, когато се използва Fixed Thread Pool

    В примера сървъра е настроем да има само 3 работещи нишки, това означава, че може да има 3 работещи връзки с клиенти по едно и също време
    # В примера може да се види допълнително как клиент 1 и клиент 3 са блокирали поради някакви причини, нишките за техните връзки чакат и не вършат работа а само заемат място
    # Единствената нишка която работи правилно е 2, клиентът си изпраща данни, а сървъра си ги обработва 

    Проблема идва с клиент 4, защото той се опитва да се свърже, но няма активна нишка за него (защото конфигурираните 3 вече са заети)
    # Поради подаден timeout, ако до определено време не се направи връзка между клиента и сървъра връзката направо се drop by timeout

    Извод от изображението:
    - Блокиращите сокети са неефективни при голямо натоварване, защото нишките губят време в чакане вместо да работят
    # Реално в модерните системи се използва друг подход, наречен Non-Blocking I/O 

* Предимства и недостатъчци към java.net

    Предимства:
    - Използва се стандартно API за потоци (InputStraem и OutputStream), което е лесно за разбиране 
    - По-малко дефекти при четене, защото нишката блокира докато прочете съобщението
    
    Недостатъци:
    - Неефективно използване на нишките, защото много могат да бъдат в waiting/blocked състояние, заради блокиращи операции
    - Доста памет се отделя за нишките
    - Performance penalty заради context switching между нишките
    - Ограничен брой паралелни connections, защото нишките на сървъра са краен брой

