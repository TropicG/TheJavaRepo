* Какво представляват структурите от данни 
	
	Това е начин за огранизиране, управление и съхранение на данни в компютъра, така че да могат да се използват ефективно
	Основните операции, които може да извършваме с данните с:
	- добавяне
	- триене 
	- търсене
	- обхождане
	
* Предимства и недостатъци на масивите 

	Предимства:
	- Лесни за използване
	- Ефективна памет: заемат точно толкова памет колкото е нужно за данните 
	- Бърз достъп до индекс (O(1)): Моментален достъп до всеки елемент стига да се знае неговият индекс 
	
	Недостатъци:
	- Фиксиран размер: След като е създаден размера на масива не може да бъде променен
	- Скъпо добавяне/триене: Това е бавна операция, защото всички следващи елемени трябва да бъдат преместени с една позиция напред или назад
	- Бавно търсене по стойност: В обикновен несортиран масив елемент се намира с (O(N)), докато в сортиран масив се намира с (O(logN))
	
* Определение за колекции 

	Java предоставя готови библиотеки (frameworks) за работа с групи от обекти. Вместо да се създават собствени структури от данни от нулата,
	може да се използват готовите, които са тествани и оптимизирани класове и алгоритмите от тези библиотеки
	
	За разлика от масивите, които имат фиксиран брой, колекциите могат автоматично да се разширяват или свиват, като се добавя или премахва елемент
	Колекциите могат да съхраняват само обекти, но не и примитивни типове (тоест трябва да се използват класовете за примитивните типове)
	
	Всички интерфейси и класове се намират в пакета java.util
	
	Колекциите са удобен интерфейс за програмиста, а неговите имплементации са някои от основните структури данни:
	- Масиви: Елементите са подредени един след друг в паметта в непрекъснат блок, имат икзлючително бърз достъп до елемент по неговия номер
	- Свързани списъци: Всеки елемент съдържа данни и сочи към следващия елемент, те са ефективни при добавяне и изваждане
	- Хеш таблици: Структура която използва функция за да преобразува даден ключ (например данни) в индекс на масив. Позволява моментално намиране добавяне и изтриване
	- Дървета: Организирани данни в йерархична структура, подобна на родословно дърво. Полезнае е при съхранение на сортирани данни и за много бързо търсене
	
* Итератори 

	Итератора е специален обект, който служи като универсален начин за 	през елментите на една колекция независимо от нейния тип 
	Без значение дали е ArrayList, LinkedList или HashSet итератора се използва по един и същи начин и неговите два основни метода са:
	- има ли следващ елемент (hasNext())
	- дай ми следващия елемент (next())
	
	Обхождането с for-each използва итератор "зад кулисите". Когато се напише такъв код, компилатора го превръща в код, който използва итератор от колекцията 
	
* Iterable и Iterator 

	Iterable е обект, който може да бъде обходен (за пример списък), а Iterator е обектът, който извършва самото обхождане
	
	Интерфейсът Itarable<T> се имплементра от всяка колекция, това даже указва, че една колекция може да бъде обходена 
	Единственият метод е Iterator<T> iterator() което връща обект Iterator<T>, който се използва за осъществяването на самото обхождане на елементите
	Реално всеки клас който имплементира Iterable може да бъде използван в for-each цикъл
	
	Интерфейсът Iterator<E> предоставя стандартен начин за обхождане на елементите в една колекция и поддръжа състоянието на текущата итерация (тоест знае до кой елемент е стигнал)
	Основните методи са:
	- boolean hasNext(), връща trye ако в колекцията има още елементи, които не са обходени 
	- E next(), връща следващия елемент от колекцията и премества вътрешния указател с една позиция напред 
	- void remove(), премахва от колекцията последния елемент, койте е бил върнат от next() 
	
	Общо взето един обект, който е Iterable, е източник на данни. Когато се извиква неговия метод iterator() той създава и връща нов обект Iterator,
	който е конкретния механизъм извършващ обхождането на данните в Iterable обекта 
	
* Методът remove() на Iterator<T>

	Методът Iterator.remove() е единствения безопасен начин за премахване на елемент от колекцията по време на обхождането и. Той премахва послендия елемент, който е бил върнат от next() 
	Не може да бъде извикан преди next() да е бил извикан поне веднъж нито не може да бъде извикван повече от ведбъж за едно и също извикване на next()

	Основното правило е да не се модифира колекцията докато е обхождана от итератора, защото поведението на итератора може да стане невалидно, единственото изключение е remove()
	Може да настъпи проблем, ако примерно извикваме add() clear() или подобен метод на обекта 
	
	Този опит модификация по време на итериране може да доведе до изключението ConcurrentModificationException
	
* Йерархията на основните интерфейси и класове в Java Collections Frameworka

	Йерархията на Collection започва от интерфейса Iterable, което означава че елементите на всяка колекция могат да бъдат обхождани.
	Collection (наследява Iterable) е базовият интерфейс за всички структури, които представляват група обекти. Основните му разклонения са:
	- List: Последователна колекция от елементи, които допускат дублиращи се елементи, елементите се достъпват чрез целочислен индекс
	Основните класове са: ArrayList, LinkedList, Vector
	
	- Set: Колекцията не позволява дублиращи се елементи, основните класове са HashSet, LinkedHashSet (пази реда на добавяне), TreeSet (пази елементтие сортирани)
	
	- Queue: Проектиран за съхранението на елементи преди обработка, като работи на FIFO принципа, основните класове са LinkedList, ArrayDeque
	
	Йерархията на Map не наследява Collection, защото представлява различна структура от данни.
	Основният интерфейс Map съхранява двойки ключ-стойности като всеки ключ е уникален и се използва за достъп до съответната му стойност
	SequencedMap интерфейсът разширява интерфейсът Map и е предназначен за речници, които поддържат реда на своите двойки ключ-стойност.
	Единствената имплементация на SequenceMap е LinkedHashMap, докато SortedMap го наследява, а NavigatbleMap наследяват SortedMap
	Единствените имплементации на NavigatbleMap e TreeMap и ConcurrentSkipListMap
	
* Обхождане на колекции

	Има два различни начина за обхождане на една колекция, като и двата достигат еднакакъв резултат:
	- чрез for each цикъл:
	for (float current : nums) System.out.println("%.2f%n", current);
	
	- чрез итератор:
	Iterator<Float> iterator = nums.iterator();
	while(iterator.hasNext()) System.out.printf("%.2f%n", iterator.next());
	
* Обхождане на Map printf
	
	Има три основни начина да се обходи Map:
	- чрез колекция от неговите ключове: keySet() връща Set съдържащ сички ключове в Map-a, използваме го само когато искаме само ключовете или искаме да итерираме през ключовете
	- чрез колекция от неговите стойности: values() връща Collection, който съдържа всички стойности в Map-a. Използваме го като само ни трябват стойностите 
	- чрез колекция от двойки ключ-стойност: entitySet() връща set който съдържа всички двойки ключ-стойности, обвити са в обект от тип Map.Entry
	Най-ефективен начин за обхождането на Map, защото едновременно може да вземем ключ и стойности
	
	Понеже Map не наследява Iterable, не може да се обходи с for-each цикъл, вместо това първо трябва да се извлече Collection на неговото съдържание
	
* Основните методи дефинирани в java.util.Collection 

	Този интерфейс е в основната на йерархията на повечето колекции в Java.

	Методи за проверка и размер:
	- int size(): връща стойността на колекцията
	- boolean isEmpty(): проверява дали колекцията е празна
	- boolean contains(Object element): проверява дали даден елемент се намира в колекцията 
	
	Методите за модификация (единични елементи)
	- boolean add(E element): добавя посочения елемент към колекцията, връща true ако е успешно
	- boolean remove(Object element): премахва първото срещата на посочения елемент от колекцията и връща true ако е успешно и е премахнато
	
	Групови операции (Bulk operations)
	Тези методи извършват операция върху колекция, като използват елементи от друга колекция:
	- boolean containsAll(Collection<?> c) връща true, ако всичките елементи на подадената колекция се намират в текущата колекция
	- boolean addAll(Collection<? extends E> c) връща true, ако успешко е добавило елементите от c към текущата колекция 
	- boolean removeAll(Collection<?> c) премахва от текущата колекция всички елементи, които се намират в c 
	- boolean retainAll(Collection<?> c) премахва всички елементи освен тези от c, които се намират в текущата колекция 
	- void clear() премахва всички елементи от колекцията 
	
	Методи за обхождане и конвертиране
	- Iterator<E> iterator() връща iterator обект, който може да се използва за обхождане на елементите в колекцията 
	- Object[] toArray() и <T> toArray(T[]a) конвертират колекцията в масив, втория метод е предпочитан, понеже се връща масив от специфичен тип
	
* Основни методи дефинирани в java.util.List 

	List е подредена колекция, която позволява дублиращи се елементи и предоставя достъп до тях чрез индекс 
	
	Индекс-базираните операции работят с конкретна позиция (индекс) в списъка:
	- E get(int index) връща елемента на посочената позиция 
	- E remove(int index) премахва елемента на посочения индекс
	- List<E> sublist(int fromIndex, int toIndex) връща sublist от началния индекс до крайния, това не е копие тоест промените ще се отразят на главния
	
	Понеже java.util.List го наследяват ArrayList И LinkedList има разлика в бързината на техните операции:
	- get(index) в ArrayList е много бърза операция с константно време O(1)
	- get(index) в LinkedList е много бавна операция с време O(N) защото трябва да се обходят елементите от началото до края
	
	Тези методи търсят елемент по неговата стойност, а не по позицията му, те са бавни понеже са бързи за време O(n):
	- int indexOf(Object a) връща индекса на срещаният елемент а
	- boolean constains(Object a) и boolean remove(Object a) се наследяват от java.util.Collection интерфейса

* Имплементации на List

	Най-често използваните имплементации на List са ArrayList и LinkedList
	
	Всичките имплементации на интерфейса java.util.List са:
	- ArrayList: В основата се използва динамичен масив, който се разширява автоматично при нужда.
	- LinkedList: В основата си използва двойно свързан списък, където всеки елемент пази референция към предишния и следващия елемент 
	- Vector: Подобие на ArrayList, но неговите методи са synchronized, което го прави по-безопасен в многонишкова среда, но и по-бавен.
	Счита се обаче за legacy (остарял) клас, така че е по-добре да се използва ArrayList заедно с други синхронизирани методи 
	- Stack: Класическата структура от данни, която покрива LIFO, той обаче наследява вектор, което се счита за лош дизайн
	Понеже е legacy клас се препоръчва да се заменя с имплеметанции на интерфейса Deque, като например ArrayDeque

* Сложността на операциите при ArrayList и LinkedList 

	Бързите операции (O(1)) при ArrayList:
	- get(index)
	- add(в края обаче)
	Бавни операции (O(n)) при ArrayList:
	- remove(0) / add(0,...,) много бавно добавяне или премахване на елемент в началото или средата, защото другите елементи трябва да са преместени
	- contains: Изисква обхождането на елементите един по един, тоест O(n^2)
	
	Бързите операции на LinkedList:
	- изключително бързи операции в добавянето или премахването на елементи в началото или края на списъка, понеже само се променя референциите
	- iterator.remove премахването чрез iterator също е много бързо 
	Бавни операции (O(n)):
	- много бавен достъп до произволен индекс, защото трябва да се обходят всички елементи от началото до желания индекс 
	- contains Отновно изисква обхождане на много елементи един по един 
	
* Кога да използваме ArrayList или LinkedList 

	Използваме ArrayList, когато се нуждаен от достъп до елементи по техния индекс 
	Използваме LinkedList, когато операциите често са добавяне и премахване в началото или края на списък, тук достъпът до индекс трябва да е рядък.
	
* Основни методи декларирани в java.util.Queue 

	Queue е структура от данни, която работи на FIFO принципа, тоест първият влязал е първият излязал 
	
	Има два вида методи този интерфейс:
	- такива които хвърлят изключение, ако операцията не може да се изпълни 
	- такива който връщата специална стойност, връщата специална стойност за да сигнализират за неуспех
	
	Методи за добавяне на елемент в края на опашката:
	- add(e) хвърля изключението IllegalStateException, ако опашката е с фиксиран капацитет и е пълна 
	- offer(e) връща false ако опашката е пълна 
	
	Методи за премахване на елемет в началото на опашката:
	- remove(e) хвърля NoSuchElementException, ако опашката е празна 
	- poll() връща null, ако опашката е празна 
	
	Методи за проверка на елемент в началото, без да го премахва:
	- element() хвърля NoSuchElementException ако опашката е празна 
	- peek() връща null ако опашката е празна 
	
* Имплементации на java.lang.Queue 

	Имплементации на интерфейса Queue са следните:
	- PriorityQueue: Елементите тук се поставят според техния естествен ред или според зададен Comparator. Елементът с най-висок приоритет е в началото на опашката.
	Вътрешната структура е heap (пирамида)
	- LinkedList (свързан списък): Може и да се използва като нормална FIFO опашка, понеже имлементира както List така и Queue
	- ArrayDeque (Двупосочна опашка с масив): Имплементира двупосочна опашка Deque, което означава, че може ефективно да добавя и премахва елементи от двата края .
	Използва цикличен масив, като това е препоръчителната имплементация за стандартна FIFO опашка 
	
* Сравнение между сложността на методите на имплементациите на Queue
	
	Малко допълнително обяснение относно сложностите:
	- O(1) (константна сложност): операцията отнема едно и също време, независимо колко елемента има в колекцията. Това е изключително бързо 
	- O(logn) (логаритмична сложност): времето за изпълнение на работа расте много бавно с увеличаване на броя на елементите (n). Това също се счита за много бързо.
	
	Имплементациите LinkedList и ArrayDeque показва O(1) сложност за стандартните операции на опашка:
	- offer (добавяне в края): понеже и двете структури поддръжат директен указател/индекс към края, така че добавянето да е моментално  
	- poll (премахване от началото): поддържат указател и към началото, което прави премахването също моментално  
	- peek (поглеждане в началото): достъпът до първия елемент в началото е веднагически
	
	Имплементацията PriorityQueue не следва FIFO принципа, тя подрежда елементите по техния приоритет:
	- peek е с O(1), защото елементът с най-висок приоритет винаги се намира на върха на хиипа (heap)
	- offer е О(logN), защото новият елемент трябва да бъде поставен на правилното му място в heap-a, за да се запази подредбата. Тази операция отнема логаритмично време 
	- poll е с O(logN), след като се премахне елементът стурктурата отново трябва да се пренаредеи, за да се избута следващия най-приоритетен. Това също отнема логаритмично време 
	
* Основни методи в Set интерфейса 

	Set интерфейса наследява Collection интерфейса, като логиката зад тези методи се спазва в имплементациите на интерфейса:
	- boolean add(E e) добавя елемент в множествотоо само ако този елемент все още не съществува. Връща truee ако е успешно и false ако не е успешно 
	- boolean contains(Object a) проверява дали даден елемент се съдържа в множеството, това е много бърза опрерация за имплементациите 
	- boolean remove(Object a) премахва посочен елемент, ако той съществува 
	- int size() 
	- boolean isEmpty()
	- Object[] toArray() конвертира множеството в масив.
	
* Основните имплементации на java.util.Set 

	Основните имплементации на този интерфейс са:
	- HashSet не поддържа никакъв ред на елементите и структурата му е хеш таблица (вътрешно използва хеш мап). Тя е много бърза за основните методи (add, remove, contains) 
	които се изпълняват със средна сложност O(1). Целта и е максимална производителност, а не подредба 
	
	- LinkedHashSet поддържа елементите в ред на тяното добавяне, структурата му е хеш таблица + двойно свързани списък. Тя използва хеш таблица, за да осигури бързината на HashSet-a,
	като използва и свързан списък, за да поддръжа реда на добавянето на елементи 
	
	- TreeSet поддържа елементите в сортиран ред като структурата му е червено-черно дърво (вътрешно използва TreeMap). Елементите се поддръждат или чрез естествения им ред
	(ако е имплементиран Comparator) или при подаден Comparator. Понеже използва балансирано дърво основните операции са по-бавни O(logn)
	
	- EnumSet е специализирана високо оптимизирана имплементация само за enum типове, като използва битов масив (bit vector)
	Вътрешно представя множеството от enum константи като поредица от битове. Всеки бит отговаря на една от възможните стойности на enum-a.
	Тази структура е много бърза и всичките и операции са O(1).
	
* Кога да използваме следните имплементации на java.util.Set 

	HashSet е най-добре да се използва когато редът няма значение, а скоростта е приоритет
	LinkedHashSet се използва когато искаме да запазим редът но ни трябва и скоростта на HashSet 
	TreeSet се използва когато елементите трябва да бъдат сортирани 
	EnumSet се използва когато се работи с множество от enum стойности
	
* Конструиране на HashSet 
	
	При използване на конструкторите, има два термина, които са свързани с производителнсотта на хеш-базираните структури:
	- initial capacity: това е първоначалния капацитет, тоест броят на bucket-ите с които хеш таблицата стартира 
	- load factor: това е фактора за запълване, число между 0.0 и 1.0 което определя колко пълна може да бъде хеш таблицата, преди капацитета и да бъде автоматично увеличен
	Прагът се изчислява чрез capacity * load factor.
	
	Следните конструктори са:
	- HashSet(): това е базовия конструктор, създава празен HashSet като първоначалният му капацитет е 16 а фактора за изпълнение е 0.75
	- HashSet(Collection<? extends E> c): създава HashSet като го запълва със всчики елементи от c, няма да има дубликати 
	- HashSet(int initialCapacity): ръчно се създава първоначалния капацитет
	- HashSet(int initialCapacity, float loadFactor): позволява ти да зададеш както capacity-то така и load factor-a 
	
	От Java19 има и статичен factory метод за създаване на HashSet: HashSet.newHashSet(int numElements)
	Вместо да му задваме капацитет, задаваме броя на елементите, които ще се добавят. След това метода сам изчислява необходимия капацитет.
	
* Конструктори на TreeSet 

	Не забравяй, TreeSet може да подрежда елементите си по 2 начина:
	- Естествен ред (Natural Ordering): Използва се когато самите обекти знаят как да се сравняват един с друг, това се случва като техния клас е имплементирал Comparable
	- Персонализиран ред (Custom Ordering): Използва се когато се иска да се наложи различна логика на сортиране, това се постига когато се подаде обект от тип Comparator
	
	Конструкторите на TreeSet следват:
	- TreeSet() създава празен TreeSet, който ще подрежда елементите по техният естествен ред, ако се добави елемент, който не имплементира Comparable ще бъде хвърлено изключение 
	- TreeSet(Comparator<? extends E> comparator) създава празен TreeSet, който използва подадения Comparator за подредба на елементите
	- TreeSet(Collection<? extends E> c) създава TreeSet, който съдържа всички елементи от c като елементите ще бъдат сортирани спрямо техния естествен ред.
	- TreeSet(SortedSet<E> s) създава нов TreeSet като съдържа елементите от s и използва същата логика на сортиране като подения SortedSet
	
* java.lang.Comparable vs java.util.Comparator

	Comparable дефинира естествен ред на един обект, докато Comparator дефинира персонализиран ред или външен ред 
	
	java.lang.Comparable<T>
	Това е интерфейс, чиито метод int compareTo(T other) се имплементира от самият клас.
	Отговаря на въпроса как един обект се сравнява с друг обект, така така се дефинира основния естествен ред за един клас. Един клас може само 1 естествен ред да има.

	java.util.Comparator<T>
	Това е интерфейс, който се имплементира в отделен или външен клас, метода който трябва да се имплементира от този интерфейс е int compare(T o1, T o2)
	Използва се когато:
	- Искаме да сортираме обекти от даден клас, който не е имплементирал Comparable 
	- Искаме различен начин за сортиране на обектите от вече дефинирания им естествен ред 
	
* Консистентност с equals() 

	Това е много важно правило за дизайн при имплементиране на Comparable:
	Естествения ред е консистентен с equals, ако e1.compareTo(e2) == 0 връща true винаги, когато e1.equals(e2) връща true
	Сортираните колекции като TreeSet и TreeMap използват compareTo() или compare() за да проверят за равенство на елементите, а не equals()
	Ако compareTo() върне 0, а equals() върне false, поведението на колекцията ще бъде много объркващо.
	
* Сложността на методите на имплементациите на интерфейса java.util.Sets 

	Следните методи в HashSet имат сложността:
	- add и contains имат сложност от O(1), като това е средната сложност. HashSet използва hashCode() метода на обекта, за да го постави в правилния bucket на хеш таблицата.
	- next използва O(h/n), защото обхождането е по-бавно. Итератора трябва да премине през вътрешния масив на таблицата (с капацитет h).
	
	Следните методи в LinkedHashSet имат сложността:
	- add и contains са изключително бързи със сложност O(1)
	- next работи с O(1) сложност, защото обхождането е много бързо. За разликата от HashSet тук има вътрешен свързан списък, който свързва елементите в реда на тяхното добавяне.
	
	Следните методи в TreeSet имат сложността:
	- Всички операции са O(logN), много са бързи, но не са константни, понеже TreeSet използва балансирано двоично дърво, за да поддържа елементите винаги сортирани
	
* Основните методи декларирани в интерфейса java.util.Map

	Интерфейсът java.util.Map е структура от данни, която съхранява двойки ключ-стойност.
	
	Методите, които са декларирани в интерфейса са:
	- V put(K key, V value) добавя или актуализира двойка в речника. Ако ключа е нов, той се добавя и методът връща null, в противен случай връща старата старата стойност и тя е заменена с нова в речника 
	- V get(Object key) връща стойността, която е свързана с ключа, ако този ключ не съществува се връща null 
	- V remove(Object key) премахва двойката ключ-стойност за посочен ключ и връща премахнатата стойност 
	- boolean containsKey(Object key) проверява дали вече се намира ключа в структурата
	- int size()
	- boolean isEmpty() 
	
	В интерфейса съществуват методи, които връщат колекции, за да може да се обходи структурата, понеже Map не може да бъде обходен директно:
	- Set<K> keySet() връща Set с всичките ключове 
	- Collection<V> values() връща Collection със всички стойности, понеже стойностите могат да се повтарят затова резултата не е Set 
	
* Имплементациита на интерфейса java.util.Map 

	Следните имплементации на java.util.Map са:
	- HashMap, не поддържа никакъв ред на ключовете и структурата му е хеш таблица. Тя е изключително бърза за следните операции (put,get,remove), които се изпълняват със средна O(1)
	- LinkedHashMap поддържа ключовете в реда на тяхното добавяне като структурата му е хеш таблица + двойно свързан списък. 
	- TreeMap поддръжа двойките сортирани по ключове и структурата му е червено-черно дърво. Ключовете се подреждат или според естествния им ред (Comparable) или според подаден Comparator.
	Понеже използва балансирано дърво, основните му операции са със сложност O(logN)
	- EnumMap е специализирана и високо оптимизирана имплементация за enum ключове като стурктурата му е обикновен масив. Всички операции са с константна сложност 

* Колекции с наредва vs колекции без наредба

	Колекции с наредба:
	Имплементациите са TreeMap и ТreeSet като елементите са винаги в сортиран ред и вътрешно тези имплементации използват самобалансиращо се дърво.
	За да може да зададе естествен ред на обектите трябва или класът да е имплементирал Comparable или при създаването на колекцията да се подаде Comparator 
	Операциите са малко по-бавни, но пак доста бързи със скорост O(logn) за операциите добавяне, изваждане и търсене 
	
	Колекции без наредба:
	Имплементациите са HashMap и HashSet като в тях не се гарантира ред на елементите, за да има максимална скорост. Вътрешната струкутра е хеш таблица.
	Чрез метода hashCode() на обекта се изчислява индекс и се поставят елемента директно там. Така се позволява почти моментално намиране 
	За да работят коректно обектите в тази структура, трябва да се имплементират методите hashCode и equals()
	Това е най-бързата колекция като основните операции са със средна сложност O(1)
	
* Sequenced Collections интефейсът 

	Sequenced Collections, които са въведени още от Java 21, предоставят унифицирани и предивидими API за работа с колекции, които имат дефиниран ред на елементите.
	
	Преди Java 21 достъпът до първия или последния елемент на различните видове подредени колекции е бил доста тромав:
	- За да вземеш последния елемент на List е трябвало да изчислиш индекса с list.get(list.size() - 1) 
	- За да вземеш първия елемент на LinkedHashSet е трябвало с интератор да го достъпъш linkedHashSet.interator().next();
	
	Обаче след въвеждането му се оправя този проблеми и се наследява от интерфейсите List, Deque, LinkedHashSet, SortedSet и техните имплементации 
	Интерфейсът добавя методи за работа с първия и последния елемент:
	- getFirst(), getLast() за достъп 
	- addFirst(E e), addLast(E e) за добавяне 
	- removeFirst(), removeLast() за премахване 
	
	Интерфейсът предоставя и метода reversed() и с него има няколко функционалности:
	- Той не създава ново копие на колекцията в обратен ред 
	- Този метод връща view на оригиналната колекция като я предоставя в обратен ред, тоест всички промени в оригиналната колекция се отразяват в този изглед
	
* Интерфейсът SequencedSet 

	Този метод не добавя нови методи, а предефинира поведението на наследниците 
	
	SequencedSet наследява метода reversed() от SequencedCollection и го предефинира така че резултата да е от тип SequencedSet, а не просто SequencedCollection
	
	Една от основните промени, които SequencedSet въвежда са:
	- При стандартен Set, ако извикаш add() с елемент, който вече съществува, операцията просто се игнорира 
	- При SequencedSet, ако извикаш addFirst(E) или addLast(E) който вече се съдържа в множеството, елементът ще бъде преместен в началото или в края 
	
* SequencedMap интерфейса 

	Интерфейсът SequencedMap предоставя APIs за работа с Map имплементации, които гарантират дефиниран ред на своите двойки ключ-стойности 
	Преди Java 21, LinkedHashMap и Treemap поддръжаха ред, но липсваше общ интерфейс за достъп до първия и послендия елемент, сега SequencedMap решава този проблем.
	
	Методи за достъп до първата/последната двойка:
	- firstEntity() връща първата двойка-ключ 
	- lastEntity() връща последната двойка-ключ 
	
	Методи за добавяне в началото/края:
	- putFirst(K k, V v) записваме двойка в началото, ако тя вече съществува в списъка се премества в началото 
	- putLast(K k, V v) записва двойка в края, ако тя вече съществува се добавя в края. 
	
	Премахване на първи и последен запис:
	- pollFirstEntity() премахва и връща първия запис 
	- pollLastEntity() премахва и връща последния запис 
	
	В този интерфейс има и подобрения на методите, които връщат изгледи:
	- SequencedMap<K,V> reversed() връща изглед на картата, но в обратен ред, без да се създава ново копие 
	- sequencedKeySet(), sequencedValues(), sequencedEntitySet() това са помощни версии от keySet(), values() и entitySet() като те връщат sequenced колекции,
	тоест върху тях може да се използват методите getFirst(), getLast() и reversed() 
	
	Например лесно може да се вземе вече първия ключ без да се използва генератор
	K firstKey = myMap.sequencedKeySet().getFirst();
	
* Помощни операции от класа java.util.Collections 

	Сортиране в естествен ред 
	Collections.sort(List<T> list) може да сортира списъка спрямо естествения ред на елементите, за да работи класът T трябва да е имлементирал Comparable 
	
	Сортиране в персонализиран ред
	Collections.sort(nums, Collections.reverseOrder()) позволява подаването на втори аргумент Comparator, който дефинира логиката на новото сортиране 
	Collections.reverseOrder() е помощен метод, който връща Comparator. 
	
	Двоично търсене 
	Collections.binarySearch(List<T> list, T key);
	С подадения лист може да приложи двоично търсене за да намери key обекта, не забравяй че list трябва да бъде сортиран възходително
	
	Разместване на елементи по произволен начин 
	Collections.shuffle(List<?> list) е статичен метод от java.util.Collections и то размества елементите в падения списък по напълно случаен начин
	Този метод работи in-place тоест че модифицира оригинално подадения списък вместо да създава ново копие 
	
	Метод за копиране на елементи от един списук в друг списък 
	Collections.copy(List dest, List src) е статичен метод, който копира всички елементи от списъка srv в списъка dest
	Важно е dest да поне поне толкова голям, колкото src, в противен случай ще се хвърли изключние IndexOutOfBoundsException 
	
	Замяна на всички елементи с една и съща стойност 
	Collections.fill(List list, Object obj) е статичен метод, който пренаписва всеки един елемент в List със стойността на obj 
	Този метод не променя размера на списъка, а само стойността на елементите в списъка 
	
	Обръщане на реда на всички елементи в даден списък 
	Методът Collections.reverse(List<?> list) e статичен метод, който обръща реда на всички елементи в подаден списък 
	Самата операция се зивръшва на място, тоест е in-place и се променя оригиналния списък 
	
	Размяна на местата на два посочени елемента
	Collections.swap(List<?> list, int i, int j) е статичен медот. който разменя местата на елементите намиращи се на позиции i и j
	Операцията също се извършва на място, тоест е in-place 
	
	Намиране на най-големия и най-малкия елемент в колекция:
	- Collections.min(Collection c) обхваща цялата колекция и връща най-малкия елемент в колекцията 
	- Collections.max(Collection c) охваща целялата колекция и връща най-големия елемент в колекцията 
	За да работят тези методи правилно, класът на обектите в колекцията трябва да е дефинирал Comparable.
	
	Намиране на броя на срещатанията на даден елемент в колекцията 
	Collections.frequency(Collection c, Object o) брой и връща колко пъти се среща обекта o в колекцията c 
	
* Immutable vs Unmodifiable колекции 

	Unmodifiable е обвивка, която забранява промени през нея, докато immutable е абсолютна гаранция, че обвивката няма да се промени след създаването и.
	
	Unmodifiable колекции 
	Създава се чрез метода Collections.unmodifiableList(myList) като не се позволява викането на модифициращи методи като add(), remove() или clear(), при опит се хвърля UnsupportedOperationsException.
	Има две слаби места:
	- При достъп до оригиналната колекция промените в нея ще се отразят на unmodifiable колекцията 
	- Ако самите елементи вътре в тази колекция могат да се променят, е напълно позволено да се промени тяхното състояние, но не може да се премахнат от колекцията 
	
	Immutable колекции 
	Създава се чрез методи като List.of("a", "b", "c") като тези колекции ще бъдат абсолютно непроменими.
	Няма методи като add() или remove() и няма как оригиналните данни да бъдат променени от друго място. За да бъде истински immutable тя трябва да съдържа само immutable елементи като String, Integer.
	
	Няколко готини свойства на unmodifiable колекциите:
	- по-малко памет 
	- Не могат да съдържат null елементи 
	- при идентично извивкане на .of() factory метода JVM може да реши да връща референции и това да оптимизира процеса 