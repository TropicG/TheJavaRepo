<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерактивен Тест - Java Collections</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .correct-answer {
            background-color: #22c55e !important;
            color: white !important;
            border-color: #16a34a !important;
        }
        .incorrect-answer {
            background-color: #ef4444 !important;
            color: white !important;
            border-color: #dc2626 !important;
        }
    </style>
</head>
<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 flex items-center justify-center min-h-screen p-4">

    <div id="quiz-container" class="w-full max-w-3xl bg-white dark:bg-slate-800 rounded-xl shadow-2xl p-6 md:p-8 transition-all duration-500">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-2xl md:text-3xl font-bold text-sky-600 dark:text-sky-400">Java Collections Тест</h1>
            <div id="progress" class="text-sm font-semibold text-slate-500 dark:text-slate-400">Въпрос <span id="current-question-number">1</span> от <span id="total-questions">50</span></div>
        </div>
        
        <div id="question-card" class="mb-6">
            <p id="question" class="text-lg md:text-xl font-semibold leading-relaxed"></p>
        </div>

        <div id="options" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <!-- Answer options will be dynamically inserted here -->
        </div>
        
        <div id="feedback-section" class="hidden mt-4 p-4 rounded-lg bg-slate-100 dark:bg-slate-700">
             <p id="rationale" class="text-sm text-slate-600 dark:text-slate-300"></p>
        </div>

        <div class="mt-8 flex justify-end">
            <button id="next-button" class="hidden bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-6 rounded-lg transition-colors duration-300">Следващ</button>
        </div>
    </div>

    <div id="result-container" class="hidden w-full max-w-3xl text-center bg-white dark:bg-slate-800 rounded-xl shadow-2xl p-8 md:p-10">
        <h2 class="text-3xl font-bold mb-4 text-sky-600 dark:text-sky-400">Тестът приключи!</h2>
        <p class="text-xl mb-6">Вашият резултат е:</p>
        <p id="score" class="text-5xl font-extrabold text-slate-800 dark:text-slate-100 mb-8">0/50</p>
        <button id="restart-button" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-8 rounded-lg transition-colors duration-300 text-lg">Нов опит</button>
    </div>

    <script>
        const quizData = [
            {
                "question": "Какво ще се случи, ако извикате метода `remove()` на `Iterator` два пъти подред, без да извикате `next()` между тях?",
                "options": [
                    { "text": "Ще бъде премахнат и последният, и предпоследният елемент, върнати от `next()`.", "correct": false, "rationale": "Методът `remove()` действа само върху последния елемент, върнат от `next()`, и не може да се прилага върху по-стари елементи." },
                    { "text": "Ще бъде хвърлено изключение `IllegalStateException`.", "correct": true, "rationale": "Спецификацията на `Iterator` позволява `remove()` да бъде извикан само веднъж след всяко извикване на `next()`." },
                    { "text": "Няма да се случи нищо при второто извикване.", "correct": false, "rationale": "Итераторът ще регистрира, че елементът вече е премахнат и ще игнорира второто извикване, но това не е стандартното поведение." },
                    { "text": "Ще бъде хвърлено `ConcurrentModificationException`.", "correct": false, "rationale": "Това изключение се хвърля, когато самата колекция се модифицира извън итератора, а не при неправилно използване на методите на итератора." }
                ]
            },
            {
                "question": "Кой е най-ефективният начин за обхождане на `Map`, ако са ви нужни едновременно и ключът, и стойността за всеки запис?",
                "options": [
                    { "text": "Чрез `keySet()`, като за всеки ключ се извиква `get(key)`.", "correct": false, "rationale": "Този подход изисква допълнително търсене (lookup) за всяка стойност, което го прави по-малко ефективен от обхождането на готовите двойки." },
                    { "text": "Чрез `values()`, тъй като стойностите са най-важни.", "correct": false, "rationale": "Този метод изобщо не предоставя достъп до ключовете, което не отговаря на изискването на задачата." },
                    { "text": "Чрез `entrySet()`, като се итерира през `Set<Map.Entry<K, V>>`.", "correct": true, "rationale": "Този метод предоставя директен достъп до обекти, които съдържат и ключа, и стойността, елиминирайки нуждата от допълнителни операции за търсене." },
                    { "text": "Map не може да се обхожда, тъй като не наследява `Iterable`.", "correct": false, "rationale": "Въпреки че `Map` не е `Iterable`, неговите изгледи (`keySet`, `values`, `entrySet`) са колекции и могат да бъдат обхождани." }
                ]
            },
            {
                "question": "Защо операцията `get(index)` в `LinkedList` е със сложност O(N), докато в `ArrayList` е O(1)?",
                "options": [
                    { "text": "`ArrayList` използва хеш таблица за бърз достъп.", "correct": false, "rationale": "`ArrayList` се базира на масив, а не на хеш таблица. Хеш таблиците се използват в `HashMap` и `HashSet`." },
                    { "text": "`LinkedList` трябва да обходи елементите един по един от началото (или края), за да достигне до посочения индекс.", "correct": true, "rationale": "Поради свързаната си структура, `LinkedList` няма директен достъп до елементите по индекс и трябва да премине през референциите последователно." },
                    { "text": "`ArrayList` съхранява индексите в отделна структура данни.", "correct": false, "rationale": "Индексът в `ArrayList` е просто отместване (offset) в паметта спрямо началото на вътрешния масив, а не отделна структура." },
                    { "text": "Достъпът в `LinkedList` е бавен само за елементи в средата, но бърз за тези в началото и края.", "correct": false, "rationale": "Дори достъпът до елемент близо до началото изисква преминаване през няколко елемента, което прави операцията зависима от позицията (N), а не константна." }
                ]
            },
            {
                "question": "При опит да добавите втори елемент към `TreeSet`, който съдържа ваши къстъм обекти, получавате `ClassCastException`. Каква е най-вероятната причина?",
                "options": [
                    { "text": "Класът на обектите не имплементира `Serializable`.", "correct": false, "rationale": "Сериализацията е свързана със запис и четене на обекти, но не и с логиката за подредба в `TreeSet`." },
                    { "text": "Класът на обектите не имплементира `Comparable` и не е подаден `Comparator` на конструктора на `TreeSet`.", "correct": true, "rationale": "`TreeSet` се нуждае от ясни инструкции как да сравнява обектите, за да ги подреди. Без тях, при опит за сравнение на втория елемент с първия, се стига до тази грешка." },
                    { "text": "Методите `hashCode()` и `equals()` не са предефинирани.", "correct": false, "rationale": "Тези методи са критични за хеш-базираните колекции (`HashSet`, `HashMap`), но `TreeSet` използва `compareTo()` или `compare()` за сравнение." },
                    { "text": "Опитвате се да добавите `null` елемент.", "correct": false, "rationale": "Добавянето на `null` би хвърлило `NullPointerException`, а не `ClassCastException`." }
                ]
            },
            {
                "question": "Какво е потенциалното последствие от дефинирането на метод `compareTo()`, който е неконсистентен с `equals()` (т.е. `a.compareTo(b) == 0`, но `a.equals(b)` е `false`)?",
                "options": [
                    { "text": "Няма последствия, тъй като колекциите използват само единия или другия метод.", "correct": false, "rationale": "Различните колекции се държат различно. `HashSet` използва `equals()`, но `TreeSet` използва `compareTo()`, което може да доведе до объркващо поведение." },
                    { "text": "Кодът няма да се компилира.", "correct": false, "rationale": "Това е логическа грешка в дизайна, а не синтактична. Компилаторът не може да провери консистентността между двата метода." },
                    { "text": "Сортирани колекции като `TreeSet` може да \"изгубят\" елементи, защото ще приемат два различни обекта за еднакви.", "correct": true, "rationale": "Тъй като `TreeSet` използва `compareTo()` за проверка на уникалност, той ще сметне двата обекта за дубликати (защото `compareTo` връща 0) и няма да добави втория, въпреки че според `equals()` те са различни." },
                    { "text": "Ще бъде хвърлено `IllegalArgumentException` при добавяне на такъв елемент в колекция.", "correct": false, "rationale": "Няма автоматична проверка по време на изпълнение, която да хвърля такова изключение. Проблемът се проявява в неочакваното поведение на колекцията." }
                ]
            },
            {
                "question": "Каква е основната разлика в поведението между `Queue.add(e)` и `Queue.offer(e)`, когато опашката е с фиксиран капацитет и вече е пълна?",
                "options": [
                    { "text": "`add(e)` връща `false`, а `offer(e)` връща `null`.", "correct": false, "rationale": "Това описва поведението на методи за премахване (`poll`) или поглеждане (`peek`), а не за добавяне." },
                    { "text": "`add(e)` хвърля `IllegalStateException`, а `offer(e)` връща `false`.", "correct": true, "rationale": "Това е ключовата разлика: `add` сигнализира за грешка чрез изключение, докато `offer` го прави чрез специална върната стойност." },
                    { "text": "И двата метода хвърлят `IllegalStateException`.", "correct": false, "rationale": "Само единият от методите е проектиран да хвърля изключение в тази ситуация." },
                    { "text": "`add(e)` изчаква да се освободи място, а `offer(e)` се проваля веднага.", "correct": false, "rationale": "Изчакването е характеристика на блокиращи опашки (BlockingQueue), които не са описани в предоставения текст." }
                ]
            },
            {
                "question": "Каква е ролята на параметъра `load factor` (фактор на запълване) при създаването на `HashSet`?",
                "options": [
                    { "text": "Определя максималния брой елементи, които `HashSet` може да съхранява.", "correct": false, "rationale": "Максималният брой не е строго фиксиран. Капацитетът се увеличава автоматично." },
                    { "text": "Определя колко пълна може да бъде хеш таблицата, преди капацитетът ѝ да бъде увеличен, за да се избегнат колизии.", "correct": true, "rationale": "Това е прагът (като процент), при достигането на който таблицата се преоразмерява, за да се запази добрата производителност и да се намали броят на колизиите." },
                    { "text": "Определя първоначалния брой \"кофи\" (buckets) в хеш таблицата.", "correct": false, "rationale": "Това се определя от параметъра `initial capacity`, а не от `load factor`." },
                    { "text": "Използва се в `hashCode()` функцията за по-добро разпределение на елементите.", "correct": false, "rationale": "Факторът на запълване е свързан със структурата на самата таблица, а не с изчисляването на хеш кода на отделните обекти." }
                ]
            },
            {
                "question": "Ако създадете `sublist` чрез `originalList.subList(from, to)` и след това структурно модифицирате `originalList` (например чрез `add()` или `remove()`), какво ще се случи при опит за достъп до `sublist`?",
                "options": [
                    { "text": "Промените в `originalList` няма да се отразят на `sublist`.", "correct": false, "rationale": "`sublist` не е копие, а изглед (view) към оригиналния списък, така че промените се отразяват." },
                    { "text": "`sublist` ще отрази промените, направени в `originalList`.", "correct": false, "rationale": "Това е вярно само за неструктурни промени (напр. `set()`). Структурните модификации правят изгледа невалиден." },
                    { "text": "Ще бъде хвърлено `ConcurrentModificationException`.", "correct": true, "rationale": "Това изключение се хвърля, защото структурната промяна на оригиналния списък прави изгледа (sublist) невалиден и всяка операция с него е опасна." },
                    { "text": "Ще бъде хвърлено `IndexOutOfBoundsException`.", "correct": false, "rationale": "Това изключение би се получило при достъп до невалиден индекс, но `ConcurrentModificationException` има предимство в този сценарий, защото проблемът е в самата модификация." }
                ]
            },
            {
                "question": "Коя от следните имплементации на `Set` гарантира O(1) сложност за итериране (извикване на `next()` от итератора)?",
                "options": [
                    { "text": "`HashSet`", "correct": false, "rationale": "Итерирането в `HashSet` зависи от капацитета на вътрешния масив (h) и броя на елементите (n), което води до сложност O(h/n), а не O(1)." },
                    { "text": "`TreeSet`", "correct": false, "rationale": "Итерирането в `TreeSet` изисква обхождане на дървовидна структура, което води до сложност O(logN) за намиране на следващия елемент." },
                    { "text": "`LinkedHashSet`", "correct": true, "rationale": "Освен хеш таблицата, `LinkedHashSet` поддържа и двойно свързан списък, който свързва елементите в реда на добавянето им. Итераторът просто следва този списък, което прави всяка стъпка (`next()`) моментална." },
                    { "text": "Нито една от посочените.", "correct": false, "rationale": "Една от имплементациите е специално проектирана да комбинира бързината на хеш таблицата с предвидим ред на итериране." }
                ]
            },
            {
                "question": "Защо `Stack` се счита за остарял (legacy) клас и коя е препоръчителната алтернатива за LIFO структура?",
                "options": [
                    { "text": "Защото е твърде бавен; алтернативата е `ArrayList`.", "correct": false, "rationale": "`ArrayList` не предоставя удобни методи за LIFO операции (`push`/`pop`) и не е проектиран за тази цел." },
                    { "text": "Защото наследява `Vector`, което е лош дизайн, и методите му са `synchronized`; алтернативата е `ArrayDeque`.", "correct": true, "rationale": "Наследяването от `Vector` излага всички негови методи, които не са типични за стек. `ArrayDeque` е модерна, бърза и ефективна имплементация на двупосочна опашка, която е идеална за LIFO операции." },
                    { "text": "Защото не може да се разширява динамично; алтернативата е `LinkedList`.", "correct": false, "rationale": "`Stack` (чрез `Vector`) може да се разширява. `LinkedList` може да се използва като стек, но `ArrayDeque` обикновено е по-ефективен." },
                    { "text": "Защото не позволява `null` елементи; алтернативата е `PriorityQueue`.", "correct": false, "rationale": "`PriorityQueue` е FIFO опашка, базирана на приоритет, и не е подходяща за LIFO структура." }
                ]
            },
            {
                "question": "Каква е основната разлика между `unmodifiable` колекция, създадена с `Collections.unmodifiableList()`, и `immutable` колекция, създадена с `List.of()`?",
                "options": [
                    { "text": "Няма разлика, те са напълно взаимозаменяеми.", "correct": false, "rationale": "Съществува ключова разлика в гаранциите, които дават. Едната е просто \"обвивка\", а другата е наистина непроменима." },
                    { "text": "`unmodifiable` колекцията може да се промени, ако се промени оригиналната колекция, докато `immutable` колекцията не може.", "correct": true, "rationale": "Това е същината на проблема: `unmodifiable` е само изглед, който забранява промени през себе си, но не и промени в източника. `immutable` колекциите са гарантирано непроменими след създаването си." },
                    { "text": "`immutable` колекциите позволяват `null` елементи, докато `unmodifiable` не позволяват.", "correct": false, "rationale": "Всъщност е обратното. `List.of()` и другите `immutable` колекции хвърлят `NullPointerException` при опит за добавяне на `null`." },
                    { "text": "`unmodifiable` колекциите са по-бързи, защото са по-стари.", "correct": false, "rationale": "Скоростта не е основният разграничител. `immutable` колекциите често са по-ефективни по отношение на паметта." }
                ]
            },
            {
                "question": "Коя операция в `ArrayList` има амортизирана сложност O(1), но в най-лошия случай може да бъде O(N)?",
                "options": [
                    { "text": "`get(index)`", "correct": false, "rationale": "Тази операция винаги е O(1), тъй като се изчислява директно адрес в паметта." },
                    { "text": "`remove(index)`", "correct": false, "rationale": "Тази операция почти винаги е O(N), защото изисква преместване на елементите след премахнатия." },
                    { "text": "`add(element)` (добавяне в края)", "correct": true, "rationale": "В повечето случаи добавянето в края е O(1). Но когато вътрешният масив се запълни, той трябва да се преоразмери (да се създаде нов, по-голям масив и да се копират старите елементи), което е O(N) операция. Тъй като това се случва рядко, средната (амортизирана) сложност е O(1)." },
                    { "text": "`contains(object)`", "correct": false, "rationale": "Тази операция винаги изисква линейно търсене и е със сложност O(N)." }
                ]
            },
            {
                "question": "Каква е сложността на операциите `offer` и `poll` в `PriorityQueue` и защо?",
                "options": [
                    { "text": "O(1), защото работи като стандартна опашка.", "correct": false, "rationale": "`PriorityQueue` не е стандартна FIFO опашка. Тя трябва да поддържа елементите подредени според техния приоритет." },
                    { "text": "O(N), защото трябва да търси правилната позиция в списък.", "correct": false, "rationale": "Вътрешната структура не е списък, а по-ефективна структура за поддържане на ред." },
                    { "text": "O(logN), защото използва балансирано двоично дърво (heap) за поддържане на реда по приоритет.", "correct": true, "rationale": "При добавяне (`offer`) или премахване (`poll`) на елемент, структурата на хийпа (пирамидата) трябва да се пренареди, което е ефективна операция със сложност O(logN)." },
                    { "text": "O(1) за `poll` и O(logN) за `offer`.", "correct": false, "rationale": "И двете операции, които модифицират структурата, изискват пренареждане на хийпа." }
                ]
            },
            {
                "question": "Кой от методите, дефинирани в интерфейса `java.util.Collection`, е групова операция (bulk operation)?",
                "options": [
                    { "text": "`add(E element)`", "correct": false, "rationale": "Това е операция върху единичен елемент, а не групова." },
                    { "text": "`contains(Object element)`", "correct": false, "rationale": "Това е операция за проверка на единичен елемент." },
                    { "text": "`retainAll(Collection<?> c)`", "correct": true, "rationale": "Тази операция модифицира текущата колекция, като използва всички елементи от друга колекция като критерий, което я прави групова." },
                    { "text": "`iterator()`", "correct": false, "rationale": "Този метод връща обект за обхождане и не извършва модификация върху група елементи." }
                ]
            },
            {
                "question": "Кога е по-подходящо да се използва `EnumSet` вместо `HashSet<MyEnum>`?",
                "options": [
                    { "text": "Когато редът на добавяне на елементите е важен.", "correct": false, "rationale": "`EnumSet` не гарантира ред на добавяне, а поддържа елементите в техния естествен ред (реда на дефиниране в `enum`)." },
                    { "text": "Винаги, когато се работи с множество от `enum` стойности, поради изключително високата производителност и ефективност на паметта.", "correct": true, "rationale": "Вътрешната имплементация на `EnumSet` като битов вектор е специално оптимизирана за `enum` типове и е значително по-бърза и лека от общата имплементация на `HashSet`." },
                    { "text": "Когато множеството трябва да бъде `thread-safe`.", "correct": false, "rationale": "`EnumSet` не е `thread-safe` по подразбиране, също както `HashSet`." },
                    { "text": "Само когато `enum` типът има по-малко от 16 константи.", "correct": false, "rationale": "Въпреки че е най-ефективен за малки `enum`-и, `EnumSet` работи отлично и с по-големи, като вътрешно може да използва масив от `long` стойности." }
                ]
            },
            {
                "question": "Какво връща методът `Collections.binarySearch()` върху несортиран списък?",
                "options": [
                    { "text": "Хвърля `IllegalStateException`.", "correct": false, "rationale": "Това изключение не е свързано с тази операция. Грешката е логическа, а не в състоянието на обекта." },
                    { "text": "Индексът на намерения елемент, ако има късмет.", "correct": false, "rationale": "Възможно е случайно да намери елемента, но това не е гарантирано. Поведението е непредсказуемо." },
                    { "text": "Непредсказуем резултат (може да е грешен индекс или отрицателно число).", "correct": true, "rationale": "Двоичното търсене разчита изцяло на това, че списъкът е сортиран. Ако не е, алгоритъмът ще следва грешен път и резултатът няма да има смисъл." },
                    { "text": "Винаги връща -1.", "correct": false, "rationale": "Връщането на -1 би означавало, че елементът не е намерен, но при несортиран списък може да върне и положителен, но грешен индекс." }
                ]
            },
            {
                "question": "Кой интерфейс, въведен в Java 21, унифицира API-то за достъп до първия и последния елемент на подредени колекции като `List` и `LinkedHashSet`?",
                "options": [
                    { "text": "`OrderedCollection`", "correct": false, "rationale": "Това име е логично, но не е името на реалния интерфейс, въведен в Java." },
                    { "text": "`SequencedCollection`", "correct": true, "rationale": "Този интерфейс добавя методите `getFirst()`, `getLast()`, `addFirst()`, `removeLast()` и `reversed()`, решавайки проблема с разнородните начини за достъп до краищата на колекциите." },
                    { "text": "`NavigableCollection`", "correct": false, "rationale": "`NavigableSet` и `NavigableMap` съществуват от по-рано и са свързани със сортирани колекции, предлагайки по-сложни операции за навигация." },
                    { "text": "`Deque`", "correct": false, "rationale": "`Deque` предлага подобни методи, но е специфичен за двупосочни опашки. `SequencedCollection` е по-общ интерфейс, който се имплементира от по-широк кръг колекции." }
                ]
            },
            {
                "question": "Какво е специфичното поведение на `addFirst(E)` в `SequencedSet` (напр. `LinkedHashSet`), ако елементът вече съществува в множеството?",
                "options": [
                    { "text": "Операцията се игнорира и редът не се променя.", "correct": false, "rationale": "Това е поведението на стандартния `add()` метод в `Set`, но новите методи за добавяне в началото/края имат различна семантика." },
                    { "text": "Хвърля `IllegalArgumentException`, защото елементът вече съществува.", "correct": false, "rationale": "Дублиращите се елементи не са позволени, но операцията не води до изключение, а до пренареждане." },
                    { "text": "Елементът се премества в началото на множеството.", "correct": true, "rationale": "Това е ключовата промяна, въведена от `SequencedSet`. Вместо да игнорира операцията, тя премества съществуващия елемент, променяйки реда му." },
                    { "text": "Създава се дубликат на елемента в началото на множеството.", "correct": false, "rationale": "`Set` по дефиниция не може да съдържа дубликати. Елементът просто се премества." }
                ]
            },
            {
                "question": "Защо `Map` интерфейсът не наследява `Collection` интерфейса?",
                "options": [
                    { "text": "Защото е по-стар и е създаден преди `Collection`.", "correct": false, "rationale": "И двата интерфейса са част от Java Collections Framework от самото начало (Java 1.2)." },
                    { "text": "Защото методите на `Map` са несъвместими с тези на `Collection`.", "correct": true, "rationale": "Методът `add(E)` от `Collection` не би имал смисъл в контекста на `Map`, който изисква ключ и стойност (`put(K, V)`). Това е фундаментална разлика в структурата." },
                    { "text": "Защото `Map` не може да бъде обходен с итератор.", "correct": false, "rationale": "Въпреки че самият `Map` не е `Iterable`, той предоставя изгледи (`keySet`, `values`, `entrySet`), които са `Collection` и могат да бъдат обходени." },
                    { "text": "Това е пропуск в дизайна на Java, който е коригиран по-късно.", "correct": false, "rationale": "Това е съзнателно дизайнерско решение, базирано на различната семантика и структура на двете абстракции." }
                ]
            },
            {
                "question": "Какво връща методът `put(K key, V value)` на `HashMap`, ако ключът `key` вече съществува в мапа?",
                "options": [
                    { "text": "`null`", "correct": false, "rationale": "`null` се връща, когато ключът е нов и се добавя за първи път." },
                    { "text": "Новата стойност, която току-що е била записана.", "correct": false, "rationale": "Методът връща информация за това какво е било в мапа преди операцията." },
                    { "text": "Старата стойност, която е била асоциирана с този ключ.", "correct": true, "rationale": "Това позволява на извикващия код да знае дали е имало предишна стойност и каква е била тя, преди да бъде презаписана." },
                    { "text": "`true`, за да индикира, че операцията е успешна.", "correct": false, "rationale": "Методите `add` в `Collection` връщат `boolean`, но `put` в `Map` връща стойност от тип `V`." }
                ]
            },
            {
                "question": "При използване на `Collections.copy(dest, src)`, какво ще се случи, ако `dest` списъкът има по-малко елементи от `src` списъка?",
                "options": [
                    { "text": "`dest` списъкът ще бъде автоматично разширен, за да побере всички елементи от `src`.", "correct": false, "rationale": "Методът `copy` не променя размера на дестинационния списък, той само презаписва съществуващи елементи." },
                    { "text": "Ще бъдат копирани само толкова елементи, колкото е размерът на `dest`.", "correct": false, "rationale": "Методът е проектиран да бъде безопасен и не позволява запис извън границите на дестинационния списък." },
                    { "text": "Ще бъде хвърлено `IndexOutOfBoundsException`.", "correct": true, "rationale": "Тъй като `copy` се опитва да запише на индекси в `dest`, които не съществуват, това води до грешка за излизане извън границите." },
                    { "text": "Ще бъде хвърлено `IllegalArgumentException`.", "correct": false, "rationale": "Грешката не е в самите аргументи (те са валидни списъци), а в техните размери, което води до проблем с достъпа по индекс." }
                ]
            },
            {
                "question": "Коя имплементация на `Map` бихте избрали, ако трябва да обхождате двойките ключ-стойност в реда, в който са били добавени?",
                "options": [
                    { "text": "`HashMap`", "correct": false, "rationale": "`HashMap` не предоставя никакви гаранции за реда на елементите; той може да се променя с времето." },
                    { "text": "`TreeMap`", "correct": false, "rationale": "`TreeMap` поддържа елементите сортирани по ключ, което не е същото като ред на добавяне." },
                    { "text": "`LinkedHashMap`", "correct": true, "rationale": "Тази имплементация комбинира хеш таблица за бърз достъп с двойно свързан списък, който поддържа реда на вмъкване." },
                    { "text": "`EnumMap`", "correct": false, "rationale": "`EnumMap` поддържа ред, но той е естественият ред на `enum` константите, а не редът на добавяне." }
                ]
            },
            {
                "question": "Какво е основното предимство на `ArrayDeque` пред `LinkedList`, когато се използва като стандартна FIFO опашка?",
                "options": [
                    { "text": "`ArrayDeque` е `synchronized` и по-безопасен в многонишкова среда.", "correct": false, "rationale": "Нито една от двете имплементации не е `synchronized` по подразбиране." },
                    { "text": "`ArrayDeque` позволява `null` елементи, докато `LinkedList` не.", "correct": false, "rationale": "Всъщност е обратното: `LinkedList` позволява `null`, докато `ArrayDeque` не." },
                    { "text": "`ArrayDeque` използва по-малко памет, защото не създава обект-възел (node) за всеки елемент.", "correct": true, "rationale": "`ArrayDeque` използва цикличен масив, което е по-ефективно по отношение на паметта, тъй като няма нужда от допълнителни обекти за референции към следващ/предишен елемент." },
                    { "text": "`ArrayDeque` има по-добра производителност за достъп по индекс (`get(index)`).", "correct": false, "rationale": "Въпреки че е базиран на масив, `ArrayDeque` не имплементира `List` и не предоставя `get(index)` метод. Той е оптимизиран за операции в двата края." }
                ]
            },
            {
                "question": "Ако имате `TreeSet` и искате да го обходите в обратен (низходящ) ред, кой е най-ефективният начин да го направите?",
                "options": [
                    { "text": "Да го копирате в `ArrayList`, да го сортирате с `Collections.reverseOrder()` и да го обходите.", "correct": false, "rationale": "Това е много неефективно, тъй като създава нови колекции и изисква пълно сортиране." },
                    { "text": "Да използвате `descendingIterator()` или `descendingSet()` (ако `TreeSet` е `NavigableSet`).", "correct": true, "rationale": "`NavigableSet` (който `TreeSet` имплементира) предоставя специални, високо ефективни методи за получаване на итератор или изглед в обратен ред." },
                    { "text": "Да го обходите и да съхраните елементите в стек, след което да изваждате от стека.", "correct": false, "rationale": "Това ще работи, но изисква допълнителна памет за стека, равна на размера на цялото множество." },
                    { "text": "Да използвате `sequencedCollection.reversed()` от Java 21.", "correct": true, "rationale": "Методът `reversed()` е чудесна модерна опция, която също връща ефективен изглед в обратен ред и е част от `SequencedSet`, който `TreeSet` имплементира." }
                ]
            },
            {
                "question": "Коя от изброените колекции НЕ позволява дублиращи се елементи?",
                "options": [
                    { "text": "`ArrayList`", "correct": false, "rationale": "`ArrayList` е списък и позволява дубликати, като ги съхранява на различни индекси." },
                    { "text": "`LinkedList`", "correct": false, "rationale": "Като имплементация на `List`, `LinkedList` също позволява дублиращи се елементи." },
                    { "text": "`TreeSet`", "correct": true, "rationale": "Всички имплементации на `Set` интерфейса, включително `TreeSet`, по дефиниция не позволяват дублиращи се елементи." },
                    { "text": "`ArrayDeque`", "correct": false, "rationale": "Въпреки че се използва като опашка, `ArrayDeque` е `Collection` и позволява дубликати." }
                ]
            },
            {
                "question": "Какъв е резултатът от извикването на `Collections.shuffle(list)`?",
                "options": [
                    { "text": "Връща ново копие на списъка с разбъркани елементи.", "correct": false, "rationale": "Методът не връща нищо (`void`) и не създава ново копие." },
                    { "text": "Модифицира оригиналния списък, като разбърква елементите му на място (in-place).", "correct": true, "rationale": "Това е \"in-place\" операция, което означава, че променя подадения обект директно, без да създава нов." },
                    { "text": "Сортира списъка в случаен ред.", "correct": false, "rationale": "Разбъркването не е вид сортиране; то цели да премахне всякаква подредба." },
                    { "text": "Хвърля изключение, ако списъкът е празен.", "correct": false, "rationale": "Методът работи коректно с празни или едно елементни списъци (не прави нищо)." }
                ]
            },
            {
                "question": "Кога бихте предпочели `Comparator` пред `Comparable`?",
                "options": [
                    { "text": "Когато искате да дефинирате основния, \"естествен\" ред за един клас.", "correct": false, "rationale": "Естественият ред се дефинира чрез имплементиране на `Comparable` вътре в самия клас." },
                    { "text": "Когато искате да сортирате обекти от клас, който не можете да промените (напр. от външна библиотека) или когато ви трябват няколко различни начина за сортиране.", "correct": true, "rationale": "`Comparator` е външен за класа и позволява дефинирането на множество различни логики за сортиране, без да се променя самият клас." },
                    { "text": "Когато работите с примитивни типове.", "correct": false, "rationale": "Примитивните типове не могат да имплементират интерфейси. Техните обвиващи класове (Integer, Double) вече имплементират `Comparable`." },
                    { "text": "Когато скоростта на сортиране е от най-голямо значение.", "correct": false, "rationale": "Няма съществена разлика в производителността между двата подхода. Изборът е въпрос на дизайн и гъвкавост." }
                ]
            },
            {
                "question": "Кой от следните статични factory методи за създаване на `HashSet` е въведен, за да се избегне ръчното изчисляване на `initialCapacity`?",
                "options": [
                    { "text": "`new HashSet(int initialCapacity, float loadFactor)`", "correct": false, "rationale": "Това е конструктор, който изисква ръчно задаване на капацитета, а не го изчислява." },
                    { "text": "`HashSet.of(E... elements)`", "correct": false, "rationale": "Този синтаксис е за `immutable` колекции като `Set.of()`, а не за създаване на `HashSet`." },
                    { "text": "`HashSet.newHashSet(int numElements)`", "correct": true, "rationale": "Този метод (от Java 19) приема очаквания брой елементи и сам изчислява оптималния първоначален капацитет, за да избегне преоразмеряване." },
                    { "text": "`new HashSet(Collection<? extends E> c)`", "correct": false, "rationale": "Този конструктор създава `HashSet` от друга колекция, но не е предназначен за създаване на празен сет с предвиден размер." }
                ]
            },
            {
                "question": "Кой метод на `SequencedMap` ще премахне и върне първия запис (двойка ключ-стойност) от мап като `LinkedHashMap`?",
                "options": [
                    { "text": "`removeFirst()`", "correct": false, "rationale": "Методите в `SequencedCollection` като `removeFirst()` са за колекции, а `SequencedMap` има собствени методи за работа със записи (entries)." },
                    { "text": "`firstEntry()`", "correct": false, "rationale": "Този метод само връща първия запис, без да го премахва." },
                    { "text": "`pollFirstEntry()`", "correct": true, "rationale": "Думата 'poll' в Java Collections често означава \"премахни и върни\", като връща `null`, ако колекцията е празна. Този метод прави точно това за първия запис." },
                    { "text": "`getFirst()`", "correct": false, "rationale": "В `SequencedMap` няма такъв метод. `getFirst()` е от `SequencedCollection`." }
                ]
            },
            {
                "question": "Ако имате списък с числа `[10, 20, 30, 40, 50]` и извикате `Collections.fill(list, 0)`, какъв ще бъде резултатът?",
                "options": [
                    { "text": "Списъкът ще стане `[0]`.", "correct": false, "rationale": "Методът `fill` не променя размера на списъка." },
                    { "text": "Списъкът ще стане `[0, 0, 0, 0, 0]`.", "correct": true, "rationale": "Този метод заменя всеки съществуващ елемент в списъка с подадената стойност, запазвайки оригиналния размер." },
                    { "text": "Ще бъде хвърлено изключение, защото списъкът не е празен.", "correct": false, "rationale": "Методът е предназначен да работи върху непразни списъци, като презаписва съдържанието им." },
                    { "text": "Списъкът ще остане непроменен, защото `fill` работи само с `Object`.", "correct": false, "rationale": "Методът работи с всякакви типове обекти, включително `Integer`." }
                ]
            },
            {
                "question": "Коя от следните операции е най-бавна за `LinkedList`?",
                "options": [
                    { "text": "Добавяне на елемент в началото (`addFirst()`).", "correct": false, "rationale": "Това е една от най-бързите операции (O(1)), тъй като изисква само промяна на няколко референции." },
                    { "text": "Премахване на елемент от края (`removeLast()`).", "correct": false, "rationale": "Подобно на добавянето в началото, това е много бърза O(1) операция." },
                    { "text": "Достъп до елемент в средата по индекс (`get(N/2)`).", "correct": true, "rationale": "Това е най-бавната операция (O(N)), тъй като изисква обхождане на половината списък от началото, за да се стигне до желания елемент." },
                    { "text": "Премахване на елемент чрез итератор (`iterator.remove()`).", "correct": false, "rationale": "След като итераторът вече е позициониран на даден елемент, премахването му е много бързо (O(1))." }
                ]
            },
            {
                "question": "Каква е основната причина `Vector` да се счита за по-бавен от `ArrayList`?",
                "options": [
                    { "text": "Използва по-сложен алгоритъм за преоразмеряване.", "correct": false, "rationale": "Алгоритмите за преоразмеряване са сходни. Основната разлика е в друга област." },
                    { "text": "Методите му са `synchronized`, което добавя режийни разходи (overhead) при всяко извикване.", "correct": true, "rationale": "Синхронизацията осигурява безопасност в многонишкова среда, но на цената на производителността, дори когато се използва само от една нишка." },
                    { "text": "Има по-голям начален капацитет по подразбиране.", "correct": false, "rationale": "Началният капацитет влияе на паметта, но не е основната причина за разликата в скоростта на операциите." },
                    { "text": "Не използва достъп до паметта с константно време.", "correct": false, "rationale": "И `Vector`, и `ArrayList` са базирани на масиви и имат O(1) достъп по индекс." }
                ]
            },
            {
                "question": "Колекцията, върната от `Map.values()`, може ли да съдържа дублиращи се елементи?",
                "options": [
                    { "text": "Не, защото идва от `Map`, където ключовете са уникални.", "correct": false, "rationale": "Уникалността се изисква само за ключовете, не и за стойностите." },
                    { "text": "Да, защото различни ключове в един `Map` могат да сочат към една и съща стойност.", "correct": true, "rationale": "Напълно е възможно `map.put(\"a\", 1)` и `map.put(\"b\", 1)`. В този случай колекцията от стойности ще съдържа `1` два пъти." },
                    { "text": "Само ако имплементацията е `HashMap`, но не и при `TreeMap`.", "correct": false, "rationale": "Това поведение е валидно за всички имплементации на `Map`." },
                    { "text": "Не, върнатият тип е `Set`, който по дефиниция не позволява дубликати.", "correct": false, "rationale": "Методът `values()` връща `Collection<V>`, а не `Set<V>`, точно защото дубликатите са възможни." }
                ]
            },
            {
                "question": "Кой е единственият безопасен начин да се премахне елемент от колекция, докато тя се обхожда с итератор?",
                "options": [
                    { "text": "Чрез извикване на `collection.remove(element)`.", "correct": false, "rationale": "Това ще доведе до `ConcurrentModificationException`, защото модифицирате колекцията директно, докато итераторът работи върху нея." },
                    { "text": "Чрез извикване на метода `remove()` на самия итератор.", "correct": true, "rationale": "Итераторът е проектиран да знае как безопасно да премахне последния върнат елемент, без да наруши състоянието на итерацията." },
                    { "text": "Чрез създаване на второ копие на колекцията и премахване от него.", "correct": false, "rationale": "Това няма да премахне елемента от оригиналната колекция, която се обхожда." },
                    { "text": "Невъзможно е да се премахват елементи по време на обхождане.", "correct": false, "rationale": "Възможно е, но само по един строго определен начин." }
                ]
            },
            {
                "question": "Каква е целта на метода `Collections.frequency(collection, object)`?",
                "options": [
                    { "text": "Да намери първия индекс на обекта в колекцията.", "correct": false, "rationale": "Това е задача за `indexOf`, който работи само върху списъци." },
                    { "text": "Да преброи и върне колко пъти даден обект се среща в колекцията.", "correct": true, "rationale": "Методът итерира през колекцията и сравнява всеки елемент с подадения обект, за да изчисли броя на срещанията." },
                    { "text": "Да провери дали обектът се съдържа в колекцията.", "correct": false, "rationale": "Това е задача за метода `contains`. `frequency` дава количествена, а не булева информация." },
                    { "text": "Да зададе честотата на разбъркване за `Collections.shuffle()`.", "correct": false, "rationale": "Двата метода не са свързани. `frequency` е метод за анализ на съдържанието." }
                ]
            },
            {
                "question": "Кой от конструкторите на `TreeSet` ще доведе до `ClassCastException`, ако се опитате да добавите обекти, които не имплементират `Comparable`?",
                "options": [
                    { "text": "`new TreeSet(Comparator<? extends E> comparator)`", "correct": false, "rationale": "Този конструктор предоставя външна логика за сравнение, така че обектите не е нужно да са `Comparable`." },
                    { "text": "`new TreeSet()`", "correct": true, "rationale": "Този конструктор разчита на естествения ред на елементите. Ако те не могат да бъдат сравнявани (не са `Comparable`), ще се хвърли изключение при опит за добавяне на втория елемент." },
                    { "text": "`new TreeSet(Collection<? extends E> c)`", "correct": true, "rationale": "Подобно на празния конструктор, и този разчита на естествения ред, освен ако подадената колекция не е `SortedSet`, от който може да се вземе `Comparator`." },
                    { "text": "`new TreeSet(SortedSet<E> s)`", "correct": false, "rationale": "Този конструктор ще използва същата логика на сортиране (естествен ред или `Comparator`) като подаденото сортирано множество." }
                ]
            },
            {
                "question": "Какво представлява обектът, върнат от `Collections.reverse(list)`?",
                "options": [
                    { "text": "Нов `List`, съдържащ елементите в обратен ред.", "correct": false, "rationale": "Методът не създава нов списък." },
                    { "text": "Методът е `void` и не връща нищо.", "correct": true, "rationale": "Това е `in-place` операция, която модифицира оригиналния списък и съответно няма нужда да връща резултат." },
                    { "text": "`Iterator`, който обхожда списъка в обратен ред.", "correct": false, "rationale": "Това би било полезно, но не е това, което методът прави. Той извършва перманентна промяна на списъка." },
                    { "text": "Непроменяем изглед (unmodifiable view) на списъка в обратен ред.", "correct": false, "rationale": "Това описва поведението на `sequencedCollection.reversed()`, но не и на `Collections.reverse()`." }
                ]
            },
            {
                "question": "Коя от следните структури данни използва вътрешно червено-черно дърво?",
                "options": [
                    { "text": "`HashSet`", "correct": false, "rationale": "Използва хеш таблица." },
                    { "text": "`PriorityQueue`", "correct": false, "rationale": "Използва хийп (пирамида), което е друг вид двоично дърво, но не е задължително червено-черно." },
                    { "text": "`TreeMap`", "correct": true, "rationale": "`TreeMap` и `TreeSet` използват самобалансиращо се двоично дърво, като червено-черното дърво е стандартната имплементация, за да гарантират O(logN) производителност." },
                    { "text": "`LinkedHashMap`", "correct": false, "rationale": "Използва хеш таблица и двойно свързан списък." }
                ]
            },
            {
                "question": "Каква е разликата между `remove(Object o)` и `remove(int index)` в `ArrayList`?",
                "options": [
                    { "text": "Няма разлика, компилаторът избира правилния метод според типа на аргумента.", "correct": false, "rationale": "Въпреки че компилаторът избира правилния метод (overloading), тяхното поведение и резултат са коренно различни." },
                    { "text": "`remove(Object o)` премахва първото срещане на елемента, докато `remove(int index)` премахва елемента на конкретна позиция.", "correct": true, "rationale": "Това е ключовата разлика: единият метод търси по стойност, а другият - по позиция. Това е важно, особено при списъци с числа, където `list.remove(2)` ще премахне елемента на индекс 2, а не числото 2." },
                    { "text": "`remove(Object o)` връща `boolean`, а `remove(int index)` е `void`.", "correct": false, "rationale": "И двата метода връщат стойност. `remove(Object o)` връща `boolean` (дали е намерен и премахнат), а `remove(int index)` връща премахнатия елемент." },
                    { "text": "`remove(Object o)` е по-бърз, защото използва хеширане.", "correct": false, "rationale": "`ArrayList` не използва хеширане. И двете операции са бавни (O(N)), защото изискват преместване на елементи." }
                ]
            },
            {
                "question": "Методът `List.subList(from, to)` връща изглед, който включва ли елемента на позиция `toIndex`?",
                "options": [
                    { "text": "Да, винаги го включва.", "correct": false, "rationale": "Повечето API-та в Java, които работят с обхвати, следват конвенцията \"включително началото, изключително края\"." },
                    { "text": "Не, обхватът е от `fromIndex` (включително) до `toIndex` (изключително).", "correct": true, "rationale": "Това е стандартната конвенция в Java. Резултатът съдържа елементите на индекси от `fromIndex` до `toIndex - 1`." },
                    { "text": "Зависи от имплементацията (`ArrayList` или `LinkedList`).", "correct": false, "rationale": "Поведението е дефинирано в `List` интерфейса и е еднакво за всички негови имплементации." },
                    { "text": "Включва го, само ако `toIndex` е последният елемент в списъка.", "correct": false, "rationale": "Правилото не зависи от позицията на крайния индекс." }
                ]
            },
            {
                "question": "Кой от изброените методи на `Collection` ще премахне от текущата колекция всички елементи, с изключение на тези, които се съдържат и в подадената колекция `c`?",
                "options": [
                    { "text": "`removeAll(c)`", "correct": false, "rationale": "Този метод прави обратното - премахва елементите, които се съдържат в `c`." },
                    { "text": "`clear()`", "correct": false, "rationale": "Този метод премахва абсолютно всички елементи, без оглед на друга колекция." },
                    { "text": "`retainAll(c)`", "correct": true, "rationale": "Този метод извършва операция \"сечение\" (intersection) - запазва (`retain`) само общите елементи." },
                    { "text": "`containsAll(c)`", "correct": false, "rationale": "Това е метод за проверка (`boolean`), който не модифицира колекцията." }
                ]
            },
            {
                "question": "Ако един клас имплементира `Iterable`, какво гарантира това?",
                "options": [
                    { "text": "Че елементите му са сортирани.", "correct": false, "rationale": "`Iterable` няма нищо общо със сортирането. `SortedSet` и `SortedMap` гарантират това." },
                    { "text": "Че може да бъде използван в `for-each` цикъл.", "correct": true, "rationale": "Това е основната цел на интерфейса. Всеки обект, който е `Iterable`, може да предостави `Iterator`, който `for-each` цикълът използва \"зад кулисите\"." },
                    { "text": "Че не съдържа дублиращи се елементи.", "correct": false, "rationale": "Това е характеристика на `Set`, а не на `Iterable`." },
                    { "text": "Че достъпът до елементите по индекс е бърз.", "correct": false, "rationale": "Много `Iterable` колекции, като `LinkedList` и `HashSet`, нямат бърз достъп по индекс." }
                ]
            },
            {
                "question": "Каква е сложността на `contains` в `HashSet` в най-лошия случай (worst-case)?",
                "options": [
                    { "text": "O(1)", "correct": false, "rationale": "Това е средната (амортизирана) сложност, но не и в най-лошия случай." },
                    { "text": "O(logN)", "correct": false, "rationale": "Тази сложност е характерна за дървовидни структури (`TreeSet`)." },
                    { "text": "O(N)", "correct": true, "rationale": "Най-лошият случай настъпва, когато всички елементи имат един и същ `hashCode` и се озовават в една и съща \"кофа\" (bucket). Тогава структурата деградира до свързан списък и търсенето става линейно." },
                    { "text": "O(N^2)", "correct": false, "rationale": "Такава сложност не е характерна за основните операции в стандартните колекции." }
                ]
            },
            {
                "question": "Защо колекциите, създадени с `List.of()`, не могат да съдържат `null` елементи?",
                "options": [
                    { "text": "Това е техническо ограничение на JVM.", "correct": false, "rationale": "Решението не е на ниво JVM, а е съзнателен избор в дизайна на API-то." },
                    { "text": "За да се насърчи по-чист и безопасен код, като се избегнат `NullPointerException` грешки по-късно.", "correct": true, "rationale": "Дизайнерите на API-то са решили, че наличието на `null` в непроменяеми колекции често е източник на грешки и са го забранили, за да направят API-то по-надеждно." },
                    { "text": "Защото `null` няма как да бъде сериализиран.", "correct": false, "rationale": "`null` може да бъде сериализиран. Причината е свързана с дизайна и безопасността на кода." },
                    { "text": "Защото `null` не може да има `hashCode`.", "correct": false, "rationale": "Въпреки че `null` няма `hashCode`, много колекции като `ArrayList` и `HashMap` го поддържат. Забраната в `List.of()` е умишлена." }
                ]
            },
            {
                "question": "Кой е най-подходящият `Comparator`, който може да се подаде на `Collections.sort`, за да се сортира списък в низходящ ред?",
                "options": [
                    { "text": "Трябва да се напише собствен `Comparator` с обърната логика.", "correct": false, "rationale": "Въпреки че това е възможно, има много по-лесен и стандартен начин." },
                    { "text": "`Comparator.naturalOrder().reversed()`", "correct": false, "rationale": "Това е модерен начин (от Java 8+), който работи отлично, но има и по-стар, класически метод в класа `Collections`." },
                    { "text": "`Collections.reverseOrder()`", "correct": true, "rationale": "Това е класическият помощен метод, който връща готов `Comparator` за сортиране в обратния на естествения ред." },
                    { "text": "Невъзможно е, трябва първо да се сортира и после да се извика `Collections.reverse()`.", "correct": false, "rationale": "Това е неефективно, тъй като изисква две обхождания на списъка. Директното сортиране в желания ред е по-добро." }
                ]
            },
            {
                "question": "Какво е предимството на метода `sequencedMap.sequencedKeySet()` пред обикновения `keySet()`?",
                "options": [
                    { "text": "По-бърз е, защото е по-нова имплементация.", "correct": false, "rationale": "Разликата не е в скоростта, а във функционалността и типа на върнатия обект." },
                    { "text": "Връща `SequencedSet`, което позволява директното използване на методи като `getFirst()`, `getLast()` и `reversed()` върху ключовете.", "correct": true, "rationale": "Това е основното подобрение - върнатият изглед е по-богат на функционалност и позволява лесна работа с първия и последния ключ, както и обръщане на реда." },
                    { "text": "Гарантира, че върнатите ключове са сортирани.", "correct": false, "rationale": "Гарантира само, че имат дефиниран ред (напр. ред на добавяне), но не задължително, че са сортирани." },
                    { "text": "Позволява премахването на ключове от множеството, докато `keySet()` не.", "correct": false, "rationale": "И двата изгледа (`keySet` и `sequencedKeySet`) поддържат премахване на елементи, което се отразява и в оригиналния мап." }
                ]
            },
            {
                "question": "Коя от следните колекции е най-подходяща за имплементиране на кеш (cache) от тип LRU (Least Recently Used), където най-старо използваният елемент се премахва, когато кешът се запълни?",
                "options": [
                    { "text": "`HashMap`", "correct": false, "rationale": "`HashMap` няма вградена представа за \"ред на достъп\" до елементите." },
                    { "text": "`TreeMap`", "correct": false, "rationale": "`TreeMap` поддържа ред по ключ, а не по време на достъп." },
                    { "text": "`LinkedHashMap`", "correct": true, "rationale": "`LinkedHashMap` има специален конструктор, който му позволява да поддържа ред по достъп (access-order) и може да бъде конфигуриран да премахва най-стария запис автоматично, което го прави идеален за LRU кеш." },
                    { "text": "`ArrayDeque`", "correct": false, "rationale": "Тази структура е добра за опашки, но не и за кеш, който изисква бързо търсене по ключ." }
                ]
            },
            {
                "question": "Кой от методите `element()` и `peek()` на интерфейса `Queue` ще хвърли изключение, ако опашката е празна?",
                "options": [
                    { "text": "`peek()`", "correct": false, "rationale": "`peek()` е проектиран да връща специална стойност (`null`) при неуспех, а не да хвърля изключение." },
                    { "text": "`element()`", "correct": true, "rationale": "Този метод е от двойката, която сигнализира за грешки чрез изключения, и ще хвърли `NoSuchElementException`." },
                    { "text": "И двата хвърлят изключение.", "correct": false, "rationale": "Интерфейсът умишлено предоставя два различни механизма за сигнализиране на грешка." },
                    { "text": "Нито един, и двата връщат `null`.", "correct": false, "rationale": "Само единият от тях връща `null`." }
                ]
            },
            {
                "question": "Коя от следните колекции е най-неподходяща за сценарий, в който постоянно трябва да се проверява за съществуването на елемент (`contains`)?",
                "options": [
                    { "text": "`HashSet`", "correct": false, "rationale": "Това е една от най-подходящите колекции, тъй като `contains` е с O(1) сложност." },
                    { "text": "`ArrayList`", "correct": true, "rationale": "Операцията `contains` в `ArrayList` е със сложност O(N), тъй като изисква линейно сканиране на всички елементи. Това я прави много неефективна за тази цел при големи списъци." },
                    { "text": "`TreeSet`", "correct": false, "rationale": "Тази колекция е много подходяща, тъй като `contains` е с O(logN) сложност, което е много бързо." },
                    { "text": "`LinkedHashSet`", "correct": false, "rationale": "Подобно на `HashSet`, тази колекция предлага O(1) сложност за `contains`." }
                ]
            },
            {
                "question": "Какво е основното предимство на колекциите пред обикновените масиви в Java?",
                "options": [
                    { "text": "Колекциите могат да съхраняват примитивни типове (`int`, `double`), докато масивите не могат.", "correct": false, "rationale": "Всъщност е обратното - масивите могат да съхраняват примитивни типове, докато колекциите изискват техните обвиващи класове (`Integer`, `Double`)." },
                    { "text": "Колекциите са по-ефективни по отношение на паметта.", "correct": false, "rationale": "Масивите са по-ефективни, защото нямат допълнителен \"overhead\". Колекциите, особено тези с възли, използват повече памет." },
                    { "text": "Колекциите имат динамичен размер и предоставят готови, оптимизирани алгоритми за работа с данни.", "correct": true, "rationale": "Това е ключовото предимство - те могат да растат и да се свиват според нуждите и идват с богат набор от готови и тествани операции, спестявайки на програмиста да ги имплементира сам." },
                    { "text": "Достъпът до елемент по индекс винаги е по-бърз в колекциите.", "correct": false, "rationale": "Достъпът по индекс в масив е O(1). В някои колекции (`ArrayList`) е също толкова бърз, но в други (`LinkedList`) е значително по-бавен." }
                ]
            }
        ];

        const quizContainer = document.getElementById('quiz-container');
        const resultContainer = document.getElementById('result-container');
        const questionEl = document.getElementById('question');
        const optionsEl = document.getElementById('options');
        const feedbackEl = document.getElementById('feedback-section');
        const rationaleEl = document.getElementById('rationale');
        const nextButton = document.getElementById('next-button');
        const restartButton = document.getElementById('restart-button');
        const scoreEl = document.getElementById('score');
        const currentQuestionNumberEl = document.getElementById('current-question-number');
        const totalQuestionsEl = document.getElementById('total-questions');

        let currentQuestionIndex = 0;
        let score = 0;

        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            resultContainer.classList.add('hidden');
            quizContainer.classList.remove('hidden');
            nextButton.classList.add('hidden');
            showQuestion();
        }

        function showQuestion() {
            resetState();
            const currentQuestion = quizData[currentQuestionIndex];
            questionEl.innerHTML = currentQuestion.question; // Use innerHTML to render code tags if any
            currentQuestionNumberEl.textContent = currentQuestionIndex + 1;
            totalQuestionsEl.textContent = quizData.length;

            currentQuestion.options.forEach(option => {
                const button = document.createElement('button');
                button.innerHTML = option.text;
                button.classList.add('w-full', 'p-4', 'border-2', 'rounded-lg', 'text-left', 'transition-colors', 'duration-200', 'dark:border-slate-600', 'hover:bg-sky-100', 'dark:hover:bg-slate-700');
                button.addEventListener('click', () => selectAnswer(button, option));
                optionsEl.appendChild(button);
            });
        }

        function resetState() {
            nextButton.classList.add('hidden');
            feedbackEl.classList.add('hidden');
            while (optionsEl.firstChild) {
                optionsEl.removeChild(optionsEl.firstChild);
            }
        }

        function selectAnswer(selectedButton, selectedOption) {
            if (selectedOption.correct) {
                score++;
            }
            
            Array.from(optionsEl.children).forEach((button, index) => {
                const option = quizData[currentQuestionIndex].options[index];
                if (option.correct) {
                    button.classList.add('correct-answer');
                } else if (button === selectedButton) {
                    button.classList.add('incorrect-answer');
                }
                button.disabled = true;
            });
            
            rationaleEl.textContent = selectedOption.rationale;
            feedbackEl.classList.remove('hidden');
            
            if (quizData.length > currentQuestionIndex + 1) {
                nextButton.classList.remove('hidden');
            } else {
                showResults();
            }
        }
        
        function showResults() {
            quizContainer.classList.add('hidden');
            resultContainer.classList.remove('hidden');
            scoreEl.textContent = `${score}/${quizData.length}`;
        }

        nextButton.addEventListener('click', () => {
            currentQuestionIndex++;
            showQuestion();
        });

        restartButton.addEventListener('click', startQuiz);

        // Initial start
        startQuiz();
    </script>
</body>
</html>
