Важни неща, които да се запомнят:
- Структурите от данни са начин за организиране, управление и съхранение на данни в компютъра, като основните операции са добавяне, триене, търсене, обхождане

- Масивите са лесни за ползване, заемат толкова място колкото е посочено при декларирането им и предлагат O(1) достъп на данни
- Масивите имат фиксиран размер, който не може да се промени, триенето/добавянето са бавни операции, защото трябва да се промени реда на всичките елементи, търсенето е бавно със сложност O(N)

- Java предоставя Collection API, които съдържа колекции, които автоматично се разширяват/свиват и могат да добавят/изтриват елементите, а тези интерфейсите се намират в java.util и предоставят имплементации на структури от данни

- Итератора е обект, който служи за универсален начин за итериране през елементите на колекция без значение каква е структурата, основните методи са hasNext() и next()
# Когато в Java се използва for each цикъл, в backgrounda се използва итератор за итериране

- Iterable<T> е интерфейс, който е имплементиран от всяка колекция и казва, че тази колекция може да се итерира, като единственият метод е Iterator<T> iterator(), който връща итератор използван за обхождането на колекцията
# Iterator<T> e interface
- Iterator<T> има методите: boolean hasNext() проверява дали има следващ елемент, E next() връща следващия елемент, void remove() премахва от колекцията последния елемент върнат от next()
- remove() позволява единствения безопасен начин за премахване на елемент от колеция, докато е итерирана с итератор, в противен случай ще се хвърли ConcurrentModificationException
# Това важи и за добавяне на елементи, но реализации на Iterator интерфейса (примерно ListIterator) предоставят възможност безопасно да се добави елемнт към колекция 

- Collection е базовият интерфейс, който наследява Iterable, на всички колекции, като той е наследен от List, Set и Queue, други интерфейси, който имат имплементации за структури данни
- При map колекциите няма Colection interface, йерархията започва с Map интерфейс 

- Map не наследява Iterable и има три основни начина, по който може да се обходи:
1) keySet() връща Set съдържащ всички ключове, съдържащи се в Map-a 
2) values() връща Collection, който съдържа всички стойности за ключовете в Map-a
3) entitySet() връща колекция от двойки ключ-стойност и са обвити в обект Map.Entry 

- Методи в интерфейса Collection<T>:
1) int size() връща големината на колекцията
2) boolean isEmpty() връща дали е празна колекцията 
3) boolean contains(Object element) връща дали element се намира в колекцията 
4) boolean add(E element) добавя element към колекцията и връща true, ако е успешно 
5) boolean remove(Object element) премахва първото срещане на element от колекцията и връща true ако е успешно
6) void clear() премахва всички елементи от колекцията
7) Методи от сорта на containsAll, addAll, removeAll, retainAll за работа с други подадени колекции
8) Iterator<E> iterator() за да върне Iterator обект, както и toArray, който връща масив с елменети от колекцията  

- Видове интерфейси, който наследяват Collection:
1) List представлява последователна колекция от елементи, като позволява дублиращи елементи и се достъпват чрез посочен индекс
2) Set не позволява дублиращи се елементи 
3) Queue позволява работа във FIFO, LIFO принципите 

- Основни методи в java.util.List:
1) E get(int index) връща елемента на посочената позиция 
2) E remove(int index) премахва елемента на посочения индекс
3) List<E> sublist(int fromIndex, int toIndex) връща sublist от началния индекс до крайния, а в него ще се отразят на главния
4) int indexOf(Object a) връща индекса на срещаният елемент а

- Имплементации на java.util.List:
1) ArrayList представлява динамичен масив, който се разширява автоматично
2) LInkedList представлява двойно свързан списък, където всеки елемент пази референция към следващищ или предишния
3) Stack: структура от данни, покриваща LIFO принципа 

- Разлики в скоростта на операциите при LinkedList и ArrayList:
1) O(1) операциите в ArrayList са get(index) и add(), обаче в края, докато O(n) операциите са remove() и add() в нчалото, както и contains
2) О(1) операциите в LinkedList са добавяне/премахване в началото/край, докато О(n) са операциите за достъп до произволен индекс, както и contains 

Основни методи в java.util.Queue:
1) add() хвърля IllegalStateException, ако опашката е с фиксиран капацитет и е пълна 
2) offer() връща false ако опашката е пълна 
3) remove() хвърля NoSuchElementException, ако опашката е празна 
4) pool() връща false, ако пашката е празна 
5) element() хвърля NoSuchElementException, ако опашката е празна 
6) peek() връща null, ако опашката е празна 
