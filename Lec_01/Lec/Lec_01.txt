Какво е Java?

	Език за програмиране: Java е обектно-ориентиран език за програмиране, създаден от Oracle, той е полулярен за уеб, мобилни и корпоративни приложения
	
	Java компилатор: Това е програма, която превежда Java кода (файлове с разрешение .java) в байткод (файлове с разширение .class), който може да се изпълнява от Java виртуалната машина (JVM)
	
	Java виртуална машина (JVM): Това е софтуерен слой, който позволява изпълнението на Java програми независимо от операционната система, като интерпретира байткода.
	
	Java Development Kit (JDK): Това е пакет от инструменти, който включва компилатора, библиотеките и средата за изпълнение на Java. Използва се за разработка на Java приложения 
	
	Java Runtime Environment (JRE): Това е част от JDK, която съдържа JVM и необходимите библиотеки за изпълнение на Java програми, но без компилатор
	
	Java платформа - Java платформите представляват среда, която включва JVM, API и библиотеки, необходими за създаване и изпълнение на Java приложения.
	
Езикът Java

	Езикът Java придоставя следните възможности:
	- Модерен: Поддържа се и се развива активно, като на всеки 6 месеца излиза нова версия с нови функционалности 
	
	- С общо предназначение: Не е създаден за една тясна област, може да се разработват много приложения с този език
	Например: уеб приложения, мобилни приложения, настолни приложения, големи корпоративни системи, embeded системи
	
	- Със C/C++ синтакси: Синтансиса на Java е силно повлиян от езиците C+
	- Статично типизиран (Statically typed): Типът на всяка променлива се задава от програмистта и се проверява по време на компилация
	
	
	- Мултипарадигмен: поддържа обектноориентирания стил за програмиране (всичко е обекти с данни и поведение), но има функционални елементи (lambda изрази и stream api)
	- Има Garbage collector: Автоматична система за управление на паметта, която намира и освобождава обекти в heap паметта, които вече не се използват.
	
	- Java програмите могат да бъдат написани веднъж и да се изпълняват на всяка платформа, без да се налага променя в кода.
	Това се случва заради JVM, когато Java код се компилира, той се превръща в байткод, който JVM може да изпълнява на всяка операционна система, стига да има съвместима JVM
	
* HelloWorld.java
	
	Виж HelloWorld.java
	
	public stratic void main(String[] args) е главния метод и е специален, защото е входната точка на java програмата
	Когато стартираш едно приложение JVM търси точно този метод и започава да изпълнява кода, който е в него
	
	Има и друг начин да се напише HellowWorld.java като се напише само void main()
	Java в този случай автоматично създава клас като той е Unnamed Class. Ключовите думи public, static, String[] args не са задължителни 
	Случват се автоматични импорти, за някой популярни функции от java библиотеките 
	
* Как работи едно Java приложение 

	Стъпките през който минава програма която се изпълнява и компилира:
	- Един програмист пише Java код и той има разширение .java 
	- Java компилатора превръща този .java файл в универсален bytecode файл с разширение .class 
	- Този .class файл се поадава на JVM-а 
	- JVM-a превежда байткода на език, който конкретната машина разбира и изпълнява програмата 
	
* Java виртуална машина (JVM)

	Какво прави JVM:
	- Интерпретира и изпълнява byte код инструкции: JVM чете универсалния Java bytecode и ги превежда стъпка по стъпка, за да ги изпълни 
	- Компилира по време на изпълнението byte кода до машинен код: JVM анализира кода, докато работи и превръща често използваните части директно в машинен код.
	Този процес също се нарича и JIT (Just in Time) компилация 
	
	- Заделя памет за оперативни данни: Когато се създават променливи и обекти, JVM е отговорна за намирането и заделянето на необходимото място за тях в RAM паметта 
	- Автоматично изчиства паметта: JVM автоматично открива и изтрива обекти от паметта, които вече не се използват. Този процес се нарича като Garbage Collection
	
	- Зарежда класове: Преди код от даден клас да бъде изпълнене JVM първо намира .class файла и да го зареди в паметта 
	- Стартира нишки: JVM може да създава и да кординира нишки 
	- Взаимойдества с операционната система: JVM служи като мост между Java кода и операционната система за комуникация и достъп до файлове и други ресурси 
	
* Типове данни 	

	Един тип данни в Java не само определя какви стойности може да запазва, но и какви операции може да се извършва с тези стойности 
	
	Java е статично типизиран език, това означава:
	- декларираш преди да използваш, с други думи казваш на програмата ще има променлива от еди какъв си тип с еди каква си стойност
	- типът е постоянен и не може да бъде променян 

	Създаването на една променлива има две стъпки: декларация (даваш тип и име) и инициализация (даваш стойност). Тези две стъпки могат дори на един ред да станат или не
	
	int a, b; // declaration statement
	int b = 99 // assigment statement 
	int c = b * 2; // combined declaration and assignment statement 
		
* Референтни и Примитивни типиве 

	Типовете данни в Java се делят на два вида:
	- Примитивните типове (Това са вече вградените в езика): Тези типове директно съдържат в себе си самата стойност
	За пример тук имаме Булев тип (boolean) както и Числените типове (integral, floating-point)
	
	- Референтни типове: Те не съдържат самата данна директно, вемсто това съдържат референция към мястото в паметта, където е записан обектът
	Всичко в Java, което не е примитивен тип е референтен, за пример: Стринговете, Масивите, Класове 
	
* Примитивни типове 

	Примитивните типове са:
	- byte
	- char
	- short 
	- int 
	- long
	- float 
	- double
	- void 
	
	В Java може да видиш като статични променливи и самите минимални и максимални стойности на примитивните типове:
	- Byte.MIN_VALUE / MAX_VALUE 
	- Short.MIN_VALUE / MAX_VALUE 
	- Integer.MIN_VALUE / MAX_VALUE 
	- Long.MIN_VALUE / MAX_VALUE
	-  Character.MIN_VALUE / MAX_VALUE 
	
	Следните примитивни типове заемат толкова място в паметта:
	- byte: 1 байт (-128...127)
	- short: 2 байта (-32,768...32767)
	- char: 2 байта (0...65535)
	- int: 4 байта (-2million...+2milion това е приблизително)
	- float: 4 байта
	- long: 8 байта
	- double: 8 байта
	- boolean: 1 байт (true or false)
	
	Може да записваме с други бройна система:
	- int decVal = 26;
	- int hexVal = 0x1a;
	- int binVal = 0b11010;
	- int octVal = 032;
	
	Като допълнение дългите литерали могат и да се пишат така, за да се разбират: int million = 1_000_000;
	
	Запомни, че компилатора не присвоява default стойности на декларираните локални променливи!
	
* Конвертиране на типове 

	Има два начина, по които Java може да преобразува типовете:
	- Имплицитно (Implicit): Това е автоматичното конвертиране, което Java извършва когато преобразуването е безопасно, тоест няма загуба от данни или точност 
	- Експилицтно (Explicit): Това е ръчното конвертиране, използва се, когато има рис от загуба на данни. Това става чрез операцията cast 
	
	Примери при образувания:
	- "1234" + 99 ---> "123499"
	- (int) 2.71 ----> 2 което е int 
	- 11 * 0.3 ---> 3.3 
	- (int) 11 * 0.3 ---> 3.3 
	- 11 * (int) 0.3 ----> 0 
	
* Wrapper типовете 

	Wrapper типовете са специални класове в Java, които обвиват примитивните стойности в обекти. 
	Всеки един примитивен тип си има съответстващ клас 
	
	Може да ги използваме в следните ситуации:
	- Когато синтаксиса извиксва обект: Напълно възможно е да има интерфейс, който да приема обект вместо примитивна стойност 
	- Когато ни трябват помощни функции и константи, понеже в тези wrappers има доста полезни вградени методи и стойности
	
	Полезни фунцкии, които може да използваме за тези обивки:
	- Integer.valueOf(25); // връща Integer инстанция
	- Integer.intValue();  // връща стойността пакетирана вътре
	- Integer.parseInt(String); // превръща String-a в int стойност 

* Autoboxing 
	
	Сега ще разгледаме разликата между примитивен тип char и неговия wrapper клас Character, както и процесите autoboxing и unboxing 
	
	char c = 'a'; това е стандартноот създаване на примитивна променлива 
	
	Character c = new Character('a'); това е експлицитния начин за създаване на wrapper обект 
	
	Character c = 'a'; това е пример за Autoboxing, тук 'a' директно се присвоява към обекта от тип Character 
	
	char c2 = c; този процес се нарича unboxing, Java автоматично взима стойността от обекта Character и го присвоява в примитивния тип
	
* Низове 

	Низовете имат следните характеристики:
	- Низивоете са референтен тип, не примитивен: Една променлива от тип String не съдържа самият текст в себе си, а съдържа референция към мястото в паметта,
	където се намира обектът с текста 
	
	- Инстанция са на String класа: Низовете са обекти от класа String, те идват и с допълнителни функционалности 
	
	- Immutable са: Това означава че веднъж създаден, един String никога не може да бъде променен 
	Когато искаме да пороменим един низ, Java създава изцяло нов String обект в паметта с резултата от промяната и обекта сочи към него 

* Разлики между низовете в heap-a или в string pool-a 

	String pool-a е специална оптимизирана област в паметта на Java (JVM), която действа като кеш за низови литерали. 
	Когато създадем нов literal string, JVM проверява в String pool-a дали вече съществува низ със същото съдържание:
	- Ако не съществуа, тя създава String обект в pool-a и променливата, получава reference към нея 
	- Ако вече съществува, Java не създава нов обект. тя просто дава на променливата референция към вече съществуващия обект 
	
	Heap-a е основната димамична памет в Java, където се съхраняват всички обекти създадени с оператора new
	Когато създаваме String обект с new оператора ние заобикаляме String pool-a и създаваме String обект директно в heap-a
	Това се случва всеки път дори ако низ със същото съдържание същестува в heap-a или в string pool-a 
	
* Операции със низове 

	Ако два низа се сравняват с == оператора, то тогава се сравнява тяхната референция 
	Ако искаме да сравним съдържанието на низовете, трябва да използваме метода equals() на String класа 
	
	Можем да конкатенираме стрингове с +: String str = "The current year is " + 2024;
	
	Можем да правим низове на много редове като използваме """ кавички
	String = """ this is a 
		string 
	""";
	
	String s = "Firebird";
	char ic = s.charAt(i); // взима символа на i тия елемент 
	char[] ca = s.toCharArray(); // превръща стринг-а в масив от символи 
	
	Това са два различни начина за обхождане на String: 
	- for (int i = 0; i < ca.size(); i++) {...}
	- for(char c : ca) {...}
	
	Възможно е да разбиеш даден String на по-малки String, които се съдържат в array:
	Stromg str1 = "This is a string sentance";
	String[] tokens = str1.split(" "); // знака подаден в скобите е разделителя 
	
* Mutable низове (StringBuilder)

	Когато искаме промяна на String да не води до създаването на нов обект в паметта, тогава вместо String може да използваме StringBuilder или StringBUffer

* Local variable type inference 

	Използваме var за да декларираме локални променливи. Java вижда какъв е изразът отдясно при декларацията и сам определя какъв е типът на тази променлива 
	
	Има няколко особености:
	- var message = "Message"; това ще се компилира защото Java вижда, че типът на тази променлива ще е String 
	- message = 1; това няма да се компилира, защото типът даден на тази променлива е различен от декларацията 
	- var mystery; това няма да се декларира, защото трябва компилатора да укаже типът на променливата 
	
* Control Flow елементи 

	Така се прави if case оператора
	if(booleanExpression) {
	}
	else if(booleanExpression) {
	}
	else {
	}
	
	Така се прави ? оператора 
	condition ? statement1 : statement2
	
	Така се прави while цикъл:
	while(booleanExpression){}
	
	Таака се прави do-while 
	do{
	}while(booleanExpression)
	
	Така се прави итерацията - for 
	for(initialization; booleanExpression; step){}
	
* Switch statement 

	Ето така изглежда нормален switch оператор в Java:
	switch(statement) {
		case value1: statement; break;
		case value2: statement; break;
		...
		default: statement;
	}
	
	
	След Java 15 може и switch оператора да изглежда таак:
	switch(ch) {
		case 'a' -> statement;
		case 'b' -> statement;
		....
		default  -> statement;
		
	От Java 21 насам може да използваме Pattern matching функционалността
	String s = switch(obj) {
		case Integer i when i > 100 -> "It is a number above 100"
		case Integer i -> "It is a integer"
		....
		default -> "It is none of the know data types"
	Тази функционалност ни да правим различни неща, когато ни са подадени различни видове типове 
	
* Масиви 

	Начини за деклариране на масив:
	- int[] а; // това е предпочитания вариант за декларариане
	- int a[]; // също валиден
	- int[] a = {1,2,3,4,5}; // експилицитно присвояваен 
	- int[] b = new int[7] // създава 7 int елемента в heap паметта, всички елементи на масива с default value 
	
	Две важни неща за запомняне:
	- Декларация: не се заделя памет за елементите 
	- инициализация: заделя се памет за елементите 
	- Елементите на масиви от примитивни типове имат default стойности, когато се инициализират 
	
	Инициализиране на многомерни масиви:
	int[][] a = new int[3][4];
	int[][]b = [[1,2,3], [4,5,6], [7,8,9]] // тук компилатора автоматично определя размерите на масива, не е нужно да казваш колко е голям
	
	Отделяне на динамична памет за двумерен масив:
	double[][] matrix = new double[7][];
	for(int i = 0; i < 7; i++){
		matrix[i] = new double[i + 1] // за всеки елемент (тоест масив) от двумерния масив се отделя размер за него 
	}
	
* Важни операции с масиви 

	System.arraycopy(src, srcPos, dest, destPos, length) // Копиране на масив 
	Arrays.equals(arr1, arr2); // Проверява масивите за еднаквност
	Arrays.fill(arr, value); // Запълва масива с value 
	Arrays.toString(arr); // Конвертира масива в низ 
	
	
============================================================================================================================


	Въпрос 1: Какво е основното предназначение на Java виртуалната машина (JVM)?
	Въпрос 2: Каква е разликата между JDK и JRE?
	Въпрос 3: Кое твърдения за Java НЕ е вярно?
	Въпрос 4: Какво представлява JIT (Just-In-Time) компилацията в контекста на JVM?
	Въпрос 5: Кое от изброените е примитивен тип данни в Java? char или String или Integer или Array
	Въпрос 6: Каква ще бъде стойността на променливата 'result' след изпълнение на следния код: int result = (int) 11 * 0.3;
	Въпрос 7: Какво е autoboxing в Java?
	Въпрос 8: Защо String са immutable в Java
	Въпрос 9: Каква е разликата между създаването на String с литерал (String s1 = "test") и с оператора new (String s2 = new String("test"))?
	Въпрос 10: Защо следния код няма да се компилира var message = "Hello"; message = 123;
	Въпрос 11: Какъв ще бъде резултатът от изпълнението на `System.out.println("123" + 99);`
	Въпрос 12: Кой е предпочитаният начин за деклариране на масив в Java?
	Въпрос 13: Какво се случва, когато инициализирате масив от примитивни типове, например `int[] arr = new int[5];`
	Въпрос 14: Кой метод трябва да се използва за сравнение на съдържанието на два низа s1 и s2?
	Въпрос 15: Кога бихте използвали `StringBuilder` вместо `String`?
	Въпрос 16: Какво прави `break` операторът в `switch` конструкция?
	Въпрос 17: Какъв е размерът в байтове на примитивния тип `long` в Java?
	Въпрос 18: Кой метод превръща низ в масив от символи? 
	Въпрос 19: Какъв е резултататът от (int) 2.71
	Въпрос 20: След Java 21 как може да се пише java метода?
	Въпрос 21: Какъв литерал се използва за запис на число в шестнадесетична бройна система?
	Въпрос 22: Кой метод от wrapper класа `Integer` се използва за преобразуване на `String` в `int`
	Въпрос 23: Каква е целна на default случая в switch оператора?
	Въпрос 24: Как се декларира и инициализира двумерен масив (матрица) с размери 3x4?
	Въпрос 25: Кой метод от класа `Arrays` се използва за проверка дали два масива имат еднакво съдържание?
	Въпрос 26: Какво означава, че Java е език с общо предназначение? 
	Въпрос 27: Какво прави Garbage Colelctor-ът?
	Въпрос 28: Какво е unboxing? 
	Въпрос 29: Защо кодът `var mystery;` няма да се компилира?
	Въпрос 30:
	
	Отговор 1: Да предоставя среда за изпълнение на Java програми, независимо от операционната система, защото JVM интерпретира байткода и го превежда на езика на конкретната машина,
	което позволява платформена независимост 
	
	Отговор 2: JDK включва JRE, компилатор и инструменти за разработка, докато JRE съдържа само JVM и библиотеки за изпълнение, защото JDK е само за изпълнение на програми, а JRE е само за разработка.
	
	Отговор 3: Java програмите не се компилират директно до машинен код, защото първо се компилира до байткод, който след това се интерпретира от JVM
	
	Отговор 4: Процес, при който JVM анализира байткода по време на изпълнение и компилира често използваните части директно в машинен код, това е оптимизация, която ускорява изпълнението на Java програмите 
	
	Отговор 5: char е примитивен тип за съхранение на данни 
	
	Отговор 6: Грешка при компилация, резултата 11 * 0.3 ще е double, който не може да бъде присвоен на int, без експлицитно преобразуване 
	
	Oтговор 7: Автоматичното преобразуване на примитивна стойносто в съответния и wrapper клас, компилатора автоматично опакова примитивната стойност в обект, когато е необходимо
	
	Отговор 8: Защото всяка промяна на низ създава нов обект в паметта и оригиналния низ остава непроменен, това осигурява предвидимост и сигурност
	
	Отговор 9: С литерал низът се създава в StringPool-a (ако не съществува там), докато с new винаги се създава нов обект в heap-a 
	
	Отговор 10: Типът на променливата определен при декларация (String) не може да бъде променян впоследствие, Java е статично типизиран език 
	
	Отговор 11: "12399", когато един от операндите е String, оператора '+' преобразува другия операнд в String и ги съединява 
	
	Отговор 12: int[] a;
	
	Отговор 13: Всички елементи на масива се инициализират със стойността по подразбиране на техния тип (0 за int)
	
	Отговор 14: s1.equals(s2), защото equals() е предназначен за сравнение на съдържанието на обекти 
	
	Отговор 15: Когато трябва да се извършват множество промени по един низ, защото StringBuilder е mutable и е много по-ефективен при модификации, защото не се създават нови обекти 
	
	Отговор 16: Излиза от switch блока и продължава изпълнението на кода след него, това предотвратява пропадането към другите cases 
	
	Отговор 17: long и double заемат по 8 байта в паметта 
	
	Отговор 18: .toCharArray 
	
	Отговор 19: 2, когато cast-ваме към 'int' се премахва всичко след десетичната запетая 
	
	Отговор 20: От JDK 21 насам, за прости програми, може да се използва опростен `main` метод.
	
	Отговор 21: 0x
	
	Отговор 22: Integer.parseInt(), това е статичен метод, който анализира низ и връща примитивен 'int'
	
	Отговор 23:	Да изпълни блок код, ако никой от case етикетите не съвпада със стойността на израза 
	
	Отговор 24: int[][] a = new int[3][4];
	
	Отговор 25: Arrays.equals() този метод сравнява елемент по елемент съдържанието на двата масива 
	
	Отговор 26: Че може да се използва за разработка на различни видове приложения - уеб, мобилни, настолни, корпоративни 
	
	Отговор 27: Автоматично намира и освобождава обекти в heap паметта, които вече не се използват, това е ключова характеристика за автоматичното управление на паметта в Java 
	
	Отговор 28: Процесът на автоматично преобразуване на wrapper клас в съответния му примитивен тип
	
	Отговор 29: Защото компилатора не може да определи типа на променливата без инициализация, при използване на var, променливата трябва да бъде декларирана и инициализирана
	на един и същи ред, за да може компилатора да изведе нейния тип.
	
	Отговор 30:
	