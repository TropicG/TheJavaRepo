* Какво означава concurent

    Превода на concurrent е едновременен или случващ се по едно и също време

    Когато две или повече събития, действия или процеси са concurrent, те протичат в един и същи период от време, като се застъпват

    # Concurrent изпълнение описва способността на системата да управлява множество задачи, които напредват едновременно

* Concurrency 

    Concurrency е способността да се прави повече от едно нещо в един и същи момемнт
    # Тоест множество задачи започват, изпълняват се и приключват, в припокриващи се времеви периоди, в непредсказуем ред
    # Това означава, че няколко задачи изглеждат сякаш се случват по едно и също време, като системата првключва между тях

    За пример, могат да се редактират документи, докато се слуша музика от други приложение и да се сваля файл от Интернето от трето, едновременно

    Concurrency не предполага непременно няколко приложение, едновременно изпълнение на части от едно приложение също се нарича concurrency 
    # За пример, един тесктов редактор форматира текста, докато прави и spell-checking и respond-ва на keyboard events едновременно 

    # Накратко, concurrency е управлението на няколко задачи, които се изпълняват в припокриващи се периоди, независимо дали са в различни програми или в рамките на една и съща програма

* Разликите между concurrent и paralel 

    Concurrency означава, че задачите се управляват по едно и също време, но не е задължително да се изпълняват в един и същи миг.
    Това може да се случи на един процес, който бързо превключва между тях, именно това създава илюзията за едновременност

    Parallelism означава, че задачите се изпълняват буквално в един и същи момент. Това изисква хардуер с няколко ядра или процесора

    Multiprocessing (много процеси) е истински паралелизъм
    Multitasking (на един процесор) e concurrency, но не е паралелизъм 

* Units of multithreading 

    Concurrency е много общ термин и може дас е използва на различни нива

    Има три конкретни нива или единици:
    - Multiprocessing (Многопроцесорност): много процеси изпълняващи инструкции concurrently (едновременно), единицата е процесор
    # Това означава, че имаме няколко физически процесора, които работят паралелно, които работят паралелно

    - Multitasking (Многозадачност): много задачи/процеси, изпълняващи едновременно на един процесор, единицата е процес
    # Тук един процесор бързо превключва между различни задачи, създавайки илюзията, че те работят едновременно 

    - Мultithreading (Многонишковост): множество части на една и съща програма се изпълняват concurrently, единицата е нишка
    # Това е concurrency в рамките на едно-единствено приложение, където различни нишки (по-малки части от процеса) се изпълняват едновременно 

* Процеси и нишки 

    Процес е програма по време на изпълнение като си има собствено адресно пространство, call stack И handles към ресурси (например отворени файлове)
    # Накратко процесът е работещото приложение (примерно web browser или текстов редактор), което има собствена, изолирана памет и ресурси

    Нишка е път на изпълнение вътре в процес 
    Има няколко важни уточнения за нишките:
    - всеки процес има поне една нишка, наричана main 
    - всяка нишка може да създава допълнителни нишки
    - нишките в един процес споделят ресурсите му, в частност, памет или отворени файлове. Всяка нишка обаче си има собствен call stack

    # За разлика от процесите (те са изолирани), нишките в рамките на един процес работят в споделена памет, което им позволява да си сътрудничат по-лесно.
    # Всяка нишка следи собствения си път на изпълнение (чрез нейния call stack)

* Сравнение между процеси и нишки 

    Сравнения:
    - Стартиране: Процесите стартират бавно, докато нишки стартират бързо
    # Стартирането на един процес изисква заделяне на нова, изолирана памет и ресурси от операционната система, докато нишката се стартира в рамките на вече съществуващ процес
    - Изолация: Процесите имат изолациям докато нишките не
    # Процесите са изолирани един от друг, докато нишките в един процес споделят една и съща памет 
    - Комуникация: Комуникацията между процеси е бавна, докато при нишките е бърза
    # Поради липсата на изолация, нишките могат да комуникират бързо, като четат и пишат в общата си памет.
    # Процесите използват по-бавни и по-сложни начини за комуникация, осигурени от ОС понеже паметта е изолирана

* Concurrent vs паралелно изпълнение 

    Concurrency не предполага непременно паралелно изпълнение 
    # Основното е че concurrency и паралелното изпълнение не са ендо и също нещо

    Когато се спомене за "множество задачи, изпълняващи се едновременно" трябва да се има предвид "множество задачи, прогресиращи през един и същи времеви интервал"
    ОС превключва между задачите толкова често, че за потребителя изглежда, че те се изпълняват едновременно, в един и същи момент 
    # Управлението на множество задачи всъщност се случва като задачите напредват в един и същи период от време, но не задължително в един и същ физически момент
    # Това се постига много бързо чрез превключване между задачите, като изглежда, че те работят едновременно.

    Всъщност паралелното изпълнение е невъзможно на компютър с единствен (single-core) процесор
    # Паралелно изпълнение е когато две или повече задчи работят в абсолютно един и същи физикчески момент
    # За да е възможно това, е нужен хардуер, който да го позволява - примерно процесор с няколко ядра. Всяко ядро да може да управлява различна задачада по едно и също време 

    Накратко:
    - Concurrency е справянето с много неща наведнъж (чрез редуване)
    - Паралелизъм е правенето на много неща наведнъж (буквално по едно и също време)
    
* Как работят еднонишковите и многонишковите програми 

    В една еднонишкова програма задачите се изпълняват една по една:
    - Първо трява да се приключи едната операция
    - След това се изпълнява другата
    # Като аналогия може да се погледне касиер и магазин, всички клиенти минават през него един по един и следващия не може да започне, докато предният не е приключил

    В многонишкова програма задачите могат да се изпълняват едновременно:
    - Програмата може да работ по няколко задачи наведнъж
    # Това е като магазин с много кас, няколко кличента могат да бъдат обслужени по едно и също време, което прави процеса по-бърз

    # Наратко, еднонишковата програма прави само едно нещо в даден момент, докато многонишковата програма може да се справя с няколко неща едновременно, като разпределя работата в различни нишки

* Ползи от многонишковостта

    Съществено увеличена производителност на програмите, чрез пълноценна употреба (utilization) на наличните ресурси, като CPU
    # Вместо програмата да използва само едно ядро на процесора, докато другите си почиват, многонишковстта позволява да се разпредели работата върху всички налични ядра
    
    Подобрено потребителско изживяване (more responsive UIs)
    # Ако една програма е еднонишкова, когато тя започне тежка операция целият и интерфейс би замръзнал, докато се обработи
    # При многонишковото програмиране, тежката работа се изнася в background нишка, докато главната нишка (която би отговорила за интерфейса) остава свободна. Това е начин да накараме интерфейса да остане responsive

    По-проста архитектрура
    # Има някой случай, в който многонишковстта опростява логиката 

    Сложен, асинхронен workflow може да се декомпозира до няколко прости, последователни workflows, изпълнявани в отделни нишки
    # Вместо една сложно програма, която управлява няколко задачи едновременно, може да се декомпозира проблема като се създадат отделни нишки, като всяка от тях изпълнява една проста ясна задача

* Проблеми свързани с concurrency

    Thread interference e това, което се случва, а Race Condition е ситуацията, която го позволява

    Когато множество нишки едновременно четат и пишат споделени данни и тези операции се припокриват във времето, тогава резултатът зависи от реда на четенията и писанията, който е непредвидим
    # Проблема идва когато поне една нишка се опитва да промени данните, докато други четат или също пишат 
    # Тогава програмата става ненадеждна, понякога може да работи правилно, а друг път ще даде напълно грешене резултат 

    Memory inconsistency е когато различни нишки "виждат" по различен начин едни и същи данни в един и същи момент
    Този проблем се случва, когато една нишка промени стойността на някаква споделена данна, но тази промяна не е "стигнала" до другите нишки, които продължават да виждат старата стойност
    Причината това да се случи е, че компилаторът, JVM-ът и CPU-то правят оптимизации (размества инструкции, кешират стойностти от RAM паметта в регистри или кеш на CPU-тата)
    # Накратко заради тези оптимизации, различните нишки може да работят с локални, кеширани копия на данните и промените, направени от една нишка, да не са видими веднага за останалите 

* Проблеми с multithreading-a

    Това е мощен метод, за ускоряване на програми, като се изпълняват няколко задачи едновременно, но той въвежда специфични трудности
    Проблемите свързани с multithreading-а са:
    - Кодът става по-сложен и неинтуитивен
    # Вместо кода да се изпълнява ред по ред ще има няколко нишки, които работят едновременно. Трябва да се мисли как те комуникират помежду си, коя кога се изпълнява и как да се синхронизират

    - Ползват се повече ОС ресурси за многото нишки, например памет
    # ОС трябва да отдели за всяка нишка ресурси, като собствен стак (мястото кудето се съхраняват временни данни), както и че процесора трябва да превключва между различните нишки
    # Ако примерно се направят прекалено много нишки, системата може да отдели повече време на превключването отколкото на истинската работа

    - Нов източник на трудни за репродуциране и дебъгване грешки, появяват се грешки, които съществуват само в многонишковото програмиране
    # Race Condition е когато две или повече нишки се опитват да променят едни и същи данни по едно и също време, така крайния резултат на операцията завбиси от непредсказуемия ред, в който ОС изпълнява инструкциите на различните нишки
    # Memory Inconsistency, поради кеширането на процесор, една нишка може да направи промяна, която друга нишка не вижда веднага

    - Liveness, Starvation и Performance рискове
    # Liveness е проблема, когато програмата не напредва, но уж работи (deadlock проблема)
    # Starvation е проблема, когато една нишка никога не получава шанс да се изпълни, защото други нишки простоянно и вземат ресурсите
    # Добавянето на повече нишки не винаги прави програмата по-бръза, понякога може да се забави заради разходите по управлението им

    - Многонишкови фраймуърци като "черна кутия"
    # Често се използват библиотеки и framewokrs, те улесняват работата, но често скриват вътрешената логика, ако примерно възникне проблем вътре в framework-a може да е почти невъзможно да се каже какъв е проблема 

* Видове нишки в Java 

    (Platform threads)
    Те са wrapper на kernel Нишките, менежирани от ОС, това означава, че за всяка Platform thread, която е създадена в Java код, ОС създава и управлява една своя истинска нишка, има пълното съответствие 1 платформена : 1 OS нишки
    Изискват много памет (около 2 до 10 MB), имат скорост за изпълнение 1ms, а когато процесора трябва да спре една такава нишка, за да работи по друга, това е бавна операция, която натоварва процесора, защото се изисква намесата на ядрото на ОС
    # Извод: Това са тежки характеристики, не е практично да се създават хиляди или милиони платформени нишки

    (Virtual threads) (създадени са за да решат проблемите с platform нишките)
    Те са изключително lightweight, има съответствието N:1 
    Нуждаят се от много малко памет да стартират (около 1KB памет), като се създават мигновенно (по малко от макро секунда) и превключването между тях е много по-ефективно
    # Разликата е че една виртуална нишка не е постоянно свързана с конкретна OS нишка, вместо това JVM може да изпълни много виртуални нишку върху една платформена (OS) нишка, това е описано като "N виртуални: 1 OS нишки"
    # Тези видове нишки се менижират от JVM, като той се грижи за тяхното превключване 
    # Виртуалните нишки позволяват на Java приложенията лесно да управляват милиони едновременно задачи, което е било почти невъзможно с платформените нишки 

* Допълнително обяснение за Platform и Virtual нишките 

    Имаме хардуер, който има процесор и неговите ядра, които реално изпълняват кода
    ОС-а има свой собствен Scheduler, който има работа да разпределя "истинските" OС нишки по физическите ядра, а OС нишките, които опреаципнната система познава и управлява и имат много тежък ресурс

    За операциобнната система, цялият JVM е просто един процес и всеки един Platform Thread (вътре в JVM-a) е директно свързaн с Thread в OC
    Така реално когато един platform thread чака за нещо, той блокира съответната OС нишка, самата тя не може да прави нищо друго, докато чака и взима ценни ресурси

    Вътре в JVM-а има нов, втори scheduler (JVM scheduler), който съществува между платформените и виртуалните нишки, така имаме N:1 връзка, защото JVM Scheduler-a взима много виртуални нишки и ги изпълнява върху малък брой платформени нишки

    Когато се извършва тази комуникация между виртуалните и платформените нишки и със JVM-a може да влезем в няколко състояния:
    - Carrier thread е платформена нишка, която реално се изпълнява от OC и CPU
    - Mounted Virtual Thread е една виртуална нишка, която трябва да изпълни код и JVM-a я монтира върху carrier thread
    - Когато виртуална нишка трябва да чака, тя първо се демонтира (Unmounted Virtual Thread) от Carrier Thread, после тя заспива някъде в паметта на JVM-a, без да хаби ресурси. Carrier Thread-a веднага се освобождава и JVM Scheduler-a монтира на нея друга виртуална нишка, която е готова за работа

    # Note: Когато един carrier thread изпълнява дадена виртуална нишка, ако тя блокира или влезе в режим на чакане, тя не блокира самият Carrier Thread, а просто се демонтира 

* Управленение на нишки в Java 

    Всяка нишка преминава през няколко на нейния жизнен цикъл:
    - Създаване: Създаа се обект Thread, но не се стартира докато не се извика .start()
    - Стартиране/Готовност: Когато се извика .start(), нишката не започва да работи веднага, тя влиза в състояние "готова за работа", чака Scheduler на OС/JVM да й даде процесорно вреем
    - Изпълнение: Това е, когато нишката реално е получила процесор и изпълбява своя код, тя се върти между Runnable и Running
    - Приключване: Нишката е приключила работата си (нейнищт run() метод е завършил) и е "мъртва", веднъж приключила нишката не може да бъде стартирана отново

    Освен основните фаза, една нишка може да е в състояние на чакане:
    - Blocked: Нишката се опитва да влезе в synchronized блок, който в момента е заклчен от друга нишка
    - Waiting: Нишката е извикала wait() или join() и чака друга нишка да я събуди (с notify() или като е приключила)
    - Timed Waiting: Същото като Waiting, но с timeout

    Синхронизацията е механизъм, който гарантира, че само една нишка в даден момент може да има достъп до определен "критичен" участък от код или данни 
    В Java това най-често се постига с ключовата дума synchronized или чрез по сложни Lock Обекти. Това принуждава нишките да се редят на опашка и да изпълняват критични код една по една, което гарантира консистентност на данните 

    Java предоставя механизми за координация между нишките, класическия начин е чрез методите:
    - wait() казва на текущата нишка да заспи и освободи ключалката, докато някой не я събуди
    - notify() събужда произволна нишка, която чака на същия обект
    - notifyAll събужда всички чакащи нишки

* Създаване на нишки 

    Всяка Java програма при стартирането си съдържа една нишка (main)
    # Когато се стартира едно Java приложение, JVM-a автоматично създава така нареченеата main нишка

    За да създадем нова нишка в Java, трябва да се наследи класа java.lang.Thread или да се имплементира интерфейса java.lang.Runnable
    
    Логиката (тоест инструкциите за изпълнение) са в метода run() 
    # Реално работата, която нишката трябва да свърши се намира в run(), независимо дали е наследен Thread класа или се имплементира Runnable трябва да се override-не run() метода
    # Когато се извиква start() метода JVM-а се грижи да стартира нова нишка и да изпълни съдържанието на run() метода в нея 

    Виж ThreadCreationExample.java

* Стартиране на нишка 

    За да се стартира нишка, трябва да се изика метода start(), който вътрешно вика run()
    # Това е единствнения правилен начин да се събуди новата нишка и да започне работата си

    Какво реално се случва зад кулисите:
    - извиква се thread.start()
    - Това подава сигнал на JVM-a 
    - JVM-a се свързва с операционната система, за да създаде нова, отделна нишка на изпълнение
    - Едва след като нишката е създадена JVM инструктура нова нишка да изпълни метода run()
    # Ако директно се извиква thread.run() няма да се стартира нова нишка, кодът от run() просто ще се изпълни на текущата нишка.

* Спиране на нишка 

    Нишката не може да бъде спряна експлицитно, веднъж щом е стартира
    # Преди е имало метод stop(), но е забранен, защото насилственото спиране на нишка може да я спре по средата на важна операция (запис на файл или промяна на данни) и да остави системата в счупено състояние

    Нишката прекратява изпълнението си автоматично след приключването на метода run()
    # Когато кодът в run() стигне своя край, нишката се смята за приключила работата си и тя автоматично спира и освобождава ресурсите си 
    
    Нишката не може да бъде стартирана повторно
    # След като една нишка е приключила е влязла в състояние Terminated, ако се извиква .start() втори път програма ще хвърли IllegalThreadStateException
    # Ако трябва да се повтори работата на вече приключилата нишка, трябва да се направи изцяло нова нишка 

* Thread vs Runnable 

    При употребата на Runnable сме по-гъвкави, защото:
    - Може да се наследи друг клас, ако решим да наследим Thread вече не можем да наследим друг клас, но ако имплементираме само Runnable, не си губим възможността да наследим клас 
    - можем да решим да изпълним имплементацията
    # Когато се създаде Runnable е направен само task-a, тоест какво трябва да се направи
    # От този момент може да стартираме таска със .run() или със threadpool или още в текущата нишка 

    # Накратко Runnable е по-добрият избор, защото разделя задачата (Runnable) от изпълнителя (Thread), което дава свобода в дизайна на класовете

* Thread API 

    Можем да имаме heam-readable име на нишка чрез setName() 
    # Пример customThread.setName("Cool thread #1")

    Също така нишките могат да се групират логически чрез ThreadGroup
    # Може да се създаде група чрез ThreadPool и да се сложат свързани нишки в нея
    # Това позволява да се извършят операциите върху цялата група наведнъж

    В ThreadAPI има четири полезни метода:
    - Thread.sleep(long miliseconds) е статичен метод, койт оказва на текущата нишка да заспи за указания брой милисекунди. Този метод може да хвърли InterruptedException
    - Thread.currentThread() е статичен метод, който връща Thread Обекта на нишката, която в момента изпълнява този метод
    - Thread.getStackTrace() този метод се извиква върху конкретна инстанция на нишка, като метода връща масив, който представлява стека на извикванията на тази нишка
    - boolean isAlive() е метод, който проверява дали нишката е жива, връща true ако нишката е стартирана с .start(), false ако не е била стартирана или е приключила с Terminated състояние 
    - void setPriority(int prio) е метод, който подсказва на диспечъра на нишки, коя нишка е с приоритет, колкото по-малко е подаденото число, толкова е по-голям приоритета
    - Thread.yield() е статичен метод, който казва на диспечъра на задачи, че текущата нишка се отказва от процесорното време в ползва на друга 

    # Note: Добре написано приложение не трябва да разчита на приоритетите на нишки или на yield за своята коректност 
    # Коректността на една програма трябва да се достига чрез синхронизация, а не чрез опити за контрол 

* Присъединяване на нишка към друга 

    Дадена нишка може да паузира изпълнението си, докато друга нишка приключи, чрез метода join()

    Примерен случай, в който можем да използваме join():
    - Нека имаме главна нишка Main и в един момент Main нишката стартира две нови нишки t1 и t2
    - t1 и t2 започват да работят паралелно с Main нишката като всяка от тях си изпълнява своята задача
    - Main нишката върши някаква работа докато не стигне до реда t1.join, тогава тя замръзва и чака да приключи метода t1, за да продължи работата си
    - След като t1 е приключила, Main се събужда и продължава докато не стигне до t2.join, тогава отново спира и чака докато t2 не приключи

    Методи, относно тази ситуация:
    - void join() блокира нишката, която го извиква и кара да чака бекзрайно, докато нишката, върху която е извикан не приключи напълно
    - void join(long milis) това е версията на void join() но с timeout 

* Стандартни и Демон нишки 

    Според режима на работа, нишките в Java могат да бъдат два вида:
    - Стандартни (non-daemon нишки)
    # Това са стандартните нишки, JVM няма да спре докато поне една стандартна нишка все още работи
    - Демон нишки
    # Това са нишки, които работят във "фонов режим" и обслужват другите нишки, пример за това е Garbage Collector-ът
    # Ако всички стандартни нишки са приключили, тогава JVM убива всички daemon нишки, които все още работят 

* Стандартни нишки

    Изпълняват задачи, които са свързани с основната идея на програмата
    # Това означава, че стандартните нишки извършват основната работа на приложението, те са причиината поради която програмата съществуа 

    всяка JVM работи, докато има поедна една работеща стандарта нишка
    # JVM-a няма да спре докато поне една стандартна нишка не е приключила работата си, те са нишките които държат програмата жива

* Daemon нишки 

    Изпълняват задачи, които не са жизненоважни за програмата
    # Можем да кажем че Daemon нишките се използват за фонови, обслужващи задачи
    Примери за такива нишки:
    - Garbage Collector-a в Java
    - Нишки за мониторинг на състоянието на приложението
    - Нишки, които почистват временни файлове 

    JVM-a ще прекрати работата на нишките от този тип, ако няма поне една работеща стандартна нишка
    Виртуалните нишки са винаги и само daemon
    # По дизайн, виртуалните нишки са създадени да изпълняват кратки задачи и не са предназначени да държат приложението живо. Затова те са винаги daemon нишки и не може да се промени това

    Нишките наследяват режима на работа от тази, която ги е създала, или го задават ексиплицитно
    # Ако main нишката (която е стандартна) създаде нова нишка, новата нишка по подразбиране също ще бъде стандартна
    # Възможно е и ръчно да се зададе, че една нишка да бъде daemon 

    void setDaemon(boolean flag)
    # Това е метода, който се изпозлва за тази цел, този метод трябва да бъде извикан преди стартирането на нишката, в противен случай ще се хвърли изключението IllegalThreadStateException

* Състояние на нишка

    Нишката може да бъде в различно състояние в даден момент от изпълнението си
    # Една нишка може да бъде в различни състояние като новосъздадена, готова за стартиране, блокирана, чакаща или приключила

    Методът getState() дава възможност да проверим моменталното състояние на нишката

    Thread.State е специален enum, който съдържа всичките възможни състояния, през които една нишка може да премине по време на своя живот
    Това са състоянията, които методът thread.getState() може да върне:
    - NEW: нишката е новосъздадена, но методътр .start() още не е извикан
    - RUNNABLE: нишката е готова да работи, или работи в момента или чака процесора да и даде процесорно време
    - BLOCKED: нишката е жива, но е спряна, защото се опитва да влезе в synchronize блок, който е заключен от друга нишка
    - WAITING: нишката е жива, но чака безкрайно за някакво събитие. Това се случва когато е извикала thread.join() 
    - TIMED_WAITING: подобно на WAITING, но с tiemout
    - TERMINATED: Нишката е приключила своето изпълнение и е мъртва, тя не моеже да се стартира отново 

* Thread Safety 

    Thread Safety е основна концепция в многонишковото програмане 
    Клас е thread-safe, ако работи коректно при concurrent достъп от множество нишки 
    # Concurrent достъп е множество нишки да се опитват да четат или пишат в данните на един и същ обект по едно и също време
    # Да работи коректно означава, че дори при този едновременен достъп, обектът не влиза в грешно състояние, не връща грешни данни и не предизвиква грешки 

    Thread safety се занимава с това как да се защитят даннните вътре в един обект, по конректно на shared & mutable състоянието
    # Ако данните са shared, множество нишки имат достъп до тях, a ако са и mutable стойността им може да бъде променена

    thread safety цели защитата на данните от неконтролиран concurrent достъп
    # Тоест неконтролиран concurrent води до грешките като race conditions, целта на thread safety e да въведе контрол

    thread-safe класовете енкапсулират евентуалната необходима синхронизация, така че хората, които ги ползват, да не се грижат за нея 
    # Един trhead-safe клас (ConcurrentHashMap в Java) вътрешно се грижи за цялото заключване и синхронизация

    Когато повече от една нишка достъпва състоянието на обект и поне една нишка може да го промени, всички тези нишки трябва да синхронизират достъпа си до това състояние
    # Thread safety нужна само ако споделено състояние и променливо състояние, когато са налице задължително трябва да бъде добавена синхронизация

    Eнкапсулацията и data hiding помагат за thread safety
    # Data Hiding е когато направим полетата private
    # Encapsulation осигурява достъпа до тези private данни чрез getters/setters

* Атомарност 

    Атомарна е операцията, която се изпълнява наведнъж като една неделима стъпка. От гледна точка на всички останали нишки, тази операцията или се е случила изцяло или изобщо не се е случвала 

    Атомарните операции са прости, неделими операции, докато съставние операции са поредица от стъпки 
    # За да постигнем thread safety трябва да намерим начин да превърнем съставните операции в атомарни 

* Race conditions 

    Race condition е понятие в многонишковото програмиране, което описва ситуацията, в която поведението или изходът на програмата зависи от реда на изпълнение на нейните нишки
    # Race condition възниква, когато крайния резултат от едно изчисленеи не е гарантира, а зависи от това коя нишка е успял да се изпълни първа в точно определен момент 

    Tъй като редът на изпълненеи на нишките е непредсказуем, резултатът от дадената последователност от операции е неопределен (недетерминистичен), тоест при няколко изпълнения върху един и същи вход данни, резултатът може да е различен 

    Race condition се случва, когато две или повече нишки имат достъп и манипулират споделни данни или ресурси едновременно, без необходимата синхронизация 
    # Рецептата за race condition е да има споделни данни, промяна на данни и липса на синхронизация

    За да се предотврати race condition-a се използват различни механизми, които гарантират, че само една нишка има достъп до споделените ресурси в даден момент 
    # Най-често срещания механизъм е синхронизацията (synchronized)

* Примери за race condition 

    Има два класически пример за Race Condition:
    - Race condition тип check-then-act 
    - Race condition тип read-modify-write
    
    (Race condition тип check-then-act)
    Това се случва, когато една нишка проверява едно условие и след това извършва действие въз основа на тази проверка. Проблема е че друга нишка може да промени условието между проверката и действието 
    if(ref == null) { # стъпка 1: проверка
        ref = new Something(); # стъпка 2: действие
    } 
    return ref;
    # Възможно е две нишки да са влезли в блока и Something да е бил създаден два пъти.

    (Race condition тип read-modify-write)
    Това е ситуацията, в която една нишка чете стойност, променя я себе си и след това я записва обратно
    i++;
    # Този код е изграден от 3 стъпки, взимане на стойността i, после увеличаване на стойноста и след това записване на i обратно в паметта
    # Проблемът е, че може да се случи context switch между тези три стъпки, което води до загубени промените. Ако две нишки се опитат да направят i++ едновременно, крайният резулат може да е 1, вместо 2

* Атомарни типове данни

    Атомарните типове данни са модерен и много бърз начин за решаване на проблемите с race condition.

    Класовете се намират в java.util.concurrent.atomic пакета 
    # Това не са стандартните примитиви (int, long), а специални класове, които се намират в този пакет

    Предоставят атомарни имплементации на примитивните типове, масиви от примитивни типове и абстракция за атомарна референция
    # Това означава, че в тях има thread-safe версии на примитивни типове, масиви и референции на обекти 
    Примери:
    - AtomicBoolean
    - AtomicInteger
    - AtomicIntegerArray
    - AtomicReference<ActualType>

    Предоставят атомарни алтернативи на съставните операции на съответния примитивен тип 
    # Това е решението на проблема i++ (който е read-modify-write), може да се използва AtomicInteger и извикване на метода .incrementAndGet(), този метод е гарантирано атомарен - изпълнява се само като една неделима операция

    Използват специални CPU инструкции, които позволяват избягването на синхронизация чрез ключалки, което ги прави много бързи 

* Синхронизираща секция 

    Когато две или повече нишки достъпват concurrent даден ресурс, който може да бъде променян, е необходима синхронизация, това се постига чрез ключовата дума synchronized.
    Една сецкията се състой от :
    - монитор, тоест логическата "ключалка"
    # Всяка нишка, коятио иска да влезе в секцията, трябва първо да вземе ключа 
    - блок код, който ще се изпълни ексклузивно от една нишка за даден монитор
    # synhcronized гарантира, че само една нишка, която държи ключ може да изпълнява този код в даден момент, всички останали нишки чакат на опашка

    Виж SynchronizedSectionExample.java 

    Всеки обект има вътрешен имплицитен монитор (lock), тоест може да се ползва за монитор
    # В Java абсолютно всеки обект има вградена ключалка, а това означава че може да се използва всеки обект като ключ за synchronized блок

    Само една нишка в даден момент за даден монитор може да изпълнява кода (mutex == mutex exclusion)
    # Ако 10 нишки се опитат да влязат в код, заключен с един и същ монитор само една ще успее, останалите ще чакат. Това се нарича mutual exclusion (взаимно изкючване)

    Всеки достъп до дадено състояние, което може да бъде променено от друга нишка, трябва винаги да става в синхронизирана секция по един и същи монитор
    # Ако трябва да се защитят данни, всички части от кода, които четат или променят тези данни трябва да се заключват с един и същи монитор (ключ), ако се използват различни ключалки няма да работи

    Мониторът се управлява имплицитно от JVM:
    - при влизане, ако е совобден, се маркира като зает от съответната нишка 
    # Нишка стига до synchronized, проверява ключалката и ако е свободна тя го взима и влиза в кода
    - при влизане, ако не е свободен, нишката блокира и чака 
    # Нишката стига до synchronized, проверява ключа, но вижда, че друга нишка го е взела, тогава нишката автоматично влиза в състояние BLOCKED и заспива нареждайки се на опашката
    - при излизане, lock-ът се освобождава и, ако има блокирани нишки, те могат да се опитат да вземат ключалката 
    # Когато нишката излезе от края synchronized блока, JVM автоматично освобождава ключа и JVM събужда чакащите нишки и е една от тях (не е гарантирано коя) ще успее да вземе ключа и да влезе

* Синхронизиращ метод 

    Случва се да трябва да се постави цялото тяло на даден метод в критична секция, с цел по-четим код Java предалга по-сбит вариант
    # Това означава, че вместо да трябва да се пише synchronized блок, може да се сложи думата synchronized на метода 

    Виж SynchronizedMethodExample.java

* Синхронизирана секция или метод?

    Методът се препоръчва, само ако е достатъчно кратик (и бърз за изпълнение) и наистина има нужда цялото тяло да бъде синхронизирано
    # Използвайки synchronized в декларирането на метода ще заключи целия метод
    # Имаме проблем, ако този метод е прекалено дълъг можм да заключим другите нишки за дълго време

    Синхронизираната секция е за предпочитане, когато:
    - нуждаещото се от синхронизация парче код е малка част от метода
    - искаме да използваме монитор, различен от this
    # Синхронизирания метод винаги използва this като ключалка, а това понякога е нежелателно, може да се иска да се използва друга специална ключалка
    # Синхронизираният блок позволява да се избере всеки обект за монитор, което дава повече контрол 

* Рекурсивност
 
    Lock-ът е рекурсивен (reentrant): нишката която го притежава, може да извиква други критични секции по същия монитор
    # Reentrant означава, че ако едан нишка вече държи ключалката на даден обект, тя може да влезе в друг код, който изисква същата ключалка, без да се самоблокира

    Виж ReentrantExample.java
    # method1 съдържа synchronized(this) блок, когато една нишка влезе в него тя заключва this, но method2 е public synchronized, за да бъде изпълнен method2 нишката също трябва да придобие монитора на this
    # Не забравяй, че public synchronized е кратък вариант за syncrhonized(this){} блок

* Използване на монитор, различен от this 

    Има по-гъвкав и препоръчителен подход за синрхонизация, а именно използването на специален, отделен обект за монитор, вместо да се използва this 

    Може да се избере да се синхронизира достъпа в дадена инстанция на обект чрез член-променлива, създадена с целта, която да се използва като ключалка
    # Вместо да се заключва целия обект има private променлива вътре в класас, чиято единствена цел е да служи като ключ

    Понякога даден клас има нужда от различни монитори за различните състояние
    # Това е ключова причина и се нарича fine-grained locking
    # Възможно е да имаме две независими променливи, които трябва да бъдат thread-safe, а ако използваме synchronized(this) има възможност да блокираме нишките 
    # Добрият подход е ако имаме две различни ключалки за тези две независими променливи

    private final Object dedicatedMonitor = new Object();
    # Това ще бъде ключалката за различните независими променливи, които искаме да сa thread-safe

* Използване на няколко монитора 

    Една нишка може да притежава много на брой монитори, стига те да са свободни
    # Това означава че една нишка може да влезе в synchronized блок да вземе ключалка (lock1) и след това докато държи Lock1 да влезе в нов synchronized блок и да вземе lock2 
    
    Виж MultipleLockExample.java
    # Държането на няколко ключалки е лоша практика и при възможнос трябва да се избягва, защото това може да направи много лесно Deadlock 

* Синхронизация между множество инстанции на клас 

    Понякога трябва да се защити ресурс, който е общ за целия клас (примерно статична променлива), в такъв случай заключване с this не работи
    
    Подходящо е да ползваме ключалка, обща за клас, примерно ключ, който е един и същ за всяка инстанциия на този клас 
    Удобно е да ползваме статична променлива за монитор
    # Най-добрият начин да имаме обща ключалка е тя да бъде статична, понеже статичните променливи принадлежат на класа, а не на отделните обекти 

    Всяка инстанция на клас има статична референция към обекта на класа, към който принадлежи, можем да я достъпим чрез:
    - BankAccount.class
    - this.getClas()

* Статични синхронизирани методи 

    Това се прави,м когато трябва да се защитят статични ресурси от едновременен достъп от много нишки

    Виж StaticSynchronizedExample.java 

* Thread-safe обекти 

    Има обекти, които са thread-safe по подразбиране
    # Има видове обекти, който не е нужно да се прави ръчна синхронизация

    Някой от видовете са:
    - Локални обекти (локални променливи на метод)
    # Безопасни са защото всяка нишка има свой собствен, независим стак и тези променливи живеят само в стака на нишката и не са споделни

    - Stateless обекти 
    # Това са обекти, който нямат състояние, тоест нямат полета, които съхраняват данни

    - Immutable обекти 
    # При Immutable Обектите част от проблема за race condition е премахнат, защото тези обекти не могат да се променят и стоят така 

    - Обекти, които са ефективно final (read-only)
    # Това е още по-общо понятие от Immutable 

* Съставни операции 

    Ако се комбинират няколко thread-safe операции в една по-сложна (обща), нямаме никакви гаранции, че те ще се изпълняват атомарно
    # Това означава, че въпреки че отделните операции са thread-safe, по-сложната операция не е thread-safe

    public synchronized void withdraw(double amount) {  this.balance -= amount; }
    public synchronized double getBalance() { return balance; }

    # Този метод също трябва да е синхронизиран
    public void withdraw(double amount) {
        if(getBalance() >= amount) {
            withdraw(amount);
        }
    }

* Мъртва хватка (Deadlock)

    Получава се, когато две или повече нишки се блокриат една друга, всяка от тях притежава ключалка, от която друга нишка има нужда, но чакайки за ключалк,а която някоя от другите нишки притежава

    Нишките не могат да бъдат прекратявани отвън 
    # Тоест няма безопасен начин просто да се убие една от блокираните нишки, методът Thread.stop() е забранен

    Ключалките не могат да бъдат отнемани насилственото
    # При стандартната synchronized ключалка, няма механизъм, по който една нишка да отракдне ключалка от друга, щом е взета веднъж тя се пуска само когато нишката сама излезе от synchronized блока 

    Единствения изход от deadlock е рестартиране на JVM-a 

* Основни стратегии за предотвратяване на deadlock 

    Има няколко стратегии:
    - Мониторите да се вземат винаги в същия ред
    # Може да се въвъде правилот, че всяка нишка трябва да взема два ключа в един и същ ред
    - използване на един общ монитор
    # Вместо да се използват няколко различни ключалки може да се използва само една-единствена ключалка за всички опреации, които се нуждае синхронизацията
    - избягване на притежаване на повече от един монитор
    # Това правило, гласи, че една нишка никога не трябва да вгнездява ключалки, вместо това да вземе един ключ да си свърши работата и след това да вземе втори ключ
    - подреждаме мониторите спрямо някакъв принзак

* Busy wait

    Busy wait е един неефективен и некоректен метод за комуникация между нишки, защото в цикъл изчаква събитието да се случи 
    # Това означава, че вместо нишката да заспи и да бъде събудена, когато условието е изпълнено, тя остава будна и постоянно проверява дали условието се е променила, хабейки ресурси

    Виж BusyWaitExample.java

* Изчакване чрез wait() 

    wait() е правилен и ефективен начин за комуникация между нишки
    Нишка може да заяви, че иска да изчака, докато дадено събитие се случи, чрез метода wait() на java.lang.Object
    Методът wait() позволява на една нишка да заспи по начин, който не хаби никакви ресурси, докато не бъде "събудена" от друга нишка 

    Виж WaitExample.java 

* java.lang.Object.wait()

    Извикването на wait() винаги става в критичната секция по обекта, който позлваме за монитор, в противен случай се хвърля java.lang.IllegalMonitorStateException
    # Не може да се извика wait(), ако нишката пътво не е заключила този обект 
    
    wait() освобождава текущия монитор и нишката промениава в статус WAITING
    # Когато се извиква wait нишката прави тези следните неща: освобождава ключалката, за да позволи на други нишка да влязат и да променят състоянието и заспива 
    
    Възжмосно е да извикваме wait() с аргументи за време- по този начин нишката ще се събуди, ако бъде известена или времето изтече

    Винаги след събуждане, трябва да проверяваме в цикъл, дали събитието, за което сме чакали, в действителност е настъпило: шаблон, известен като guarded wait 
    # Никога не трябва да използваме if при wait(), а винаги while(), причината е че нишката може да се събуди без notify() да е било извикано или преди условието да е изпълнено 
    # Шаблонът guarded wait гарантира, че нишката ще провери условието отновно след събуждане и ако то все още не е вярно, ще заспи пак

* Известяване чрез notify()

    notify() е методът, който събужда нишките заспали с wait() 

    Нишка може да извести чакащи нишки, че дадено събитие се е случило и те могат да продължат своето изпълнение, това става чрез метода notify() на java.lang.Object
    Виж NotifyExample.java 

    notify() събужда една нишка, чакаща за съответния монитор и извикването на този метод трябвва винаги да става в критична секция на обекта, който ползваме за монитор 
    Когато се извика notify() не се пуска ключалката, тя продължава да държи, докато не стигне края на syncrhonized блока

* notify() vs notifyAll() 

    notify():
    - събужда една произволна нишка, чакаща за този монитор. Полезно е само когато е сигурно, че само една нишка може да продължи изпълнението си и не се иска да се плати цената да се събудят всички
    # notify() е по-евтин защото събужда само едан чакаща нишка, това е добре само ако една нишка ще може да се възползва от промяната
    - ако имаме няколко чакащи нишки за текущия монитор, нямаме възможност да кажем коя/кои нишки да бъдат събудени или да бъдат събудени първи
    # не може да се контролира notify(), ако грешната нижка се събуди тя просто ще заспи отновно, но правилната нишка няма никога да бъде събудена

    notifyAll():
    - събужда всички нишки, в много сучаи, повече от едан нишка може да продължи действието си след известяването си. Нишките се изпълняват последователно в синхронизираната секция по монитора след събуждането си
    # notifyAll() е по-скъп, но по-безопасен понеже събужда всички които чакат
    - В практиката най-често се ползва notifyAll(), правилно имплементирана проверка в while може да гарантира същото поведение като при notify() - макар събудени повечето нишка те ще заспят отново

* Прекъсване на нишки 

    Прекъсването на нишка е кооперативен механизъм, при който една нишка моли друга да спре, а не я спира насилствно 

    Една нишка може да съобщи на друга да спре изпълнението си 
    # Това съобщение се изпраща чрез извикването на метода .interrupt() върху обекта на нишката 

    Какво действие ще се извърши в нишката, зависи изцяло от програмиста, възможно е сигналът да се игнорира
    # Изикването на .interrupt() не спира нишката, то просто вдига флаг за прекъсване. Нишката която е била прекъсната трябва сама да проверява този флаг и да реши какво да прави
    # Aко програмистът не е написал код за проверка сигналът ще бъде игнориран

    Нишката може да провери дали е била прекъсната 
    # Това се случва чрез двата метода Thread.interrupted() и isInterrupted()

    Някои методи, например sleep() или join() хвърлят изключение java.lang.InterruptedException, когато нишката е получила сигнал за прекъсване, докато те се изпълняват 

    customThread.interrupt() # от текущата нишка се изиква този метод върху друга нишка, за да и се изпрати сигнал
    Thread.interrupted() # проверява дали текущата нишка е била прекъсната, ако флага е бил true след това флага ще бъде false
    isInterrupted() # проверява дали нишката има вдигнат флаг за прекъсване и не изчиства флага 