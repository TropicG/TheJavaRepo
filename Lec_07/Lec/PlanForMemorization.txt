Неща, които да се запомня от лекцията:
- Поток е абстракция базирана на непрекъснат поток от данни, има само две операции, които са четене и писане със поток, потоците в Java се делят на битови и символни

- Има 4ри основни абстрактни класа за потоците, 2та от тях са за байтови потоци: InputStream и OutputStream, 2ма от тях са за символни потоци: Reader и Writer
# Teзи абстрактни класове имат много наследници, които служат за работа с различни видове данни като FileInputStream, Socket, ByteArrayInputStream, PipedInputStream

- Потоците могат да се wrapp-ват, като добавят нови функционалности, примерно четене/писане на данни като тескстс, парсване на числа, буфериране

- InputStream/OutputStream служат за четене писане на байтове от системата, може да се използва за аудио или картиран, примерно FileInputStream, DataInputStream
# InputStream може да чете байтове чрез един метод read(), докато DataInputStream може да чете чрез метода readInt()

- Reader/Writer се използва за четене или писанне на текстови данни чрез символи, те са специализирани за това PrintWriter, FileReader

- Основните категории за streams са: Basic, Arrays, File, Data, Buffer
# Basic са основните абстракни stream-ове, Arrays е за четене/писане от паммета, Buffer добавят възможността за буфериране, Data позволяват четене писане на данни 

- Основните класове за потоци от байтове са InputStream и OutputStream, но техните наследници могат да се свързват с източник на данни като файл изображение или да обвиват други stream
# Примерно може да се използва само FileInputStream да се чете от файл директно неговите байтове
# Примерно може дас е използва new BufferedInputStream върху FileInputStream, за да се чете по буфер или да се използва DataInputStream, за да се четат конкретни данни

- Основните класове за потоци от символи са Reader и Writer, но техните наследници добавят BridgeStreams, Wrappers или потоци към памет
# За BridgeStreams може да се използва InputStreamReader, който конверира байтов поток към символен
# Може да се използва BufferedReader, за да може да се добави буфериране за по-бърза обработка

- Жизнения цикъл на съответните потоци е да се създадат, да се използват и да се затворят
# Много важно, когато се затвори даден поток трябва да се извика .close(), но ако външен поток се затвори той затваря и вътрешния

- Важно е да се запомни, че байтовите потоци четат байт по байт, докато символните потоци четат по 2 байта 
# Примерно чрез байтов поток можеш да прочетеш "latinica", но не можеш да прочетеш "кирилица" за това ще ти трябва символен поток

- Важни методи от java.io.InputStream:
# int read() чете следващия байт от потока
# int read(byte[] b) чете байтовете от потока и ги записва в b
# void close() затваря потока
# void available() връща приблизително броя байтове до края на потока

- Важни методи от java.io.OutputStream:
# int write(int b) записва един байт в потока, нарочно е int защото 24-те most significant байтове са използвани
# void write(byte[] b)

- Когато пишем файл чрез FileOutputStream/FileWritter можем да му задем флаг true/false при създаването му с идеята дали да се append-не новата информация или да се пренапише 

- Serializable е маркерен интерфейс (тоес няма методи), той се използа да за каже на JVM, че един клас може да се сеализира или десиализира
# Сериализация е процеса на конвертиране на обект от паметта с всичките му данни в последователност от битове/байтове 
# Десериализация е обратния процес, тоест пресъздаването на обекта в паметта от тази последователност от битове 

- Ако един поток е бил отворен в try-with-resources блок независимо каквото да стане с програмата ще се извика метода .close 
# Възможно е по време на обработката на данните от един поток да крашне програмата, това ще накара потока да не се затвори и ОС да заключи файла, за да не стане проблем, това се нарича изтриване на ресурси
# Всеки един клас, които имплементира AutoClousable и имплементира .close() ще му бъде този метод извиква от try-with-resources

- Основни методи в java.io.Reader
# read() чете символ от потока
# int read(char[] buff) чете масив от pпотока
# void close() 

- Освнони методи в java.io.Writer
# void write(String string) записва цял String в потока
# void flush() ако потокът е буфериран, записва буфера към потока
# void close() 

- краят на реда в Windows е /r/n, докато в Linux e /n, използва се System.lineSeperator(), за да се използва default-ния на системата

- Има три стандартни потока System.in, System.out, System.err

- java.nio.file.Path е интерфейс, който представлява адрес във файловата система
- java.io.File е клас, който представлява както локацията на даден клас така и позволява операции върху него, ппц е legacy подход
- java.nio.file.Files е помощен калс, пълен със много статични методи свързани със операции със файлове и използва Path