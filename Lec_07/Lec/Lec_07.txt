* Какво е поточна линия?

	Това е производителен процес, при който продуктът се движи на конвейрна лента, а всеки работник извършва една и съща малка, повтаряща се задача 
	
* Входни-изходни потоци 

	Някой неща относно концепцията за входно-изходните потоци (streams) в Java:
	- Цялата система за вход-изход (I/О) в Java е изградена върху идеята за потици 
	- Поток е реално една абстракция, която представлява непрекъснат поток от данни 
	- Съществуват само две операции или може да се четат данни от потока (вход) или да се пишат данни в поток (изход)
	- В Java потоците са разделени на два вида, тези който са базирани на байтове (всякакъв вид данни) и тези който са базирани на символи (оптимизирани за работа с текст)
	
* Основния модел за вход-изход (I/O) в Java 

	При вход, Java рпиложението чете (Read) данни от източник (Source), този източник може да бъде файл, конзола или мрежова връзка. Целият процес се случва чрез InputStream (входен поток)
	
	При изход, Java приложението пише (Write) данни към дестинацията, която отново може да бъде файл, конзола или Socket. Целият процес се случва чрез OutputStream (изходен поток)
	
	С други думи, InputStream внася данни в програмта, докато OutputStream изнася данни от нея
	
* Абстрактни класове в корена на I/O йерархията 

	Всичко се базира на четири основни абстрактни класа, които са разделени на две категории:
	- Byte I/O Streams (Байтови потоци) 
	- Character I/O Streams (Символни потоци)
		
	Абстрактните класове в Byte I/O Streams са:
	- InputStream: Това е базовия клас за четене на данни байт по байт (примерно изображение, аудио, всякакви файлове)
	- OutputStream: Това е базовия клас за писане на данни байт по байт 
		
	Абстрактните класове в Character I/О Streams са:
	- Reader: Това е базовия клас за четене на текстови данни символ по символ  (автоматично борави с кодировки като UTF-8)
	- Writer: Това е базовия клас за писане на текстови данни символ по символ 
		
	За по накратко:
	- Byte потоците са за всякакви (бинарни) данни
	- Character потоците са специализирани и оптимизирани за текст 
	
* Абстракните класове и техните конкретни наследници 

	Основните абстрактни класове за I/O в Java (InputStream, OutputStream, Reader и Writer) имат много конкретни наследници (подкласове)

	Всеки наследник е специализиран да работи с различен тип източник или дестинация на данни, примерно:
	- Файлове (FileInputStream)
	- Мрежови връзки (Socket)
	- Буфери в паметта (ByteArrayInputStream)
	- Комуникацията между нишки (PipedInputStream)
		
* Входни-изходни потоци: според допълнителните си качества 

	Освен според източника си потоците могат и да се класифицират и според допълнителните си качества, това се постига като един басов поток се обвива (wrapping) с друг, който добавя нова способност
	Примери за такива способности:
	- Четене/писане на специфични данни като тестк, примитивни типове или цели обекти 
	- Обработка на данни като парсване (анализиране), буфериране (за по-бърза обработка), компресиране или криптиране 
		
* Видове потоци 

	Както споменахме по-рано има две вида потоци (Streams) в Jav: Byte Streams и Character Streams 
	
	Byte Streams (Байтови потоци):
	- Те служат за бинарно четене и писане на сурови (бинарни) данни - байт по байт 
	- Използват се за всякакъв тип файлове, особено за не-текстови като изображенея, аудио
	- Освните класове тук са InputStream и OutputStream както и техните наследници (FileInputStream, DataInputStream, BufferedInputStream и др.)
		
	Character Streams (Символни потоци):
	- Те са специализирани за четене и посане на текстови данни - символ по символ 
	- Автоматично се справят с различните кодировки на символи (примерно UTF-8)
	- Освноните класове са Reader и Writer както и техните наследници (FileReader, BufferedReader, PrintWriter)
		
* Основните категории какъв може да е един поток 

	Основните категории на потоци:
	- Basic: Това са основните абстрактни класове, всички други ги наследяват 
	- Arrays: За четене/писане от масив в паметта 
	- Files: За четене/писане от файлове на диска 
	- Buffering: Добавяне на буфер за по-бърза работа 
	- Data: За четене/писане на примитивни Java типове 
	- Objects: За четене/писане на цели Java обекти 
	- Data-formatted: За лесно форматиране на изхода в четим текст 
		
* Йерархията за Байтовите потоци (Byte Streams) в Java 

	Всичко започва от тези два основни абстракни класа:
	- InputStream
	- OutputStream 
		
	Класовете, които наследяват тези основни абстрактни класове, се делят на две групи:
	- Потоците към източник/дестинация се свързват директно с конкрене източник или цел  като FileInputStream, ByteArrayInputStream
	- Wrapper потоците обвиват друг поток, за да му дадат нова функционалност , базовите класове за товаса FilterInputStream и FilterOutputStream (примери BufferedInputStread, DataInputStream)

* Йерархията на Символните потоци (Character Streams) в Java

	Всичко започва от тези двата основни абстракни класа:
	- Reader
	- Writer 
		
	Основните типове калсове в тази йерархия са:
	- Bridge Streams (Мостови потоци)
	- Wrappers (Обвиващи потоци)
	- Потоци към паметта
		
	Bridge Streams:
	- InputStreamReader е най-важния Reader, той е мост, който преобразвуа байтов поток (примерно FileInputStream) в символен, позволявайки четенето на текст от файл или мрежа 
	- OutputStreamWriter е мост, който преобразува символи в байтове, за да ги пише в OutputStream
	- FileReader/FileWriter са удобни класове, който комбинират горните две с файлове потоци за лесна работа с файлове 
		
	Wrappers:
	- BufferedReader обвива друг Reader и добавя буфериране, което повишава скоростта и позволява четене на тескт ред по ред 
	- BufferedWriter обвива Writer и добавя буфериране за по-бърз запис 
	- PrintWriter обвива Writer и добавя удобни методи за форматиране на текст като println() и printf()
		
	Потоци към паметта:
	- StringReader/StringWriter се използва за четене или писане директно от/към String в паметта 
	- CharArrayReader/CharArrayWriter се използва за четене или писане от/към масив от символи (char[])
		
* Жизнен цикъл на stream-овете 

	Жизнения цикъл на потоците се състои от три стъпки:
	- Създават се: Потоък се отваря и се свързва с източник на данни 
	- Използват се: Извършват се операции за четене или писане на данни 
	- Затварят се: Това е много важна стъпка, защото като се затвори потокът се освобождават заетите ресурси и гарантира, че всички данни са записани 
		
* Wrapping на I/O потоци в Java 

	Концепцията за wrapping на I/O потоците в Java е известна още като шаблона Decorator 
	
	Идеята е че се взима един базов поток (например InputStream) и се обвива в друг, по-специализиран поток (например DataInputStream)
	Целта е да се добавят нови функционалности:
	- Базовият InputStream може само да чете сурови байтове (чрез метода read())
	- Обвиващия DataInputStream добавя по-удобните методи като readInt(), readFloat(), readLong() които автоматично четат и преобразуват байтовете в съответния тип данни 
	Същата логика важи и за OutputStream и DataOutputStream 
	
	Когато се затвори (.close()) външния обвиващ поток, той автоматично затвароя и вътрешния поток, който го обвива 
	
* Byte Streams vs Character Streams при обработката на символи 

	Атомарната единица за работа с ByteStream е 1 байт (8 бита), те четат байт по байт 
	
	Атомаранта единца за работа с CharacterStreams е 1 символ, който в Java се представява като 2 байта (16 бите) 
	
	Виж ByteStreamExample.java
	Виж CharacterStreamExample.java
	Виж FileInputStreamExample.java
	
* Защо байтовите потоци се провалят при обработка на кирилица

	Символите от латинската азбука имат размер до 8 бита, докато символите от кирилица имат размер повече от 8 бита 
	
	Символ като 'I' има стойност 73, което може да се запише с 7 бита (01001001) и това се побира в един байт 
	Символ като 'С' (това е българско с) има стойност 1057 в Unicode и за да се напише са нужни 11 бита (10000100001)

	И понеже един байтов поток чете само по 8 бита, тоест 1 байт наведнъж, той не може да прочете целия 11-битов символ и това води до грешки и счупени символи 
	
* Java.io.InputStream 

	Основните методи на абстракния клас java.io.InputStream:
	- abstract int read(): чете следващищ байт от потока и го връща като int (стойността е от 0 до 255) като байтовете са свършили се връща -1
	- int read(byte[] b): чете байтове от потока и ги записва в масива b, като връща броя на прочетените байтове 
	- int read(byte[] b, int off, int len): чете len байта и ги записва в b, като започва от бозиция off 
	- void close(): затваря потока и освобождава всички системни ресурси, свързани с него 
	- int available(): връща приблизителния брой байтове, които могат да бъдат прочетени веднага 
	- long skip(long n): пропуска следващите n байта от потока 
	- readAllBytes(): чете всички оставащи байтове от потока и ги връща като байтов масив 
		
		Виж DataInputStreamExample.java

* java.io.OutputStream

	Основните методи на абстракния клас java.io.OutputStream:
	- abstract void write(int b): Записва един единствен байт в потока 
	- void write(byte[] b): записва целия байтов масив b в потока и отиват в буфера
	- void write(byte[] b, int off, int lean): записва len брой байта от масива b, започвайки от off и отиват в буфера
	- void flush(): ако потокът е буфериран (тоест събира данни в паметта, преди да ги запише) този метода изпразва буфера и принуждава всички чакащо данни да бъдат записани веднага в дестинацията 
	- void close(): затваря потока за да бъдат освободени ресурси
		
	Виж FileOutputStreamExample.java
	Виж ObjectOutputStreamExample.java

* FileOutputStream: append vs overwrite 

	Има два начина да контролираме FileOutputStream, когато отваряме файл:
	- Append: когато създадем new FileOutputStream("file.txt", true) новите данни ще бъдат добавени в края на файла, запазвайки старото му съдържание
	- Overwrite: когато създадем new FileOutputStream("file.txt", false) (или ако извикаме без false) файлът ще бъде изтрит и презаписан с нови данни 
	
* java.io.Serializable

	Това е маркерен интерфейс, който не съдържа никакви методи 
	
	Неговата единствена цел е да указва на Java, че обектите на даден клас могат да бъдат сериализирани:
	- Сериализация е процеса на конвертиране на обект от паметта с всичките му данни в последователност от битове/байтове 
	- Десериализация е обратния процес, тоест пресъздаването на обекта в паметта от тази последователност от битове 
	
	Имплементиране на този интерфейс е задължително за класовете, чиите обекти ще записваме във файлове или ще изпращаме по мрежата 
	
	Виж SerializableExampe.java
	
* Заключване на ресурси от файловата система 

	Виж примерa LockedFileExample.java
	
	Има сериозен пробле, свръзан с управлението на ресурсите и липсата на обработка на изключения 
	
	Ако примерно възникне грешка по време на четенето на файл или по време на обработката му, програмата ще крашне и никога няма да се затвори потока.
	Това се нарича "изтриване на ресурси" и файлът ще остане заключен от операционната система, което може да създаде проблеми 
	
	Правилният начин да се справим с този проблем е като се работи с try-with-resources блок, който гарантира, че потока ще се затвори автоматично дори и ако е възникнала грешка 
	
* Try-with-resources
	 
	try-with-resources е модерен и по-безопасен начин за работа с ресурси (като потоци) в Java 
	
	В този специален try блок се декларира ресурса в самите скоби на try, основното му предимство е, че той гарантира автоматичното затваряне (извикването на .close()) на ресурса в края на блока, независимо дали кода е приключил успешно или не 
	
	С този начин предотвратяваме изтичането на ресурси, което се случва, когато забравим да затворим потока 
	
	Виж TryResourceExample.java
	
* java.io.Reader
	
	Основните методи на абстрактния клас java.io.Reader:
	- abstract int read(): чете един-единствен символ от потока и го връщата като int (стойност от 0 до 65535), ако няма повече данни връща -1
	- abstract int read(char[] cbuf, int off, int len):  чете до len на брой символа и ги записва в масива cbuf започвайки от позиция off, връща броя на прочетените символи или -1 ако е края на потока 
	- int read(char[] cbuf): опит да се напълни целия масив cbuf със симболи
	- abstract void close(): затваря потока и освобождава всички системни ресурси, свързани с него
	- boolean ready(): проверява дали следващото read() може да се изпълни 
	- long skip(long n): пропуска следващите n символи от потока 
	
* java.io.Writer 

	Основните методи на абстрактния клас java.io.Writer:
	- abstract void write(char[] cbuf, int off, int len): записва len на брой симболи от масива cbuf, започвайки от позиция off
	- void write(String str): записва цял String в потока 
	- void write(char[] cbuf): записва целия масив от символи cbuf 
	- abstract void flush(): Ако потокът е буфериран (събира символи в паметта), този метод кара всички чакащи симболи да бъдат зпаисани веднага в дестинацията
	- abstract void close(): затваря се потока, като първо се извиква flush()
	
* Разделител на редовете в текстов файл 

	Различните операционни системи обозначава край на реда в тексовите си файлове по различен начин:
	- Windows използва два символа: \r\n
	- UNIX, Linux и macOS използват само един \n 
	
	Това може да създаде проблем и за да се гарантира че Java кода работи коректно на всяка ОС, не трябва да се изписват \n или \r\n ръчно 
	Вместо това трябва да се използва един от следните методи, които автоматично използват правилния разделител за ОС:
	- System.lineSeparator()
	- PrintWriter.println()
	- BufferedWrite.newLine()
	
* Трите стандартни потока 

	Трите стандартни входа входно-изходни потока в Java, която всяка програма има автоматично:
	- System.in (Стандартния вход): свързана е с клавиатурата по подразбиране и се използва за да се четат данни от потребителя
	- System.out (Стандартния изход): свързан е с екрана по подразбиране, но се използва за да се напише нормалния изход 
	- System.errr (Стандартен изход за грешки): свързан е с екрана по подразбираме, използва се специално за писане на съобщения за грешки (Това позволява изходът за грешки да бъде отделен или пренасочен, независимо от стандартния изход)
	
* java.util.Scanner 

	java.util.Scanner е най-лесният начин за четене на данни от потребителя, който са въведени от клавиатурата в Java 
	
	Scanner scaneer = new Scanner(Syste.in) създава обект Scanner който слуша стандарният вход System.in
	
	int i = scanner.nextInt() чака потребителя да въведе нещо и да натисне Enter, след това го прочита и преобразува въведенето в цяло число 
	String str = scanner.next() прочита последовалността от символи, разделени с интервал или нов ред и я връща като String 
	
* java.util.Formatter

	java.util.Formatter е клас подпомагащ за форматирането на текст и числа
	
	Виж FormatterExample.java 
	
* Основните концепции за файловата система 

	Основните концепции са:
	- Файловете са организирани в "дърво" - директории (папки), които съдържат файловете или други директории 
	- Основните съставни части се състоят от директории и файлое 
	- Главната директория в windows е C:\, докато в Linux/macOS е /
	- Текущата директория е директорията, в която дадена програма се намира и изпълнява дадените операции в момента 
	- Пътищата са адресът на който файл или директория се намира, делят се на относителни и абсолютни 
	- Символните връзки са специални файлове, които служат като shortcut и сочат към друг файл или директория
	
* Java API-то за работа с файловата система 

	NIO.2, което означава Non-blocking I/O,  е представен като модерния Java API за работа с файловата система 
	
	Пакета java.nio.file съдържа два основни класа:
	- java.nio.file.Path е интерфейс, който представлява адрес във файловата система 
	- java.nio.file.Files е помощен клас. пълен със статични методи за извършване на операции със файлове, използвайки Path
	
* java.nio.file.Path 

	Понеже има различни разделители в пътищата до файловете в различните операционни системи, Java и java.nio.file.Path се справят с тях.
	
	За да може да се пише cross-platform код, който работи навсякъде не трябва ръчно да се пише \ или /, Java предоставя начини да се вземе правилния разделител на текущата система:
	- File.seperator това е статична променлива 
	- FileSystem.getSeperator() това е метод 
	
	Виж PathExample.java 
	
* Шаблони за търсене в операционните системи 

	Какво означават следните символи:
	- * замества произволен брой симболи дори и нула, но само в рамките на едно име на файл или директория
	- ** като * обаче се използва за рекурсивно търсене 
	- ? замества точно един знак 
	- {s1, s2} замества някой от изброните под-шаблони, примерно *.{java, txt} намира File.java и Notes.txt
	- [abc] замества един от изброените символи 
	- [a-z] замества един символ от посочения диапазон
	- [!c] замества всеки един символ освен посочения 
	
	В този файл има много методи, които се използват за Path, но винаги гледай Path класа онлайн
	Виж PathExample.java
	
	В този файл има много методи, които се използват за File, но винаги гледай Path класа онлайн
	Виж FileExample.java
	
* Информация за свободното пространство 

	Java може да провери свободното дисково пространство, това е полезно за инсталаторите, за да проверят дали има свободно място 
	
	Дял е ОС-специфична част от пространството за съхранение с файловата систеам
	Java предоставя ОС-независимо API за това чрез класовете FileSystems и FileStore в пакета java.nio.file
	
	Виж PartionCheckExample.java
	
* Криптиращи и декриптиращи потоци 

	Класовете в Java, които служат за криптиране и декриптиране на данни по време на четене или писане се намират в javax.crypto 
	
	Основните компоненти са:
	- Cipher: той представлява самият алгоритъм като AES или RSA, настройва се да се криптира или декриптира 
	- CipherInputStream: поток, който автоматично декриптира данни, докато ги четеш 
	- CipherOutputStream: поток, който автоматично криптира данни, докато се записват 
	
* Inflater/Deflater потоци, работа със ZIP файлове 

	Класовете в Java, който служат за работа (четене и създаване) на ZIP архиви се намират в пакате java.util.zip
	
	Ключовите класове са:
	- ZipFile: представлява самият ZIP архив, използва се за четене на съдържанието му 
	- ZipEntry: представлява един елемент (един файл или директория) вътре в ZIP архива 
	- ZipOutputStream: Поток, който се използва за създаване на ZIP архива, в него се записват файловете един по един 
	- ZipInputStream: Поток. който се използва за четене на ZIP архива, от него се чете файловете един по един