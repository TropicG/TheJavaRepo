<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест по Java I/O (За напреднали)</title>
    <!-- Зареждане на Tailwind CSS за стилове -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Зареждане на шрифт Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Основен шрифт за цялата страница */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Персонализирани класове за състояние на бутоните */
        .option-btn.correct {
            background-color: #d1fae5; /* Tailwind green-100 */
            border-color: #10b981; /* Tailwind green-500 */
            color: #065f46; /* Tailwind green-800 */
            font-weight: 600;
        }

        .option-btn.incorrect {
            background-color: #fee2e2; /* Tailwind red-100 */
            border-color: #ef4444; /* Tailwind red-500 */
            color: #991b1b; /* Tailwind red-800 */
            font-weight: 600;
        }

        /* Клас за деактивиране на бутоните след отговор */
        .option-btn.disabled {
            pointer-events: none;
            opacity: 0.8;
        }

        /* Скриване на елементи по подразбиране */
        #feedback,
        #next-btn,
        #result-container {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen py-10">

    <div id="app" class="max-w-2xl w-full mx-auto bg-white rounded-xl shadow-2xl overflow-hidden">
        
        <!-- Контейнер за самия тест -->
        <div id="quiz-container" class="p-6 md:p-10">
            <!-- Заглавие и прогрес -->
            <div class="mb-6">
                <h1 class="text-3xl font-bold text-center text-gray-800 mb-2">Тест по Java I/O (За напреднали)</h1>
                <div id="progress" class="text-center text-sm font-medium text-gray-500">Въпрос 1 от 50</div>
            </div>

            <!-- Текущ въпрос -->
            <div class="mb-6">
                <h2 id="question" class="text-xl md:text-2xl font-semibold text-gray-900 leading-tight">Зареждане на въпрос...</h2>
            </div>
            
            <!-- Подсказка (Hint) -->
            <div id="hint-container" class="mb-4 p-3 rounded-lg bg-blue-50 border border-blue-200 text-blue-700 text-sm">
                <strong class="font-semibold">Подсказка:</strong>
                <span id="hint">Зареждане...</span>
            </div>

            <!-- Контейнер за отговорите -->
            <div id="options-container" class="flex flex-col space-y-3">
                <!-- Бутоните за отговори ще бъдат генерирани тук от JavaScript -->
            </div>

            <!-- Обратна връзка/Обяснение -->
            <div id="feedback" class="mt-6 p-4 rounded-lg bg-gray-50 border border-gray-200 text-gray-700">
                <!-- Обяснението ще бъде генерирано тук -->
            </div>

            <!-- Навигация -->
            <div id="nav-buttons" class="mt-8 text-right">
                <button id="next-btn" class="px-8 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                    Следващ въпрос
                </button>
            </div>
        </div>

        <!-- Контейнер за резултати (скрит по подразбиране) -->
        <div id="result-container" class="p-10 text-center">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">Тестът приключи!</h2>
            <div id="score" class="text-2xl font-semibold text-gray-700 mb-8">
                Вашият резултат: 0 от 50
            </div>
            <button id="restart-btn" class="px-8 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                Започни отначало
            </button>
        </div>

    </div>

    <script>
        // --- Начало на данните за теста ---
        // Данните са взети директно от предоставения JSON файл (java_io_advanced_quiz_bg)
        const questionsData = {
            "Qk": [{
                "zBa": 0,
                "question": "Каква е основната разлика в парадигмата между `java.io` (Blocking I/O) и `java.nio` (Non-blocking I/O)?",
                "hint": "Помислете как се четат и обработват данните при двата подхода.",
                "GE": [{
                    "text": "`java.io` използва символни потоци, докато `java.nio` използва байтови потоци.",
                    "Sr": false,
                    "O8": "`java.io` има и байтови, и символни потоци. Основната разлика е в модела на блокиране, а не в типа данни."
                }, {
                    "text": "`java.io` е базиран на потоци (stream-based), докато `java.nio` е базиран на буфери и канали (buffer-based & channel-based).",
                    "Sr": true,
                    "O8": "Това е ключовата архитектурна разлика. NIO чете данни в буфери през канали, което позволява по-гъвкава обработка."
                }, {
                    "text": "`java.nio` е по-бърз само за текстови файлове, докато `java.io` е по-бърз за бинарни.",
                    "Sr": false,
                    "O8": "NIO обикновено е по-бърз за големи обеми данни (бинарни или текстови) поради директните буфери и по-ниското ниво на абстракция."
                }, {
                    "text": "`java.io` не може да работи с мрежи, докато `java.nio` е създаден специално за мрежи.",
                    "Sr": false,
                    "O8": "`java.io` може да работи с мрежи (напр. `SocketInputStream`), но го прави по блокиращ начин."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво прави методът `flip()` на `java.nio.Buffer`?",
                "hint": "Методът се използва за превключване между режими на запис и четене.",
                "GE": [{
                    "text": "Обръща съдържанието на буфера наобратно (от край до начало).",
                    "Sr": false,
                    "O8": "Това би било `reverse()`. `flip()` не променя самите данни, а само указателите."
                }, {
                    "text": "Изчиства буфера, като нулира `position` и `limit`.",
                    "Sr": false,
                    "O8": "Това е описанието на `clear()`. `clear()` подготвя буфера за ново пълнене."
                }, {
                    "text": "Подготвя буфера за четене, като поставя `limit` на текущата `position` и нулира `position`.",
                    "Sr": true,
                    "O8": "Това е точната дефиниция. След запис в буфера, `flip()` го \"обръща\" в режим на четене."
                }, {
                    "text": "Записва съдържанието на буфера във `FileChannel`.",
                    "Sr": false,
                    "O8": "Записването се извършва от метода `write()` на канала, който приема буфера като аргумент."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Каква е разликата между `ByteBuffer.allocate()` и `ByteBuffer.allocateDirect()`?",
                "hint": "Помислете къде се намира паметта, която буферът използва, и как това влияе на Garbage Collector-а.",
                "GE": [{
                    "text": "Няма разлика, `allocateDirect()` е просто псевдоним (alias).",
                    "Sr": false,
                    "O8": "Има съществена разлика в управлението на паметта и производителността."
                }, {
                    "text": "`allocate()` заделя памет в Java heap-а, докато `allocateDirect()` заделя памет извън heap-а (native memory).",
                    "Sr": true,
                    "O8": "Това е вярно. Директните буфери избягват копирането на данни между JVM и OS, което е по-бързо за I/O операции."
                }, {
                    "text": "`allocate()` е за байтове, а `allocateDirect()` е за символи.",
                    "Sr": false,
                    "O8": "И двата метода създават `ByteBuffer`. За символи се използва `CharBuffer`."
                }, {
                    "text": "`allocateDirect()` автоматично компресира данните.",
                    "Sr": false,
                    "O8": "Компресията е отделна функционалност (напр. `DeflaterByteBuffer`)."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "За какво се използва класът `java.nio.channels.Selector`?",
                "hint": "Този клас е в основата на неблокиращите сървърни приложения в Java.",
                "GE": [{
                    "text": "За избиране на най-бързия `FileChannel` от няколко налични.",
                    "Sr": false,
                    "O8": "`Selector` не се използва за файлови канали, а за мрежови."
                }, {
                    "text": "За управление на множество `SocketChannel`-и в една нишка (non-blocking multiplexed I/O).",
                    "Sr": true,
                    "O8": "Това е основната му цел. Позволява на една нишка да следи много връзки за събития (read, write, connect, accept)."
                }, {
                    "text": "За избиране на кодировка (Charset) при четене на текстови файлове.",
                    "Sr": false,
                    "O8": "Изборът на кодировка се прави от `CharsetDecoder` или `InputStreamReader`."
                }, {
                    "text": "За търсене на файлове (glob matching) в `java.nio.file`.",
                    "Sr": false,
                    "O8": "Това се прави с `PathMatcher` или `DirectoryStream`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво означава ключовата дума `transient` в контекста на `java.io.Serializable`?",
                "hint": "Използва се за полета, които не искате да бъдат част от запазеното състояние на обекта.",
                "GE": [{
                    "text": "Полето е временно и ще бъде изтрито от Garbage Collector-а веднага след употреба.",
                    "Sr": false,
                    "O8": "`transient` не влияе на Garbage Collector-а, а само на механизма за сериализация."
                }, {
                    "text": "Полето трябва да бъде криптирано по време на сериализация.",
                    "Sr": false,
                    "O8": "Криптирането изисква ръчна имплементация (напр. с `readObject`/`writeObject`) или `SealedObject`."
                }, {
                    "text": "Полето ще бъде пропуснато (няма да бъде запазено) по време на процеса на сериализация.",
                    "Sr": true,
                    "O8": "Това е точната дефиниция. Използва се за полета, които не трябва да се запазват (напр. пароли, кеширани стойности)."
                }, {
                    "text": "Полето може да бъде достъпвано от множество нишки едновременно.",
                    "Sr": false,
                    "O8": "Това се отнася за ключовата дума `volatile`, а не `transient`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Каква е разликата между имплементирането на `Serializable` и `Externalizable`?",
                "hint": "Единият е автоматичен (маркерен), а другият изисква от вас да напишете логиката за запис и четене.",
                "GE": [{
                    "text": "Няма разлика, `Externalizable` наследява `Serializable`.",
                    "Sr": false,
                    "O8": "`Externalizable` *наистина* наследява `Serializable`, но добавя изисквания, които променят процеса."
                }, {
                    "text": "`Serializable` е за текст, `Externalizable` е за бинарни данни.",
                    "Sr": false,
                    "O8": "И двата интерфейса са за бинарна сериализация на обекти."
                }, {
                    "text": "`Serializable` използва автоматичен процес, докато `Externalizable` изисква ръчно имплементиране на `writeExternal()` и `readExternal()`.",
                    "Sr": true,
                    "O8": "Това е вярно. `Externalizable` дава пълен контрол на програмиста върху това какво и как се записва."
                }, {
                    "text": "`Serializable` е маркерен интерфейс, а `Externalizable` е клас.",
                    "Sr": false,
                    "O8": "И двата са интерфейси."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "За какво служи `serialVersionUID` в `Serializable` клас?",
                "hint": "Помислете какво се случва, ако промените `.class` файла, след като вече сте сериализирали обект.",
                "GE": [{
                    "text": "Това е уникален ID на обекта в паметта.",
                    "Sr": false,
                    "O8": "Това е по-скоро `hashCode()`. `serialVersionUID` е свързан с версионирането на класа."
                }, {
                    "text": "Използва се за криптиране на сериализираните данни.",
                    "Sr": false,
                    "O8": "Няма връзка с криптирането."
                }, {
                    "text": "Използва се за проверка на съвместимостта на версиите на класа по време на десериализация.",
                    "Sr": true,
                    "O8": "Това е точната цел. Ако ID-то на заредения клас не съвпада със запазеното ID, се хвърля `InvalidClassException`."
                }, {
                    "text": "Определя максималния брой обекти, които могат да бъдат сериализирани.",
                    "Sr": false,
                    "O8": "Няма такова ограничение, свързано с този ID."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой от следните класове *не* е част от шаблона \"Decorator\" (wrapping) в `java.io`?",
                "hint": "Декораторът (wrapper) приема друг поток от същия базов тип в конструктора си.",
                "GE": [{
                    "text": "BufferedInputStream",
                    "Sr": false,
                    "O8": "Това е класически Decorator. Той *обвива* друг `InputStream` (напр. `FileInputStream`), за да добави буфериране."
                }, {
                    "text": "DataInputStream",
                    "Sr": false,
                    "O8": "Това също е Decorator. Той *обвива* друг `InputStream`, за да добави способността да чете примитивни типове."
                }, {
                    "text": "FileInputStream",
                    "Sr": true,
                    "O8": "Това *не* е Decorator. Той е базов поток (източник), който се свързва директно с файла. Той не обвива друг поток."
                }, {
                    "text": "ObjectInputStream",
                    "Sr": false,
                    "O8": "Това е Decorator. Той *обвива* друг `InputStream`, за да добави способността да десериализира обекти."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "За какво служи интерфейсът `java.nio.file.FileVisitor`?",
                "hint": "Името му подсказва, че \"посещава\" файлове, обикновено при рекурсивно обхождане.",
                "GE": [{
                    "text": "За наблюдение на промени във файловата система в реално време.",
                    "Sr": false,
                    "O8": "Това се прави от `WatchService`, а не от `FileVisitor`."
                }, {
                    "text": "За имплементиране на логика при обхождане на дърво от директории (walk file tree).",
                    "Sr": true,
                    "O8": "Точно така. Подава се на `Files.walkFileTree()` и методите му се извикват за всеки файл/директория."
                }, {
                    "text": "За четене на метаданни (атрибути) на файл.",
                    "Sr": false,
                    "O8": "Това се прави с `Files.readAttributes()` или `BasicFileAttributes`."
                }, {
                    "text": "За създаване на символни и твърди връзки (links).",
                    "Sr": false,
                    "O8": "Това се прави с `Files.createSymbolicLink()` и `Files.createLink()`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой метод на `FileChannel` е най-ефективният начин за копиране на данни директно от един канал в друг?",
                "hint": "Търсете метод, който избягва копирането на данни през потребителското пространство (user space).",
                "GE": [{
                    "text": "Ръчно четене в `ByteBuffer` с `read()` и запис с `write()` в цикъл.",
                    "Sr": false,
                    "O8": "Това работи, но не е най-ефективният начин, тъй като изисква копиране на данни през JVM heap-а."
                }, {
                    "text": "Използване на `transferTo()` или `transferFrom()`.",
                    "Sr": true,
                    "O8": "Тези методи позволяват на операционната система да извърши копирането директно (zero-copy), ако е възможно, което е много по-бързо."
                }, {
                    "text": "Използване на `ObjectOutputStream` за прехвърляне на байтовия масив.",
                    "Sr": false,
                    "O8": "`ObjectOutputStream` е за сериализация на обекти и добавя ненужно натоварване."
                }, {
                    "text": "Използване на `Files.copy(Path, OutputStream)`.",
                    "Sr": false,
                    "O8": "Това е добър метод от NIO.2, но на по-ниско ниво `FileChannel.transferTo` е често по-производителен."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво представлява `RandomAccessFile` и какво го отличава от `FileInputStream`?",
                "hint": "Името му подсказва, че достъпът не е само последователен.",
                "GE": [{
                    "text": "Той е част от NIO и работи неблокиращо.",
                    "Sr": false,
                    "O8": "`RandomAccessFile` е част от стария `java.io` пакет и е блокиращ."
                }, {
                    "text": "Може да чете и пише в един и същи файл и поддържа позициониране (чрез `seek()`).",
                    "Sr": true,
                    "O8": "Това е основната му характеристика. `FileInputStream` е само за четене и е строго последователен."
                }, {
                    "text": "Той е по-бърз от `FileInputStream`, защото винаги използва директни буфери.",
                    "Sr": false,
                    "O8": "Не е задължително по-бърз и не използва NIO буфери по подразбиране, въпреки че може да предостави `FileChannel`."
                }, {
                    "text": "Може да се използва само за текстови файлове.",
                    "Sr": false,
                    "O8": "Името му (Random Access) предполага, че е идеален за бинарни файлове с фиксирана структура, като бази данни."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какъв е проблемът с използването на `FileReader` или `FileWriter` без изрично задаване на кодировка (Charset)?",
                "hint": "Какво се случва, ако стартирате програмата си на Windows в България и след това на Linux сървър в САЩ?",
                "GE": [{
                    "text": "Няма проблем, те автоматично разпознават кодировката на файла.",
                    "Sr": false,
                    "O8": "Те не разпознават автоматично. Те използват кодировката по подразбиране на платформата."
                }, {
                    "text": "Те ще използват кодировката по подразбиране на платформата, което може да доведе до повредени данни (напр. кирилица).",
                    "Sr": true,
                    "O8": "Това е сериозен проблем. Файл, записан с UTF-8 на една машина, може да бъде прочетен грешно на машина с Windows-1251."
                }, {
                    "text": "Те винаги използват UTF-8, което е стандарт.",
                    "Sr": false,
                    "O8": "Това не е вярно за тези стари класове. `Files.newBufferedReader` (от Java 7+) използва UTF-8 по подразбиране, но `FileReader` не."
                }, {
                    "text": "Те ще хвърлят `UnsupportedEncodingException` при стартиране.",
                    "Sr": false,
                    "O8": "Няма да хвърлят грешка, просто ще работят тихо, но грешно, ако кодировките не съвпадат."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "За какво служат `PipedInputStream` и `PipedOutputStream`?",
                "hint": "Името \"тръба\" (pipe) предполага връзка между две точки.",
                "GE": [{
                    "text": "За свързване на I/O операции в UNIX-базирани тръбопроводи (pipelines).",
                    "Sr": false,
                    "O8": "Въпреки името, те не комуникират с външни процеси (за това се използва `ProcessBuilder`)."
                }, {
                    "text": "За ефективна комуникация между две нишки (threads) в рамките на една и съща JVM.",
                    "Sr": true,
                    "O8": "Това е целта им. Една нишка пише в `PipedOutputStream`, а друга чете от свързания `PipedInputStream`."
                }, {
                    "text": "За компресиране и декомпресиране на данни в движение.",
                    "Sr": false,
                    "O8": "Това се прави от `GZIPOutputStream` или `ZipOutputStream`."
                }, {
                    "text": "Това са абстрактни класове, които не могат да се използват директно.",
                    "Sr": false,
                    "O8": "Те са конкретни класове и се използват директно, като се свържат един с друг."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой от следните методи *не* е част от интерфейса `java.io.Closeable`?",
                "hint": "Интерфейсът `Closeable` е много прост и има само един метод.",
                "GE": [{
                    "text": "close()",
                    "Sr": false,
                    "O8": "`close()` е единственият метод, дефиниран в `Closeable`."
                }, {
                    "text": "flush()",
                    "Sr": true,
                    "O8": "`flush()` е дефиниран в интерфейса `Flushable`, който често се имплементира от изходни потоци, но не е част от `Closeable`."
                }, {
                    "text": "Нито един от другите отговори.",
                    "Sr": false,
                    "O8": "`flush()` не е в `Closeable`."
                }, {
                    "text": "Всички изброени са част от `Closeable`.",
                    "Sr": false,
                    "O8": "`flush()` не е част от `Closeable`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво ще се случи, ако се опитате да десериализирате обект, чийто клас има `transient` полета, без да сте дефинирали `readObject()`?",
                "hint": "Каква е стойността по подразбиране за поле на обект, което не е изрично инициализирано?",
                "GE": [{
                    "text": "Ще бъде хвърлена `NotSerializableException`.",
                    "Sr": false,
                    "O8": "Грешката няма да възникне, процесът ще успее, но полетата няма да бъдат възстановени."
                }, {
                    "text": "Обектът ще бъде десериализиран, но `transient` полетата ще бъдат `null` (или 0, false за примитиви).",
                    "Sr": true,
                    "O8": "Тъй като тези полета са пропуснати при записа, те ще получат стойностите си по подразбиране при инициализацията."
                }, {
                    "text": "Процесът ще спре и ще чака потребителят да въведе стойности за `transient` полетата.",
                    "Sr": false,
                    "O8": "Десериализацията е автоматичен процес и не взаимодейства с потребителя."
                }, {
                    "text": "JVM ще се опита да намери стойностите в база данни.",
                    "Sr": false,
                    "O8": "Няма такъв автоматичен механизъм."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво е \"Scatter/Gather I/O\" (известно още като векторизирано I/O) в `java.nio`?",
                "hint": "Помислете за методите `read(ByteBuffer[] dsts)` и `write(ByteBuffer[] srcs)` в `ScatteringByteChannel` и `GatheringByteChannel`.",
                "GE": [{
                    "text": "Процес на записване на данни в произволен (разпръснат) ред във файла.",
                    "Sr": false,
                    "O8": "Това по-скоро описва `RandomAccessFile`, а не scatter/gather."
                }, {
                    "text": "Четене на данни от канал в *множество* буфери (Scatter) или писане от *множество* буфери в канал (Gather).",
                    "Sr": true,
                    "O8": "Това е точната дефиниция. Позволява обработка на хедър и тяло в отделни буфери с една I/O операция."
                }, {
                    "text": "Техника за изпращане на I/O заявки до всички налични дискове едновременно.",
                    "Sr": false,
                    "O8": "Това описва RAID, а не scatter/gather I/O в Java."
                }, {
                    "text": "Автоматично разделяне на големи файлове на по-малки части.",
                    "Sr": false,
                    "O8": "Това е сегментиране, което е различно от векторизираното I/O."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой от следните методи на `java.nio.file.Files` *не* е атомарна операция?",
                "hint": "Атомарна операция означава, че тя или се случва изцяло, или изобщо не се случва. Коя операция отнема време?",
                "GE": [{
                    "text": "Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE)",
                    "Sr": false,
                    "O8": "Опцията `ATOMIC_MOVE` изрично изисква атомарност (ако се поддържа от ОС)."
                }, {
                    "text": "Files.createSymbolicLink(link, target)",
                    "Sr": false,
                    "O8": "Създаването на символна връзка обикновено е атомарна операция на ниво файлова система."
                }, {
                    "text": "Files.createDirectory(path)",
                    "Sr": false,
                    "O8": "Създаването на директория е атомарна операция."
                }, {
                    "text": "Files.copy(path1, path2)",
                    "Sr": true,
                    "O8": "Копирането на файл *не* е атомарно. Ако системата се срине по средата, ще останете с частично копиран файл."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво прави методът `compact()` на `java.nio.Buffer`?",
                "hint": "Помислете какво правите, ако сте прочели само половината данни, но трябва да освободите място за още четене от канала.",
                "GE": [{
                    "text": "Компресира данните в буфера, използвайки GZIP.",
                    "Sr": false,
                    "O8": "Компресията е много по-сложна операция. `compact()` само премества данни."
                }, {
                    "text": "Премества всички *непрочетени* байтове в началото на буфера и подготвя буфера за нов запис.",
                    "Sr": true,
                    "O8": "Това е точната дефиниция. Използва се, когато сте прочели частично буфера и искате да добавите още данни."
                }, {
                    "text": "Изтрива всички данни от буфера (същото като `clear()`).",
                    "Sr": false,
                    "O8": "`clear()` нулира указателите, но не премества данни. `compact()` запазва непрочетените данни."
                }, {
                    "text": "Намалява капацитета на буфера, за да спести памет.",
                    "Sr": false,
                    "O8": "Капацитетът на буфера е фиксиран след създаването му."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Каква е целта на `java.nio.file.WatchService`?",
                "hint": "Как бихте имплементирали функция \"auto-refresh\" в IDE, когато файл се промени?",
                "GE": [{
                    "text": "Да следи за бавни I/O операции и да докладва за тях.",
                    "Sr": false,
                    "O8": "Това е по-скоро задача за профайлър, а не за `WatchService`."
                }, {
                    "text": "Да ограничава скоростта на I/O операциите, за да не претоварва диска.",
                    "Sr": false,
                    "O8": "Това е 'throttling' и не е целта на `WatchService`."
                }, {
                    "text": "Да наблюдава директории за промени (създаване, триене, модифициране на файлове).",
                    "Sr": true,
                    "O8": "Това е основната му функция. Позволява на приложенията да реагират на промени във файловата система."
                }, {
                    "text": "Да проверява дали файловете са заключени от други процеси.",
                    "Sr": false,
                    "O8": "Проверката за заключване се прави с `FileChannel.tryLock()`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво е \"Memory-Mapped File\" и как се създава в Java NIO?",
                "hint": "Това е техника, при която съдържанието на файла се третира като част от виртуалната памет.",
                "GE": [{
                    "text": "Това е файл, съхраняван изцяло в `String` в паметта, създава се с `StringWriter`.",
                    "Sr": false,
                    "O8": "`StringWriter` е за `java.io` и работи в heap-а, не е memory-mapped file."
                }, {
                    "text": "Файл, който е мапнат (картографиран) в паметта на JVM, което позволява достъп до него сякаш е масив. Създава се с `FileChannel.map()`.",
                    "Sr": true,
                    "O8": "Това е точната дефиниция. Позволява изключително бърз I/O, тъй като OS управлява зареждането на страници."
                }, {
                    "text": "Файл, който се създава в RAM диска на операционната система.",
                    "Sr": false,
                    "O8": "RAM диск е нещо различно. Memory-mapped file е свързан с реален файл на диска."
                }, {
                    "text": "Компресиран ZIP файл, който се чете директно в паметта. Създава се с `ZipFile`.",
                    "Sr": false,
                    "O8": "`ZipFile` чете ZIP архив, но това не е същото като memory-mapping."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Ако един клас имплементира `Serializable`, но неговият родителски клас не, какво се случва с полетата на родителския клас по време на сериализация?",
                "hint": "Помислете как се конструира обект по време на десериализация. Какво се случва с веригата на наследяване?",
                "GE": [{
                    "text": "Всички полета (от детето и родителя) се сериализират автоматично.",
                    "Sr": false,
                    "O8": "Това не е вярно. Автоматичната сериализация работи само за класове, които имплементират `Serializable`."
                }, {
                    "text": "Ще бъде хвърлена `NotSerializableException`, защото родителят не е `Serializable`.",
                    "Sr": false,
                    "O8": "Грешка няма да бъде хвърлена, но полетата на родителя няма да бъдат запазени автоматично."
                }, {
                    "text": "Полетата на детето се сериализират, а полетата на родителя се инициализират чрез извикване на конструктора без параметри на родителя при десериализация.",
                    "Sr": true,
                    "O8": "Това е точният механизъм. JVM търси `no-arg constructor` на първия *не*-сериализируем родител."
                }, {
                    "text": "Само `public` полетата на родителя се сериализират.",
                    "Sr": false,
                    "O8": "Видимостта (`public`/`private`) не е основният фактор тук, а имплементирането на `Serializable`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Каква е основната разлика между `FileChannel.lock()` и `FileChannel.tryLock()`?",
                "hint": "Единият метод ще накара нишката ви да \"заспи\", докато другият ще се върне веднага.",
                "GE": [{
                    "text": "`lock()` е за четене, `tryLock()` е за писане.",
                    "Sr": false,
                    "O8": "И двата метода могат да приемат параметър за споделено (четене) или ексклузивно (писане) заключване."
                }, {
                    "text": "`lock()` е блокиращ (чака, докато получи ключалката), докато `tryLock()` е неблокиращ (връща `null` или хвърля грешка веднага, ако не успее).",
                    "Sr": true,
                    "O8": "Това е ключовата разлика. `tryLock()` позволява на програмата да продължи, ако файлът вече е заключен."
                }, {
                    "text": "`lock()` заключва целия файл, `tryLock()` заключва само част от него.",
                    "Sr": false,
                    "O8": "И двата метода могат да заключват региони от файла (чрез овърлоуди)."
                }, {
                    "text": "`lock()` е част от `java.io`, а `tryLock()` е част от `java.nio`.",
                    "Sr": false,
                    "O8": "И двата метода са на `FileChannel`, който е част от `java.nio`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой от следните `java.nio.file.LinkOption` се използва, за да се укаже на `Files` методите да *не* следват символни връзки?",
                "hint": "Как бихте изтрили самата символна връзка, а не файла, към който тя сочи?",
                "GE": [{
                    "text": "StandardCopyOption.REPLACE_EXISTING",
                    "Sr": false,
                    "O8": "Това е опция за копиране, не за следване на връзки."
                }, {
                    "text": "StandardOpenOption.CREATE",
                    "Sr": false,
                    "O8": "Това е опция за отваряне/създаване на файл, не за следване на връзки."
                }, {
                    "text": "LinkOption.NOFOLLOW_LINKS",
                    "Sr": true,
                    "O8": "Това е точната опция. С нея методи като `Files.exists` ще проверят самата връзка, а не файла, към който сочи."
                }, {
                    "text": "FileVisitOption.FOLLOW_LINKS",
                    "Sr": false,
                    "O8": "Това е опция за `Files.walkFileTree` и прави точно обратното - *следва* връзките."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой клас е най-подходящ за четене на данни, които са били записани с `DataOutputStream`?",
                "hint": "Търсете симетричния \"Input\" клас на дадения \"Output\" клас.",
                "GE": [{
                    "text": "BufferedReader",
                    "Sr": false,
                    "O8": "`BufferedReader` е за текст, четен ред по ред. `DataOutputStream` записва бинарни примитиви."
                }, {
                    "text": "ObjectInputStream",
                    "Sr": false,
                    "O8": "`ObjectInputStream` е за цели обекти. `DataOutputStream` е за примитиви (int, long, double...)."
                }, {
                    "text": "DataInputStream",
                    "Sr": true,
                    "O8": "Тези два класа са симетрични. `DataOutputStream.writeInt()` се чете с `DataInputStream.readInt()`."
                }, {
                    "text": "FileInputStream",
                    "Sr": false,
                    "O8": "`FileInputStream` чете сурови байтове. Ще трябва ръчно да сглобявате `int` от 4 байта, което `DataInputStream` прави за вас."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "В `java.io`, каква е разликата между `Reader` и `InputStream`?",
                "hint": "Единият е предназначен за текст (и кодировки), другият е за сурови данни.",
                "GE": [{
                    "text": "`Reader` е абстрактен клас, `InputStream` е интерфейс.",
                    "Sr": false,
                    "O8": "И двата са абстрактни класове."
                }, {
                    "text": "`Reader` работи със символи (characters, 16-bit), `InputStream` работи с байтове (bytes, 8-bit).",
                    "Sr": true,
                    "O8": "Това е фундаменталната разлика. `Reader` е за текст, `InputStream` е за сурови бинарни данни."
                }, {
                    "text": "`Reader` се използва само за четене от паметта, `InputStream` само от файлове.",
                    "Sr": false,
                    "O8": "И двата могат да четат от различни източници (файлове, мрежа, памет)."
                }, {
                    "text": "`Reader` е по-бърз от `InputStream`.",
                    "Sr": false,
                    "O8": "Няма такова генерално правило; `InputStream` (особено с буфер) е много бърз за бинарни данни."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой от тези класове *не* трябва да се затваря изрично в `try-with-resources` блок?",
                "hint": "Помислете кой от тези класове не управлява ресурс на операционната система (като файл или мрежова връзка).",
                "GE": [{
                    "text": "FileInputStream",
                    "Sr": false,
                    "O8": "Този клас държи файлов дескриптор и *трябва* да бъде затворен, за да се избегне изтичане на ресурси."
                }, {
                    "text": "ByteArrayInputStream",
                    "Sr": true,
                    "O8": "Този клас работи изцяло в паметта. Методът му `close()` не прави нищо и затварянето му не е необходимо."
                }, {
                    "text": "Socket.getInputStream()",
                    "Sr": false,
                    "O8": "Този поток е свързан с мрежов ресурс (сокет) и трябва да бъде затворен (което обикновено затваря и сокета)."
                }, {
                    "text": "ZipFile",
                    "Sr": false,
                    "O8": "`ZipFile` (макар и да не е поток) имплементира `Closeable` и трябва да бъде затворен, за да освободи файла."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво прави методът `rewind()` на `java.nio.Buffer`?",
                "hint": "Името му означава \"пренавиване\" (като на аудио касета), за да започнете отначало.",
                "GE": [{
                    "text": "Изчиства съдържанието на буфера.",
                    "Sr": false,
                    "O8": "Това е `clear()`. `rewind()` не трие данните."
                }, {
                    "text": "Връща `position` на 0, без да променя `limit`.",
                    "Sr": true,
                    "O8": "Това е точната дефиниция. Позволява повторно прочитане на данните, които вече са в буфера."
                }, {
                    "text": "Премества непрочетените байтове в началото (същото като `compact()`).",
                    "Sr": false,
                    "O8": "`compact()` премества данни, `rewind()` само мести указателя `position`."
                }, {
                    "text": "Обръща буфера, за да се чете (същото като `flip()`).",
                    "Sr": false,
                    "O8": "`flip()` променя и `limit`, и `position`. `rewind()` променя само `position`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво е \"Serialization Proxy Pattern\" в Java?",
                "hint": "Това е сложен шаблон, използван за контрол на сериализацията, често при имутативни (immutable) класове.",
                "GE": [{
                    "text": "Използване на `java.lang.reflect.Proxy` за прихващане на I/O операции.",
                    "Sr": false,
                    "O8": "Това е динамично прокси, което е различна концепция от модела за сериализация."
                }, {
                    "text": "Техника, при която се дефинира вътрешен `static` клас (прокси), който се сериализира *вместо* основния обект, чрез `writeReplace()` и `readResolve()`.",
                    "Sr": true,
                    "O8": "Това е точната дефиниция. Дава пълен контрол върху сериализираната форма и помага за сигурността и имутативността."
                }, {
                    "text": "Мрежов прокси сървър, който сериализира всички преминаващи обекти.",
                    "Sr": false,
                    "O8": "Това описва мрежова архитектура, а не шаблон за дизайн в Java."
                }, {
                    "text": "Използване на `transient` за всички полета.",
                    "Sr": false,
                    "O8": "Това би направило обекта празен при сериализация, което не е целта на шаблона."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой клас-мост (bridge) се използва за преобразуване на `OutputStream` (байтове) в `Writer` (символи)?",
                "hint": "Търсите `Writer`, който \"пише в\" `OutputStream`.",
                "GE": [{
                    "text": "InputStreamReader",
                    "Sr": false,
                    "O8": "Това е мост в обратната посока: от `InputStream` (байтове) към `Reader` (символи)."
                }, {
                    "text": "BufferedReader",
                    "Sr": false,
                    "O8": "Това е декоратор, който добавя буфериране към друг `Reader`."
                }, {
                    "text": "OutputStreamWriter",
                    "Sr": true,
                    "O8": "Това е точният мост. Той приема символи (като `Writer`) и ги енкодира в байтове, които записва в `OutputStream`."
                }, {
                    "text": "PrintWriter",
                    "Sr": false,
                    "O8": "Това е декоратор, който добавя форматиращи методи (`println`) към друг `Writer`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво прави `StandardCopyOption.ATOMIC_MOVE` при `Files.move()`?",
                "hint": "Помислете какво означава \"атомарна\" операция в контекста на бази данни или транзакции.",
                "GE": [{
                    "text": "Гарантира, че ако файлът се премести, той ще бъде компресиран.",
                    "Sr": false,
                    "O8": "Няма връзка с компресията."
                }, {
                    "text": "Гарантира, че преместването се случва като една неделима операция на ниво файлова система (ако се поддържа).",
                    "Sr": true,
                    "O8": "Това е вярно. Предотвратява състояния, в които файлът е частично преместен."
                }, {
                    "text": "Изтрива файла-източник, *преди* да започне копирането в дестинацията.",
                    "Sr": false,
                    "O8": "Това би било опасно и не е атомарно. Атомарното преместване често е просто преименуване."
                }, {
                    "text": "Работи само при преместване на файлове между различни дискови устройства.",
                    "Sr": false,
                    "O8": "Атомарното преместване почти винаги се поддържа *само* в рамките на едно и също дисково устройство."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой от тези класове е най-подходящ за четене на ZIP файл, без да се налага да се обхождат всички записи (entries) последователно?",
                "hint": "Търсете клас, който не е `InputStream`, а по-скоро представя целия архив.",
                "GE": [{
                    "text": "ZipInputStream",
                    "Sr": false,
                    "O8": "Този клас е базиран на поток и чете архива последователно, запис по запис. Не е добър за произволен достъп."
                }, {
                    "text": "ZipFile",
                    "Sr": true,
                    "O8": "Този клас позволява произволен достъп. Можете да поискате конкретен `ZipEntry` по име и да получите `InputStream` само за него."
                }, {
                    "text": "GZIPInputStream",
                    "Sr": false,
                    "O8": "Това е за `.gz` файлове, които не са архиви (съдържат само един компресиран файл)."
                }, {
                    "text": "JarInputStream",
                    "Sr": false,
                    "O8": "Той е подобен на `ZipInputStream`, но е специализиран за JAR файлове и също чете последователно."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "В `java.nio.file.attribute`, каква е разликата между `BasicFileAttributes` и `PosixFileAttributes`?",
                "hint": "Името 'POSIX' се отнася за стандарти, свързани с UNIX-подобни операционни системи.",
                "GE": [{
                    "text": "Няма разлика, `PosixFileAttributes` е за Linux, `BasicFileAttributes` е за Windows.",
                    "Sr": false,
                    "O8": "`BasicFileAttributes` е универсален и работи на всички платформи."
                }, {
                    "text": "`BasicFileAttributes` съдържа основни атрибути (размер, време), докато `PosixFileAttributes` добавя UNIX-специфични (права, собственик, група).",
                    "Sr": true,
                    "O8": "Това е точната разлика. `PosixFileAttributes` наследява `BasicFileAttributes` и добавя специфични за POSIX системи данни."
                }, {
                    "text": "`BasicFileAttributes` е за файлове, `PosixFileAttributes` е за директории.",
                    "Sr": false,
                    "O8": "И двата интерфейса могат да се отнасят както за файлове, така и за директории."
                }, {
                    "text": "`BasicFileAttributes` е за четене, `PosixFileAttributes` е за промяна на атрибути.",
                    "Sr": false,
                    "O8": "И двата са за четене. За промяна се използват `Files.setAttributes` или `PosixFileAttributeView`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какъв е резултатът от извикването на `mark()` и след това `reset()` на `BufferedInputStream`?",
                "hint": "Само потоци, които поддържат `markSupported()` (като буферираните), могат да използват тази функционалност.",
                "GE": [{
                    "text": "Потокът ще се върне в самото начало на файла.",
                    "Sr": false,
                    "O8": "`reset()` връща потока до последната `mark()` позиция, а не до началото."
                }, {
                    "text": "Потокът ще се върне към позицията, където `mark()` е бил извикан, стига да не е прочетен повече от `readlimit`.",
                    "Sr": true,
                    "O8": "Това е точната функция. `BufferedInputStream` поддържа `mark`/`reset`, като кешира данни в буфера си."
                }, {
                    "text": "Ще бъде хвърлена `IOException`, тъй като `FileInputStream` не поддържа `mark`/`reset`.",
                    "Sr": false,
                    "O8": "Самият `FileInputStream` *не* поддържа, но `BufferedInputStream`, който го обвива, *поддържа*."
                }, {
                    "text": "Ще маркира файла като \"само за четене\".",
                    "Sr": false,
                    "O8": "Няма връзка с атрибутите на файла."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой от тези класове *не* имплементира `AutoCloseable` и *не* може да се използва в `try-with-resources`?",
                "hint": "Търсете обект, който е просто \"представител\" на данни, а не \"активен\" ресурс.",
                "GE": [{
                    "text": "java.util.Scanner",
                    "Sr": false,
                    "O8": "`Scanner` имплементира `Closeable` (което наследява `AutoCloseable`) и *трябва* да се затваря, особено ако чете от файл."
                }, {
                    "text": "java.nio.channels.Selector",
                    "Sr": false,
                    "O8": "`Selector` имплементира `Closeable` и трябва да бъде затворен, за да освободи ресурси на ОС."
                }, {
                    "text": "java.nio.file.DirectoryStream",
                    "Sr": false,
                    "O8": "`DirectoryStream` имплементира `Closeable` и трябва да бъде затворен, за да се освободи файловият дескриптор."
                }, {
                    "text": "java.nio.file.Path",
                    "Sr": true,
                    "O8": "`Path` е просто обект, който представлява адрес (път). Той не държи отворен ресурс и не имплементира `AutoCloseable`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Каква е целта на `java.io.FileDescriptor`?",
                "hint": "Това е много нискониво понятие, свързващо JVM с операционната система.",
                "GE": [{
                    "text": "Това е обект, който съдържа името, размера и пътя до файла.",
                    "Sr": false,
                    "O8": "Това е описание на `java.io.File` или `java.nio.file.Path`."
                }, {
                    "text": "Това е нискониво \"описание\" (handle) на отворен файл или сокет, управлявано от операционната система.",
                    "Sr": true,
                    "O8": "Това е вярно. Класове като `FileInputStream` го използват вътрешно, за да комуникират с ОС."
                }, {
                    "text": "Използва се за дефиниране на `serialVersionUID`.",
                    "Sr": false,
                    "O8": "Няма връзка със сериализацията."
                }, {
                    "text": "Това е класът, отговорен за заключване на файлове.",
                    "Sr": false,
                    "O8": "Заключването се прави от `FileChannel`, въпреки че то оперира върху файловия дескриптор."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кое твърдение за `PrintWriter` е *невярно*?",
                "hint": "Помислете защо `System.out.println()` (който е `PrintStream`, подобен на `PrintWriter`) не ви кара да слагате `try-catch` всеки път.",
                "GE": [{
                    "text": "Той може да обвие `Writer` (напр. `FileWriter`).",
                    "Sr": false,
                    "O8": "Това е един от основните му конструктори, `new PrintWriter(new FileWriter(...))`."
                }, {
                    "text": "Той може да обвие `OutputStream` (напр. `FileOutputStream`).",
                    "Sr": false,
                    "O8": "Това също е вярно. Той автоматично създава `OutputStreamWriter` вътрешно."
                }, {
                    "text": "Той предоставя методи като `println()` и `printf()`.",
                    "Sr": false,
                    "O8": "Това е основната му цел - лесно форматиране на текст."
                }, {
                    "text": "Той хвърля `IOException` при всяка операция по запис, ако възникне грешка.",
                    "Sr": true,
                    "O8": "Това е *невярно*. `PrintWriter` е проектиран да \"поглъща\" `IOException` и вместо това да задава вътрешен флаг за грешка, който се проверява с `checkError()`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво прави `java.io.SequenceInputStream`?",
                "hint": "Името му подсказва, че създава \"последователност\" (sequence) от потоци.",
                "GE": [{
                    "text": "Чете данни от множество `InputStream`-и, един след друг, карайки ги да изглеждат като един-единствен поток.",
                    "Sr": true,
                    "O8": "Това е точната му функция. Позволява \"слепването\" на няколко файла."
                }, {
                    "text": "Чете един `InputStream`, но в обратен ред.",
                    "Sr": false,
                    "O8": "Няма такъв вграден поток; това би било много сложно за имплементиране."
                }, {
                    "text": "Гарантира, че I/O операциите се случват в правилната последователност при многонишковост.",
                    "Sr": false,
                    "O8": "Това описва синхронизация, която `SequenceInputStream` не предоставя."
                }, {
                    "text": "Разделя един `InputStream` на няколко по-малки.",
                    "Sr": false,
                    "O8": "Той прави обратното - събира няколко в един."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Каква е разликата между `java.io.File` и `java.nio.file.Path`?",
                "hint": "Единият е клас, който съчетава данни (пътя) и поведение (операции), другият е интерфейс, който е само за данни.",
                "GE": [{
                    "text": "`File` е за файлове, `Path` е за директории.",
                    "Sr": false,
                    "O8": "И двата обекта могат да представляват както файлове, така и директории."
                }, {
                    "text": "`File` е остарял (legacy) клас с методи за I/O, докато `Path` е модерен интерфейс, който само представлява път, а операциите са в `Files`.",
                    "Sr": true,
                    "O8": "Това е ключовата разлика. `Path` е по-чиста абстракция, разделяща представянето на пътя от операциите."
                }, {
                    "text": "`File` работи само с абсолютни пътища, `Path` работи и с релативни.",
                    "Sr": false,
                    "O8": "И двата могат да работят и с абсолютни, и с релативни пътища."
                }, {
                    "text": "`File` е по-бърз, защото е по-стар.",
                    "Sr": false,
                    "O8": "`Path` и `Files` (NIO.2) са по-модерни и често по-ефективни, тъй като работят по-добре с файловите системи."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "В `java.nio.file.Files.walkFileTree()`, какво се случва, ако `preVisitDirectory()` върне `FileVisitResult.SKIP_SIBLINGS`?",
                "hint": "Името казва да се пропуснат \"братята\" (siblings), а не \"поддървото\" (subtree).",
                "GE": [{
                    "text": "Обхождането спира незабавно.",
                    "Sr": false,
                    "O8": "Това се случва при `TERMINATE`."
                }, {
                    "text": "Директорията и нейното съдържание се пропускат, но обхождането продължава със \"братята\" (siblings) на директорията.",
                    "Sr": false,
                    "O8": "Това се случва при `SKIP_SUBTREE`."
                }, {
                    "text": "Директорията се посещава, но нейните \"братя\" (файлове и директории на същото ниво) се пропускат.",
                    "Sr": true,
                    "O8": "Това е точната (макар и рядко използвана) семантика. Обхождането продължава в `postVisitDirectory`."
                }, {
                    "text": "Няма ефект, същото е като `CONTINUE`.",
                    "Sr": false,
                    "O8": "Има ясен ефект върху това кои файлове ще бъдат посетени след това."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Каква е целта на `java.io.ObjectOutputStream.writeObjectOverride(Object obj)`?",
                "hint": "Думата `Override` подсказва, че този метод е предназначен за наследяване и промяна на поведението.",
                "GE": [{
                    "text": "Това е методът, който се извиква за запис на `transient` полета.",
                    "Sr": false,
                    "O8": "`transient` полетата се пропускат, освен ако не се обработят в `writeObject()`."
                }, {
                    "text": "Това е `protected` метод, предназначен за подкласове, които искат *напълно* да заменят логиката за сериализация по подразбиране.",
                    "Sr": true,
                    "O8": "Това е точната му цел. За да го използвате, трябва да наследите `ObjectOutputStream`."
                }, {
                    "text": "Използва се за писане на примитивни типове, вместо `writeInt()`.",
                    "Sr": false,
                    "O8": "Той е за обекти, не за примитиви."
                }, {
                    "text": "Това е алтернативно име на `writeObject()`, няма разлика.",
                    "Sr": false,
                    "O8": "Има голяма разлика. `writeObject` използва `writeObjectOverride`, ако е наличен, но `writeObjectOverride` е точката за разширение."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кое е основното предимство на `CipherOutputStream` пред ръчното криптиране на данни преди запис?",
                "hint": "Помислете какво се случва, ако трябва да криптирате 10 GB файл. Ще се побере ли в паметта?",
                "GE": [{
                    "text": "Той е по-бърз, защото използва NIO канали.",
                    "Sr": false,
                    "O8": "Той е част от `javax.crypto` и е базиран на `java.io` потоци, а не на NIO."
                }, {
                    "text": "Той криптира данните \"в движение\" (on-the-fly), докато се записват, което пести памет.",
                    "Sr": true,
                    "O8": "Това е голямо предимство. Не е нужно да зареждате целия файл в паметта, за да го криптирате."
                }, {
                    "text": "Той може да използва само AES-256 алгоритъм.",
                    "Sr": false,
                    "O8": "Той е гъвкав и може да работи с всеки `Cipher` обект, който му подадете (AES, DES, RSA и т.н.)."
                }, {
                    "text": "Той автоматично управлява `serialVersionUID`.",
                    "Sr": false,
                    "O8": "Няма връзка със сериализацията."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво е `java.io.StreamTokenizer`?",
                "hint": "Подобен е на `StringTokenizer`, но работи директно върху поток, а не върху `String`.",
                "GE": [{
                    "text": "Модерен клас за парсване на JSON потоци.",
                    "Sr": false,
                    "O8": "За JSON се използват библиотеки като Jackson или GSON. `StreamTokenizer` е много по-стар."
                }, {
                    "text": "Остарял клас, който разделя `InputStream` на \"токени\" (думи, числа, символи).",
                    "Sr": true,
                    "O8": "Това е точната му функция. Днес `Scanner` или ръчно парсване са предпочитани, но този клас все още съществува."
                }, {
                    "text": "Клас за комбиниране на множество потоци в един.",
                    "Sr": false,
                    "O8": "Това е `SequenceInputStream`."
                }, {
                    "text": "Клас за генериране на токени за сигурност (security tokens).",
                    "Sr": false,
                    "O8": "Това е съвсем различна концепция от I/O."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой клас ви позволява да четете компресирани данни във формат GZIP?",
                "hint": "Търсете класа, чието име съответства на формата `.gz`.",
                "GE": [{
                    "text": "ZipInputStream",
                    "Sr": false,
                    "O8": "`ZipInputStream` е за `.zip` архиви, които могат да съдържат *множество* файлове. GZIP е за *един* файл."
                }, {
                    "text": "InflaterInputStream",
                    "Sr": false,
                    "O8": "Това е по-общият клас за декомпресия. `GZIPInputStream` го наследява и добавя GZIP-специфична обработка (хедъри)."
                }, {
                    "text": "GZIPInputStream",
                    "Sr": true,
                    "O8": "Този клас е декоратор, който обвива друг `InputStream` и декомпресира GZIP данни, докато чете."
                }, {
                    "text": "BufferedInputStream",
                    "Sr": false,
                    "O8": "Той добавя буфериране, но не и декомпресия."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кое от тези твърдения за `java.nio.file.Path` е вярно?",
                "hint": "Помислете как работят `String` обектите. `Path` споделя една важна тяхна характеристика.",
                "GE": [{
                    "text": "Обект `Path` винаги е свързан с реален, съществуващ файл.",
                    "Sr": false,
                    "O8": "Не е вярно. `Path` е просто абстракция. Можете да създадете `Path` за `C:\\nonexistent.txt`."
                }, {
                    "text": "Обектите `Path` са имутативни (immutable).",
                    "Sr": true,
                    "O8": "Това е вярно. Методи като `resolve()` или `normalize()` връщат *нов* `Path` обект, вместо да променят текущия."
                }, {
                    "text": "Можете да промените името на файла, като извикате `path.setFileName(\"new.txt\")`.",
                    "Sr": false,
                    "O8": "Няма такъв метод, тъй като `Path` е имутативен. Преименуването се прави с `Files.move()`."
                }, {
                    "text": "`Path` може да се използва само в `java.nio` и не може да се свърже с `java.io`.",
                    "Sr": false,
                    "O8": "Не е вярно. Можете лесно да конвертирате с `path.toFile()` и `file.toPath()`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво прави `java.io.LineNumberReader`?",
                "hint": "Той е декоратор, подобен на `BufferedReader`, но с една допълнителна функция, свързана с броене.",
                "GE": [{
                    "text": "Чете конкретен ред от файла, зададен с номер.",
                    "Sr": false,
                    "O8": "Той не позволява произволен достъп до редове. Той чете последователно."
                }, {
                    "text": "Това е `BufferedReader`, който следи номера на текущия ред.",
                    "Sr": true,
                    "O8": "Точно така. Той наследява `BufferedReader` и добавя методите `getLineNumber()` и `setLineNumber()`."
                }, {
                    "text": "Записва номера на редовете в началото на всеки ред във файла.",
                    "Sr": false,
                    "O8": "Това е `Reader` (чете), а не `Writer` (пише)."
                }, {
                    "text": "Изчислява общия брой редове във файла, без да го чете целия.",
                    "Sr": false,
                    "O8": "За да преброи редовете, той трябва да ги прочете (или поне да сканира за `\\n`)."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Кой е най-добрият начин да прочетете цял (малък) текстов файл в `String` с *един* ред код (Java 7+)?",
                "hint": "Търсете метод в `java.nio.file.Files`, който връща `byte[]`.",
                "GE": [{
                    "text": "new Scanner(new File(\"f.txt\")).useDelimiter(\"\\\\A\").next();",
                    "Sr": false,
                    "O8": "Това е известен \"трик\", който работи, но е доста нечетлив и не е най-препоръчваният начин."
                }, {
                    "text": "new String(Files.readAllBytes(Paths.get(\"f.txt\")), StandardCharsets.UTF_8)",
                    "Sr": true,
                    "O8": "Това е отличен, ясен и ефективен начин. Първо чете всички байтове, след това ги конвертира в `String`."
                }, {
                    "text": "Files.readAllLines(Paths.get(\"f.txt\")).get(0)",
                    "Sr": false,
                    "O8": "Това ще прочете целия файл в `List<String>`, но ще върне само *първия* ред, а не целия файл като един `String`."
                }, {
                    "text": "new BufferedReader(new FileReader(\"f.txt\")).readLine()",
                    "Sr": false,
                    "O8": "Това ще прочете само първия ред, а също така изисква `try-catch` и не затваря потока."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво е `FileStore` в `java.nio.file`?",
                "hint": "Как бихте проверили колко свободно място има на диск `C:` по крос-платформен начин?",
                "GE": [{
                    "text": "Това е клас за съхранение на файлове в криптиран формат.",
                    "Sr": false,
                    "O8": "Няма връзка с криптирането."
                }, {
                    "text": "Представлява хранилище за файлове, като дисков дял или мрежово устройство, и дава информация за пространството (общо, свободно).",
                    "Sr": true,
                    "O8": "Това е точната му цел. Използва се за получаване на информация за дисковото пространство."
                }, {
                    "text": "Клас за съхранение на `Path` обекти в `HashMap`.",
                    "Sr": false,
                    "O8": "Това е просто структура от данни, а не част от NIO API."
                }, {
                    "text": "Алтернативно име за `FileSystem`.",
                    "Sr": false,
                    "O8": "`FileSystem` представлява файловата система (напр. за ZIP), докато `FileStore` представлява конкретно устройство за съхранение."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво прави `java.io.PushbackInputStream`?",
                "hint": "Помислете за парсър, който чете '123X' и трябва да спре да чете числото, когато види 'X', но 'X' трябва да бъде прочетен от следващия парсър.",
                "GE": [{
                    "text": "Принуждава (push) данните да се запишат веднага (същото като `flush()`).",
                    "Sr": false,
                    "O8": "Това е `InputStream` (чете), а не `OutputStream` (пише)."
                }, {
                    "text": "Позволява \"връщането\" (push back) на прочетени байтове обратно в потока, за да бъдат прочетени отново.",
                    "Sr": true,
                    "O8": "Това е точната му функция. Полезен е за парсъри, които трябва да \"надникнат\" в следващия байт."
                }, {
                    "text": "Изпраща данни към сървър (push notification).",
                    "Sr": false,
                    "O8": "Няма връзка с push известия."
                }, {
                    "text": "Компресира данни, докато ги чете.",
                    "Sr": false,
                    "O8": "Това се прави от `InflaterInputStream`."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Какво е `java.nio.channels.AsynchronousFileChannel`?",
                "hint": "Това е част от т.нар. NIO.2 Asynchronous I/O (AIO), различно от неблокиращото I/O със селектори.",
                "GE": [{
                    "text": "Това е друго име за `FileChannel`, те са идентични.",
                    "Sr": false,
                    "O8": "Те са различни. `FileChannel` е блокиращ (макар и да може да се ползва с `Selector`), докато този е изцяло асинхронен."
                }, {
                    "text": "Канал, който извършва I/O операции асинхронно, връщайки `Future` или използвайки `CompletionHandler`.",
                    "Sr": true,
                    "O8": "Това е точната дефиниция. Позволява на нишката да продължи работа, докато I/O операцията се извършва във фонов режим."
                }, {
                    "text": "Канал, който работи само с текстови файлове.",
                    "Sr": false,
                    "O8": "Той е за байтове, както всички канали."
                }, {
                    "text": "Канал, който не може да пише във файлове, а само да чете.",
                    "Sr": false,
                    "O8": "Може да извършва и четене, и писане."
                }],
                "fS": 0
            }, {
                "zBa": 0,
                "question": "Когато използвате `java.nio.channels.Selector`, какво връща методът `select()`?",
                "hint": "Този метод е блокиращ и \"събужда\" нишката, когато има събитие.",
                "GE": [{
                    "text": "Списък (`List`) с каналите, които са готови за I/O.",
                    "Sr": false,
                    "O8": "Той не връща директно каналите, а само бройка. Готовите канали се взимат от `selectedKeys()`."
                }, {
                    "text": "Броят на каналите, чиито ключове са готови за I/O операции.",
                    "Sr": true,
                    "O8": "Това е точната му функция. Той блокира, докато поне един канал не е готов, и тогава връща броя им."
                }, {
                    "text": "Първият `SocketChannel`, който е готов за четене.",
                    "Sr": false,
                    "O8": "Той не връща самия канал, а само известява, че *има* готови канали."
                }, {
                    "text": "`Future<Integer>`, който ще съдържа броя, когато е готов.",
                    "Sr": false,
                    "O8": "`select()` е блокиращ, той не връща `Future`. Асинхронните операции са в AIO."
                }],
                "fS": 0
            }]
        };
        
        const questions = questionsData.Qk;
        // --- Край на данните за теста ---


        // --- Начало на JavaScript логиката ---
        // Тази логика е адаптирана от Test_lec7_easier.html

        // Променливи за състоянието на теста
        let currentQuestionIndex = 0;
        let score = 0;
        let answerSelected = false;

        // Референции към HTML елементи
        const quizContainer = document.getElementById('quiz-container');
        const resultContainer = document.getElementById('result-container');
        const questionEl = document.getElementById('question');
        const hintEl = document.getElementById('hint');
        const optionsContainer = document.getElementById('options-container');
        const feedbackEl = document.getElementById('feedback');
        const progressEl = document.getElementById('progress');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const scoreEl = document.getElementById('score');

        /**
         * Функция за стартиране на теста (или рестартиране)
         */
        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            answerSelected = false;
            
            // Показва екрана на теста и скрива този за резултати
            quizContainer.style.display = 'block';
            resultContainer.style.display = 'none';
            
            // Зарежда първия въпрос
            loadQuestion();
        }

        /**
         * Функция за зареждане на текущия въпрос и отговори
         */
        function loadQuestion() {
            // Нулиране на състоянието от предишния въпрос
            answerSelected = false;
            feedbackEl.style.display = 'none';
            feedbackEl.innerHTML = '';
            nextBtn.style.display = 'none';

            // Вземане на данните за текущия въпрос
            const questionData = questions[currentQuestionIndex];

            // Попълване на HTML елементите
            questionEl.textContent = questionData.question;
            hintEl.textContent = questionData.hint;
            progressEl.textContent = `Въпрос ${currentQuestionIndex + 1} от ${questions.length}`;

            // Изчистване на старите отговори
            optionsContainer.innerHTML = '';

            // Създаване и добавяне на бутони за всеки възможен отговор
            // Логиката е същата, тъй като новите данни (GE, text, Sr, O8)
            // съвпадат със структурата, очаквана от стария файл.
            questionData.GE.forEach(option => {
                const button = document.createElement('button');
                button.textContent = option.text;
                // Използваме базовия клас за стилизиране от <style>
                button.className = 'option-btn w-full text-left p-4 border border-gray-300 rounded-lg hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200';
                
                // Запазваме важна информация в data- атрибути
                button.dataset.correct = option.Sr; // 'true' или 'false'
                button.dataset.rationale = option.O8; // Обяснението

                // Добавяме event listener за клик
                button.addEventListener('click', selectAnswer);
                
                optionsContainer.appendChild(button);
            });
        }

        /**
         * Функция, която се изпълнява при избор на отговор
         */
        function selectAnswer(e) {
            // Ако вече е отговорено, не прави нищо
            if (answerSelected) return;
            answerSelected = true;

            const selectedBtn = e.target;
            const isCorrect = selectedBtn.dataset.correct === 'true';
            const rationale = selectedBtn.dataset.rationale;

            // Проверка дали отговорът е верен и обновяване на резултата
            if (isCorrect) {
                score++;
                selectedBtn.classList.add('correct');
            } else {
                selectedBtn.classList.add('incorrect');
            }

            // Показване на обяснението
            feedbackEl.innerHTML = `<p class="font-semibold text-gray-800 mb-1">Обяснение:</p><p>${rationale}</p>`;
            feedbackEl.style.display = 'block';

            // Деактивиране на всички бутони и показване на верния отговор
            Array.from(optionsContainer.children).forEach(child => {
                child.classList.add('disabled');
                // Ако потребителят е сгрешил, показваме и верния отговор
                if (child.dataset.correct === 'true' && !isCorrect) {
                    child.classList.add('correct');
                }
            });

            // Показване на бутона "Следващ" или "Завърши"
            nextBtn.style.display = 'inline-block';
            if (currentQuestionIndex === questions.length - 1) {
                nextBtn.textContent = 'Завърши теста';
            } else {
                nextBtn.textContent = 'Следващ въпрос';
            }
        }

        /**
         * Функция за преминаване към следващ въпрос или показване на резултати
         */
        function handleNext() {
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                loadQuestion();
            } else {
                showResults();
            }
        }

        /**
         * Функция за показване на крайния резултат
         */
        function showResults() {
            quizContainer.style.display = 'none';
            resultContainer.style.display = 'block';
            
            const percentage = Math.round((score / questions.length) * 100);
            scoreEl.innerHTML = `Вашият резултат: <span class="text-blue-600">${score} от ${questions.length}</span> (${percentage}%)`;
        }

        // Добавяне на event listeners за бутоните за навигация
        nextBtn.addEventListener('click', handleNext);
        restartBtn.addEventListener('click', startQuiz);

        // При зареждане на страницата, стартираме теста
        document.addEventListener('DOMContentLoaded', startQuiz);

        // --- Край на JavaScript логиката ---
    </script>

</body>
</html>
