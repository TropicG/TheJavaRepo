<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест по Java Path и File</title>
    <!-- Зареждане на Tailwind CSS за стилове -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Зареждане на шрифт Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Основен шрифт за цялата страница */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Персонализирани класове за състояние на бутоните */
        .option-btn.correct {
            background-color: #d1fae5; /* Tailwind green-100 */
            border-color: #10b981; /* Tailwind green-500 */
            color: #065f46; /* Tailwind green-800 */
            font-weight: 600;
        }

        .option-btn.incorrect {
            background-color: #fee2e2; /* Tailwind red-100 */
            border-color: #ef4444; /* Tailwind red-500 */
            color: #991b1b; /* Tailwind red-800 */
            font-weight: 600;
        }

        /* Клас за деактивиране на бутоните след отговор */
        .option-btn.disabled {
            pointer-events: none;
            opacity: 0.8;
        }

        /* Скриване на елементи по подразбиране */
        #feedback,
        #next-btn,
        #result-container {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen py-10">

    <div id="app" class="max-w-2xl w-full mx-auto bg-white rounded-xl shadow-2xl overflow-hidden">
        
        <!-- Контейнер за самия тест -->
        <div id="quiz-container" class="p-6 md:p-10">
            <!-- Заглавие и прогрес -->
            <div class="mb-6">
                <h1 class="text-3xl font-bold text-center text-gray-800 mb-2">Тест по Java Path и File</h1>
                <div id="progress" class="text-center text-sm font-medium text-gray-500">Въпрос 1 от 50</div>
            </div>

            <!-- Текущ въпрос -->
            <div class="mb-6">
                <h2 id="question" class="text-xl md:text-2xl font-semibold text-gray-900 leading-tight">Зареждане на въпрос...</h2>
            </div>
            
            <!-- Подсказка (Hint) -->
            <div id="hint-container" class="mb-4 p-3 rounded-lg bg-blue-50 border border-blue-200 text-blue-700 text-sm">
                <strong class="font-semibold">Подсказка:</strong>
                <span id="hint">Зареждане...</span>
            </div>

            <!-- Контейнер за отговорите -->
            <div id="options-container" class="flex flex-col space-y-3">
                <!-- Бутоните за отговори ще бъдат генерирани тук от JavaScript -->
            </div>

            <!-- Обратна връзка/Обяснение -->
            <div id="feedback" class="mt-6 p-4 rounded-lg bg-gray-50 border border-gray-200 text-gray-700">
                <!-- Обяснението ще бъде генерирано тук -->
            </div>

            <!-- Навигация -->
            <div id="nav-buttons" class="mt-8 text-right">
                <button id="next-btn" class="px-8 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                    Следващ въпрос
                </button>
            </div>
        </div>

        <!-- Контейнер за резултати (скрит по подразбиране) -->
        <div id="result-container" class="p-10 text-center">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">Тестът приключи!</h2>
            <div id="score" class="text-2xl font-semibold text-gray-700 mb-8">
                Вашият резултат: 0 от 50
            </div>
            <button id="restart-btn" class="px-8 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                Започни отначало
            </button>
        </div>

    </div>

    <script>
        // --- Начало на данните за теста ---
        const questionsData = {
            "Qk": [
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.io.File` проверява дали файлът или директорията, означени с този път, съществуват?",
                    "hint": "Методът връща булева стойност.",
                    "GE": [
                        { "text": "isFile()", "Sr": false, "O8": "Този метод проверява дали е файл, но предполага, че вече съществува." },
                        { "text": "exists()", "Sr": true, "O8": "Това е основният метод за проверка на съществуването във файловата система." },
                        { "text": "canRead()", "Sr": false, "O8": "Този метод проверява правата за четене." },
                        { "text": "isDirectory()", "Sr": false, "O8": "Този метод проверява дали е директория." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.nio.file.Path` връща последното име във файловия път като `Path` обект?",
                    "hint": "Това е само името на файла или директорията, без родителските директории.",
                    "GE": [
                        { "text": "getName(int index)", "Sr": false, "O8": "Този метод връща конкретен елемент от пътя по индекс." },
                        { "text": "getParent()", "Sr": false, "O8": "Този метод връща родителската директория." },
                        { "text": "getRoot()", "Sr": false, "O8": "Този метод връща корена на пътя (напр. 'C:\\')." },
                        { "text": "getFileName()", "Sr": true, "O8": "Това е методът, който изолира последното име (файл или директория) в пътя." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.io.File` се използва за създаване на нов, празен файл?",
                    "hint": "Методът връща `true`, ако файлът е създаден успешно, и `false`, ако вече съществува.",
                    "GE": [
                        { "text": "mkdir()", "Sr": false, "O8": "Този метод създава директория." },
                        { "text": "createNewFile()", "Sr": true, "O8": "Това е стандартният метод за създаване на празен файл в legacy I/O." },
                        { "text": "mkdirs()", "Sr": false, "O8": "Този метод създава директория, включително всички необходими родителски директории." },
                        { "text": "createTempFile()", "Sr": false, "O8": "Този статичен метод създава временен файл с уникално име." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Какво прави методът `resolve(Path other)` на `java.nio.file.Path`?",
                    "hint": "Използва се за конструиране на път спрямо друг.",
                    "GE": [
                        { "text": "Намира абсолютния път.", "Sr": false, "O8": "Това се прави от `toAbsolutePath()`." },
                        { "text": "Премахва излишните '.' и '..' елементи.", "Sr": false, "O8": "Това се прави от `normalize()`." },
                        { "text": "Комбинира този път с друг път (`other`). Ако `other` е абсолютен, връща `other`.", "Sr": true, "O8": "Това е основната му функция - 'добавяне' на относителен път към базов." },
                        { "text": "Изчислява относителния път от този път до `other`.", "Sr": false, "O8": "Това се прави от `relativize()`." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Каква е разликата между `mkdir()` и `mkdirs()` в `java.io.File`?",
                    "hint": "Единият метод е по-гъвкав при създаване на вложени директории.",
                    "GE": [
                        { "text": "Няма разлика.", "Sr": false, "O8": "Има съществена разлика в поведението им." },
                        { "text": "`mkdir()` създава само една директория, `mkdirs()` създава и всички липсващи родителски директории.", "Sr": true, "O8": "`mkdirs()` е по-удобен, когато не сте сигурни дали цялата структура съществува." },
                        { "text": "`mkdir()` е за файлове, `mkdirs()` е за директории.", "Sr": false, "O8": "И двата метода са за създаване на директории." },
                        { "text": "`mkdir()` връща `boolean`, `mkdirs()` връща `void`.", "Sr": false, "O8": "И двата метода връщат `boolean`, указващ успех." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.nio.file.Path` премахва излишните '.' и '..' компоненти от пътя?",
                    "hint": "Този процес се нарича нормализация.",
                    "GE": [
                        { "text": "toAbsolutePath()", "Sr": false, "O8": "Този метод прави пътя абсолютен, но не го нормализира задължително." },
                        { "text": "resolve()", "Sr": false, "O8": "Този метод комбинира пътища." },
                        { "text": "normalize()", "Sr": true, "O8": "Това е методът, специално предназначен за 'изчистване' на пътя от '.' и '..'." },
                        { "text": "toRealPath()", "Sr": false, "O8": "Този метод връща реалния път, което включва нормализация и премахване на символни връзки." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Какво връща `delete()` на `java.io.File`, ако се опитате да изтриете непразна директория?",
                    "hint": "Стандартният метод `delete()` има ограничения.",
                    "GE": [
                        { "text": "`true`", "Sr": false, "O8": "Операцията ще се провали." },
                        { "text": "`false`", "Sr": true, "O8": "Методът `delete()` не може да изтрие непразна директория и ще върне `false`." },
                        { "text": "Хвърля `IOException`", "Sr": false, "O8": "Методът не хвърля изключение в този случай, просто връща `false`." },
                        { "text": "Изтрива рекурсивно съдържанието", "Sr": false, "O8": "Това поведение изисква ръчно имплементиране или използване на `Files.walkFileTree`." }
                    ],
                    "fS": 0
                },
                 {
                    "zBa": 0,
                    "question": "Кой метод на `java.nio.file.Path` се използва за изчисляване на относителния път от един път до друг?",
                    "hint": "Резултатът показва как да стигнете от първия път до втория.",
                    "GE": [
                        { "text": "resolve()", "Sr": false, "O8": "Този метод комбинира пътища." },
                        { "text": "normalize()", "Sr": false, "O8": "Този метод опростява пътя." },
                        { "text": "relativize(Path other)", "Sr": true, "O8": "Този метод намира пътя от 'this' Path до 'other' Path." },
                        { "text": "compareTo()", "Sr": false, "O8": "Този метод сравнява лексикографски два пътя." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кое е често срещан проблем при използването на `renameTo(File dest)` в `java.io.File`?",
                    "hint": "Методът има репутация на ненадежден при определени условия.",
                    "GE": [
                        { "text": "Не може да преименува директории.", "Sr": false, "O8": "Може да преименува и файлове, и директории." },
                        { "text": "Често се проваля при преместване на файл между различни файлови системи (дискове) и не дава ясна причина.", "Sr": true, "O8": "Това е основен недостатък; `Files.move()` е по-надежден и хвърля изключения." },
                        { "text": "Винаги изтрива файла `dest`, ако съществува.", "Sr": false, "O8": "Поведението при съществуващ `dest` зависи от операционната система." },
                        { "text": "Работи само на Windows.", "Sr": false, "O8": "Работи на различни платформи, но с различно ниво на надеждност." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.nio.file.Path` връща абсолютния път, ако пътят вече не е абсолютен?",
                    "hint": "Резултатът ще започва от корена на файловата система.",
                    "GE": [
                        { "text": "normalize()", "Sr": false, "O8": "Нормализира пътя, но не го прави задължително абсолютен." },
                        { "text": "toRealPath()", "Sr": false, "O8": "Връща реалния път, който е абсолютен, но изисква файлът да съществува." },
                        { "text": "toAbsolutePath()", "Sr": true, "O8": "Този метод преобразува относителния път в абсолютен спрямо текущата работна директория." },
                        { "text": "getRoot()", "Sr": false, "O8": "Връща само корена, а не целия абсолютен път." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Какво връща методът `length()` на `java.io.File`, ако обектът представлява директория?",
                    "hint": "Размерът на директорията не е дефиниран по същия начин като размера на файл.",
                    "GE": [
                        { "text": "Размера на всички файлове в директорията.", "Sr": false, "O8": "Това изисква рекурсивно обхождане; `length()` не го прави." },
                        { "text": "Броя на файловете в директорията.", "Sr": false, "O8": "За това се използва `listFiles().length`." },
                        { "text": "0 или неопределена стойност, зависеща от файловата система.", "Sr": true, "O8": "Спецификацията казва, че стойността е неопределена за директории." },
                        { "text": "-1", "Sr": false, "O8": "-1 обикновено индикира грешка или край на поток, не размер на директория." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Какво връща `getRoot()` на `java.nio.file.Path` за относителен път (напр. `images/logo.png`)?",
                    "hint": "Относителните пътища нямат корен.",
                    "GE": [
                        { "text": "Празен `Path` обект.", "Sr": false, "O8": "Връща `null`." },
                        { "text": "`null`", "Sr": true, "O8": "Относителните пътища нямат корен, затова методът връща `null`." },
                        { "text": "`.` (текущата директория)", "Sr": false, "O8": "Не връща символ за текуща директория." },
                        { "text": "Хвърля `IllegalStateException`", "Sr": false, "O8": "Методът е дефиниран да връща `null` в този случай." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.io.File` връща времето на последна модификация на файла?",
                    "hint": "Връщаната стойност е брой милисекунди от епохата (01.01.1970).",
                    "GE": [
                        { "text": "getCreationTime()", "Sr": false, "O8": "Такъв метод няма в `java.io.File`; наличен е в NIO.2 атрибутите." },
                        { "text": "lastModified()", "Sr": true, "O8": "Това е стандартният метод за получаване на времето на модификация като `long`." },
                        { "text": "getTimestamp()", "Sr": false, "O8": "Такъв метод няма." },
                        { "text": "getModificationDate()", "Sr": false, "O8": "Такъв метод няма." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.nio.file.Path` проверява дали пътят започва с определен префикс (друг път)?",
                    "hint": "Методът е подобен на `String.startsWith()`.",
                    "GE": [
                        { "text": "isPrefix()", "Sr": false, "O8": "Такъв метод няма." },
                        { "text": "beginsWith()", "Sr": false, "O8": "Такъв метод няма." },
                        { "text": "startsWith(Path prefix)", "Sr": true, "O8": "Този метод проверява дали компонентите на пътя съвпадат с тези на префикса." },
                        { "text": "contains()", "Sr": false, "O8": "Такъв метод няма за проверка на префикс." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Каква е разликата между `getAbsolutePath()` и `getCanonicalPath()` в `java.io.File`?",
                    "hint": "Единият метод разрешава '.' и '..' и символни връзки.",
                    "GE": [
                        { "text": "Няма разлика.", "Sr": false, "O8": "Има важна разлика, особено при наличие на '.' , '..' или символни връзки." },
                        { "text": "`getAbsolutePath()` връща абсолютния път, докато `getCanonicalPath()` връща пътя, използван при създаването на обекта.", "Sr": false, "O8": "`getCanonicalPath()` прави повече от това." },
                        { "text": "`getAbsolutePath()` връща абсолютния път, докато `getCanonicalPath()` връща абсолютния път *след* разрешаване на '.' , '..' и символни връзки.", "Sr": true, "O8": "Каноничният път е уникалното, опростено представяне на пътя във файловата система." },
                        { "text": "`getAbsolutePath()` работи само на Windows, `getCanonicalPath()` само на Linux.", "Sr": false, "O8": "И двата работят на различни платформи." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.nio.file.Path` връща броя на елементите (имена) в пътя?",
                    "hint": "Това не включва корена.",
                    "GE": [
                        { "text": "getLength()", "Sr": false, "O8": "Такъв метод няма; `length()` е за `File` и връща размер." },
                        { "text": "size()", "Sr": false, "O8": "Такъв метод няма." },
                        { "text": "getNameCount()", "Sr": true, "O8": "Този метод връща броя на имената в последователността на пътя." },
                        { "text": "getElementCount()", "Sr": false, "O8": "Такъв метод няма." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.io.File` връща само последното име на файла или директорията като `String`?",
                    "hint": "Аналогичен е на `getFileName()` в `Path`, но връща `String`.",
                    "GE": [
                        { "text": "getPath()", "Sr": false, "O8": "Връща целия път, както е подаден при създаването." },
                        { "text": "getAbsolutePath()", "Sr": false, "O8": "Връща пълния абсолютен път." },
                        { "text": "getName()", "Sr": true, "O8": "Това е методът, който връща последното име в пътя." },
                        { "text": "getFileName()", "Sr": false, "O8": "Такъв метод няма в `java.io.File`." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Какво прави методът `getName(int index)` на `java.nio.file.Path`?",
                    "hint": "Позволява достъп до отделните компоненти на пътя.",
                    "GE": [
                        { "text": "Връща името на файла.", "Sr": false, "O8": "За това е `getFileName()`." },
                        { "text": "Връща елемента от пътя на указания индекс като `Path` обект.", "Sr": true, "O8": "Индексирането започва от 0 за първия елемент след корена." },
                        { "text": "Преименува елемента на указания индекс.", "Sr": false, "O8": "`Path` е immutable; преименуването става с `Files.move()`." },
                        { "text": "Връща броя на имената (същото като `getNameCount()`).", "Sr": false, "O8": "Връща конкретен елемент, не броя." }
                    ],
                    "fS": 0
                },
                 {
                    "zBa": 0,
                    "question": "Какво връща `getParent()` на `java.io.File`, ако пътят няма родител (напр. корен или относителен път без '/'/ '\\')?",
                    "hint": "Помислете как се представя липсата на родител.",
                    "GE": [
                        { "text": "Празен низ (`\"\"`)", "Sr": false, "O8": "Не връща празен низ." },
                        { "text": "`null`", "Sr": true, "O8": "`null` се използва за индикация, че няма родителска директория." },
                        { "text": "Хвърля `NullPointerException`", "Sr": false, "O8": "Методът не хвърля изключение в този случай." },
                        { "text": "`.` (текущата директория)", "Sr": false, "O8": "Не връща символ за текуща директория." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.nio.file.Path` създава относителен път, който е подпоследователност от имената в този път?",
                    "hint": "Позволява да 'изрежете' част от пътя.",
                    "GE": [
                        { "text": "getName(int index)", "Sr": false, "O8": "Връща само един елемент." },
                        { "text": "subpath(int beginIndex, int endIndex)", "Sr": true, "O8": "Този метод връща нов `Path`, състоящ се от елементите в указания диапазон." },
                        { "text": "relativize()", "Sr": false, "O8": "Изчислява път между два други пътя." },
                        { "text": "slice()", "Sr": false, "O8": "Такъв метод няма; `slice()` е за буфери." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Какво връща методът `listFiles()` на `java.io.File`, ако обектът не е директория или възникне I/O грешка?",
                    "hint": "Методът индикира неуспех чрез връщаната стойност.",
                    "GE": [
                        { "text": "Празен масив (`File[0]`)", "Sr": false, "O8": "Празен масив се връща, ако директорията е празна, но съществува." },
                        { "text": "`null`", "Sr": true, "O8": "`null` се връща, ако пътят не сочи към директория или има проблем с достъпа." },
                        { "text": "Хвърля `IOException`", "Sr": false, "O8": "Методът не хвърля изключение в тези случаи." },
                        { "text": "Масив с един елемент, сочещ към самия обект.", "Sr": false, "O8": "Не връща себе си." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "За какво основно се използва методът `toUri()` на `java.nio.file.Path`?",
                    "hint": "Резултатът започва с `file:///`.",
                    "GE": [
                        { "text": "За конвертиране на пътя в `URL` обект.", "Sr": false, "O8": "Въпреки че URI може да се конвертира в URL, основната цел е URI представяне." },
                        { "text": "За създаване на универсален идентификатор на ресурса (URI), който представя пътя.", "Sr": true, "O8": "Това позволява еднозначно идентифициране на файла, независимо от платформата." },
                        { "text": "За криптиране на пътя.", "Sr": false, "O8": "Няма връзка с криптиране." },
                        { "text": "За съкращаване на пътя.", "Sr": false, "O8": "URI обикновено е по-дълго от стандартния път." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Какво проверява методът `isAbsolute()` на `java.io.File`?",
                    "hint": "Проверката зависи от платформата.",
                    "GE": [
                        { "text": "Дали файлът съществува.", "Sr": false, "O8": "За това е `exists()`." },
                        { "text": "Дали пътят е абсолютен според конвенциите на операционната система.", "Sr": true, "O8": "На Windows проверява за 'C:\\...', на Linux за '/...'." },
                        { "text": "Дали пътят е каноничен.", "Sr": false, "O8": "Това е различна концепция, проверявана с `getCanonicalPath()`." },
                        { "text": "Дали файлът е директория.", "Sr": false, "O8": "За това е `isDirectory()`." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Какво прави методът `toRealPath(LinkOption... options)` на `java.nio.file.Path`?",
                    "hint": "Той комбинира няколко други операции и изисква пътят да съществува.",
                    "GE": [
                        { "text": "Конвертира пътя в `java.io.File` обект.", "Sr": false, "O8": "За това е `toFile()`." },
                        { "text": "Връща реалния път до съществуващ файл, като го прави абсолютен, нормализира го и разрешава символни връзки (по подразбиране).", "Sr": true, "O8": "Това е най-точният начин да се получи 'истинският' път във файловата система." },
                        { "text": "Проверява дали пътят е валиден.", "Sr": false, "O8": "Той прави повече от проверка, връща самия път." },
                        { "text": "Създава файла, ако не съществува.", "Sr": false, "O8": "Той изисква пътят вече да съществува и хвърля `IOException`, ако го няма." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод се използва за конвертиране на `java.io.File` обект в `java.nio.file.Path` обект?",
                    "hint": "Методът е част от `java.io.File` класа.",
                    "GE": [
                        { "text": "Paths.get(file.getAbsolutePath())", "Sr": false, "O8": "Това работи, но има по-директен метод." },
                        { "text": "file.toPath()", "Sr": true, "O8": "Това е стандартният метод за конверсия от `File` към `Path`." },
                        { "text": "new Path(file)", "Sr": false, "O8": "`Path` е интерфейс и няма публичен конструктор." },
                        { "text": "Files.getPath(file)", "Sr": false, "O8": "Няма такъв статичен метод в `Files`." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод се използва за конвертиране на `java.nio.file.Path` обект в `java.io.File` обект?",
                    "hint": "Методът е част от `java.nio.file.Path` интерфейса.",
                    "GE": [
                        { "text": "new File(path.toString())", "Sr": false, "O8": "Това работи, но има по-директен метод." },
                        { "text": "path.getParent().toFile()", "Sr": false, "O8": "Това ще върне родителя като `File`, не самия път." },
                        { "text": "Files.toLegacyFile(path)", "Sr": false, "O8": "Няма такъв статичен метод в `Files`." },
                        { "text": "path.toFile()", "Sr": true, "O8": "Това е стандартният метод за конверсия от `Path` към `File`." }
                    ],
                    "fS": 0
                },
                {
                   "zBa": 0,
                   "question": "Кои методи на `java.io.File` се използват за проверка на наличното дисково пространство?",
                   "hint": "Има три свързани метода, които връщат размери в байтове.",
                   "GE": [
                       { "text": "checkSpace()", "Sr": false, "O8": "Такъв метод няма." },
                       { "text": "getTotalSpace(), getFreeSpace(), getUsableSpace()", "Sr": true, "O8": "Тези методи предоставят информация за общото, свободното и използваемото пространство на дяла." },
                       { "text": "getDiskUsage()", "Sr": false, "O8": "Такъв метод няма." },
                       { "text": "getAvailableBytes()", "Sr": false, "O8": "Такъв метод няма." }
                   ],
                   "fS": 0
               },
               {
                   "zBa": 0,
                   "question": "За какво се използва методът `register(WatchService watcher, WatchEvent.Kind<?>... events)` на `java.nio.file.Path`?",
                   "hint": "Свързан е с наблюдение на промени във файловата система.",
                   "GE": [
                       { "text": "Регистрира пътя в централен регистър.", "Sr": false, "O8": "Няма такъв общ регистър." },
                       { "text": "Регистрира обекта `Path` за наблюдение от `WatchService` за определени типове събития.", "Sr": true, "O8": "Това е начинът да кажете на `WatchService` кои директории и за какви промени да следи." },
                       { "text": "Заключва файла за други процеси.", "Sr": false, "O8": "Заключването става през `FileChannel`." },
                       { "text": "Записва пътя в лог файл.", "Sr": false, "O8": "Няма връзка с логване." }
                   ],
                   "fS": 0
               },
               {
                   "zBa": 0,
                   "question": "Какво връщат методите `setReadable(boolean readable)`, `setWritable(boolean writable)` и `setExecutable(boolean executable)` в `java.io.File`?",
                   "hint": "Те се опитват да променят правата и индикират дали са успели.",
                   "GE": [
                       { "text": "`void`", "Sr": false, "O8": "Те връщат стойност, за да покажат резултата." },
                       { "text": "`boolean`, указващ дали операцията е била успешна.", "Sr": true, "O8": "`true` означава, че правата са променени успешно (ако се поддържа от ОС)." },
                       { "text": "Старите стойности на правата.", "Sr": false, "O8": "Не връщат старите стойности." },
                       { "text": "Хвърлят `SecurityException`, ако няма права.", "Sr": false, "O8": "Те връщат `false`, ако няма права, вместо да хвърлят изключение." }
                   ],
                   "fS": 0
               },
               {
                   "zBa": 0,
                   "question": "Какво обхожда `iterator()` на `java.nio.file.Path`?",
                   "hint": "Позволява итерация върху компонентите на пътя.",
                   "GE": [
                       { "text": "Файловете в директорията, сочена от пътя.", "Sr": false, "O8": "За това се използва `Files.newDirectoryStream()`." },
                       { "text": "Компонентите (имената) на пътя като `Path` обекти.", "Sr": true, "O8": "Итераторът преминава през всяко име в пътя (без корена)." },
                       { "text": "Символите в името на пътя.", "Sr": false, "O8": "За това бихте използвали `toString().chars()`." },
                       { "text": "Родителските директории на пътя.", "Sr": false, "O8": "За достъп до родителя се използва `getParent()`." }
                   ],
                   "fS": 0
               },
               {
                  "zBa": 0,
                  "question": "Как методът `compareTo(File pathname)` сравнява два `java.io.File` обекта?",
                  "hint": "Сравнението е базирано на текстовото представяне на пътя.",
                  "GE": [
                      { "text": "По размер на файла.", "Sr": false, "O8": "Не сравнява по размер." },
                      { "text": "По дата на последна модификация.", "Sr": false, "O8": "Не сравнява по дата." },
                      { "text": "Лексикографски, базирано на низовете, върнати от `getPath()`.", "Sr": true, "O8": "Това е стандартното сравнение, дефинирано от интерфейса `Comparable`." },
                      { "text": "Чрез проверка дали сочат към един и същ файл във файловата система.", "Sr": false, "O8": "Това би било по-скоро `equals()` след канонизация." }
                  ],
                  "fS": 0
              },
              {
                  "zBa": 0,
                  "question": "Как методът `compareTo(Path other)` сравнява два `java.nio.file.Path` обекта?",
                  "hint": "Сравнението отново е базирано на текстовото представяне.",
                  "GE": [
                      { "text": "По брой компоненти в пътя.", "Sr": false, "O8": "Не сравнява по брой компоненти." },
                      { "text": "Чрез проверка дали са в една и съща директория.", "Sr": false, "O8": "Не прави такава проверка." },
                      { "text": "Лексикографски, компонент по компонент.", "Sr": true, "O8": "Сравнява пътищата по азбучен ред на техните компоненти." },
                      { "text": "По това дали са абсолютни или относителни.", "Sr": false, "O8": "Типът на пътя не е основен критерий за подредба." }
                  ],
                  "fS": 0
              },
              {
                  "zBa": 0,
                  "question": "Какво сравнява `equals(Object obj)` за `java.io.File` обекти?",
                  "hint": "Сравнява пътищата, но може да е чувствителен към регистър.",
                  "GE": [
                      { "text": "Съдържанието на файловете.", "Sr": false, "O8": "Не чете съдържанието." },
                      { "text": "Дали сочат към един и същ файл/директория във файловата система.", "Sr": false, "O8": "Не гарантира това; сравнява само низът на пътя." },
                      { "text": "Низовете на пътищата, като сравнението е зависимо от платформата (case-sensitive/insensitive).", "Sr": true, "O8": "Поведението зависи от това как операционната система третира пътищата." },
                      { "text": "Размера и датата на модификация.", "Sr": false, "O8": "Не сравнява атрибути." }
                  ],
                  "fS": 0
              },
              {
                  "zBa": 0,
                  "question": "Какво сравнява `equals(Object other)` за `java.nio.file.Path` обекти?",
                  "hint": "Сравнението е по-стриктно дефинирано от това при `File`.",
                  "GE": [
                      { "text": "Низовете на пътищата, без оглед на регистъра.", "Sr": false, "O8": "Сравнението е чувствително към регистър, освен ако `FileSystem` не указва друго." },
                      { "text": "Дали файловете, към които сочат, са идентични.", "Sr": false, "O8": "Не проверява файловата система." },
                      { "text": "Низовете на пътищата и `FileSystem`-а, към който принадлежат.", "Sr": true, "O8": "Два `Path` обекта са равни, само ако низовете им са равни и са от една и съща файлова система." },
                      { "text": "Каноничните им пътища.", "Sr": false, "O8": "Не изчислява каноничен път." }
                  ],
                  "fS": 0
              },
              {
                   "zBa": 0,
                   "question": "На какво се базира `hashCode()` на `java.io.File`?",
                   "hint": "Свързано е с `equals()`.",
                   "GE": [
                       { "text": "На размера на файла.", "Sr": false, "O8": "Не зависи от размера." },
                       { "text": "На низа на пътя, като отчита чувствителността към регистър на платформата.", "Sr": true, "O8": "Хеш кодът се изчислява върху пътя по начин, съвместим с `equals()`." },
                       { "text": "На датата на последна модификация.", "Sr": false, "O8": "Не зависи от датата." },
                       { "text": "На inode номера (на UNIX).", "Sr": false, "O8": "Не използва директно inode." }
                   ],
                   "fS": 0
               },
               {
                   "zBa": 0,
                   "question": "На какво се базира `hashCode()` на `java.nio.file.Path`?",
                   "hint": "Свързано е с `equals()` за `Path`.",
                   "GE": [
                       { "text": "На хеш кода на `FileSystem` обекта.", "Sr": false, "O8": "Включва и пътя." },
                       { "text": "На нормализирания път.", "Sr": false, "O8": "Базира се на оригиналния низ." },
                       { "text": "На хеш кода на низа на пътя и `FileSystem`-а.", "Sr": true, "O8": "Гарантира, че ако два `Path` обекта са `equals()`, те ще имат еднакъв `hashCode()`." },
                       { "text": "На абсолютния път.", "Sr": false, "O8": "Базира се на подадения низ." }
                   ],
                   "fS": 0
               },
               {
                   "zBa": 0,
                   "question": "Какво обикновено връща `toString()` на `java.io.File`?",
                   "hint": "Същото е като един от `get...` методите.",
                   "GE": [
                       { "text": "Абсолютния път.", "Sr": false, "O8": "Не е гарантирано, че е абсолютен." },
                       { "text": "Каноничния път.", "Sr": false, "O8": "Не изчислява каноничен път." },
                       { "text": "Низът на пътя, подаден при създаването (същото като `getPath()`).", "Sr": true, "O8": "Това е стандартното поведение." },
                       { "text": "Само името на файла.", "Sr": false, "O8": "За това е `getName()`." }
                   ],
                   "fS": 0
               },
               {
                   "zBa": 0,
                   "question": "Какво обикновено връща `toString()` на `java.nio.file.Path`?",
                   "hint": "Това е основното текстово представяне.",
                   "GE": [
                       { "text": "URI представянето.", "Sr": false, "O8": "За това е `toUri()`." },
                       { "text": "Низът на пътя, използвайки разделителя по подразбиране за платформата.", "Sr": true, "O8": "Връща стандартното текстово представяне на пътя." },
                       { "text": "Абсолютния и нормализиран път.", "Sr": false, "O8": "Не извършва тези трансформации." },
                       { "text": "Пътя с разделители, обърнати наобратно.", "Sr": false, "O8": "Използва стандартните разделители." }
                   ],
                   "fS": 0
               },
               {
                   "zBa": 0,
                   "question": "Създаването на `new File(\"some/path/file.txt\")` създава ли файл или директория на диска?",
                   "hint": "`File` обектът е само представяне.",
                   "GE": [
                       { "text": "Да, създава празен файл.", "Sr": false, "O8": "Създаването на обекта не взаимодейства с файловата система." },
                       { "text": "Да, създава директориите `some/path/`.", "Sr": false, "O8": "Създаването на обекта не взаимодейства с файловата система." },
                       { "text": "Не, създава само обект в паметта, който представлява този път.", "Sr": true, "O8": "За реално създаване са нужни `createNewFile()`, `mkdir()` или операции от `Files`." },
                       { "text": "Зависи дали пътят вече съществува.", "Sr": false, "O8": "Създаването на обекта винаги успява, независимо дали пътят съществува." }
                   ],
                   "fS": 0
               },
               {
                   "zBa": 0,
                   "question": "Създаването на `Path p = Paths.get(\"some/path/file.txt\")` създава ли файл или директория на диска?",
                   "hint": "`Path` обектът също е само представяне.",
                   "GE": [
                       { "text": "Да, създава празен файл.", "Sr": false, "O8": "Създаването на `Path` обекта не взаимодейства с файловата система." },
                       { "text": "Да, създава директориите `some/path/`.", "Sr": false, "O8": "Създаването на `Path` обекта не взаимодейства с файловата система." },
                       { "text": "Не, създава само обект в паметта, който представлява този път.", "Sr": true, "O8": "За реално създаване са нужни операции от класа `Files` (напр. `Files.createFile(p)`)." },
                       { "text": "Зависи дали имате права за запис.", "Sr": false, "O8": "Правата нямат значение за създаването на самия `Path` обект." }
                   ],
                   "fS": 0
               },
                {
                    "zBa": 0,
                    "question": "Кое поле/метод предоставя платформено-независимия разделител за пътища (path separator)?",
                    "hint": "Това е символът, който разделя директориите (`/` или `\\`).",
                    "GE": [
                        { "text": "`File.separator` (статично поле)", "Sr": true, "O8": "Това е класическият начин в `java.io` да се вземе правилният разделител." },
                        { "text": "`Path.separator`", "Sr": false, "O8": "Няма такова статично поле в `Path`." },
                        { "text": "`System.getProperty(\"file.separator\")`", "Sr": false, "O8": "Това също работи, но `File.separator` е по-пряк начин." },
                        { "text": "`Path.getFileSystem().getSeparator()`", "Sr": false, "O8": "Това е модерният начин в NIO.2, но `File.separator` също е валиден отговор в контекста." }
                        // Note: Depending on strictness, File.separator is the most direct answer for the 'File' part.
                        // Added clarification that the NIO.2 way exists.
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.io.File` връща `File` обект, представляващ родителската директория?",
                    "hint": "Връща обект, не низ.",
                    "GE": [
                        { "text": "getParent()", "Sr": false, "O8": "Този метод връща родителя като `String`." },
                        { "text": "getParentFile()", "Sr": true, "O8": "Този метод връща родителя като `File` обект." },
                        { "text": "getAbsoluteFile().getParentFile()", "Sr": false, "O8": "Това е по-сложен начин да се постигне същото, но `getParentFile()` е директният метод." },
                        { "text": "getRoot()", "Sr": false, "O8": "Връща корена, което не винаги е родителят." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.nio.file.Path` връща `Path` обект, представляващ родителската директория?",
                    "hint": "Аналогичен е на `getParentFile()` в `File`.",
                    "GE": [
                        { "text": "getParent()", "Sr": true, "O8": "В NIO.2, `getParent()` връща директно `Path` обект за родителя." },
                        { "text": "getRoot()", "Sr": false, "O8": "Връща корена, не родителя." },
                        { "text": "getName(getNameCount() - 2)", "Sr": false, "O8": "Това би върнало само името на родителя, не целия път до него." },
                        { "text": "getParentPath()", "Sr": false, "O8": "Такъв метод няма." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.io.File` проверява дали файлът е скрит според конвенциите на ОС?",
                    "hint": "На UNIX това обикновено означава име, започващо с точка.",
                    "GE": [
                        { "text": "isSystem()", "Sr": false, "O8": "Няма такъв метод." },
                        { "text": "isHidden()", "Sr": true, "O8": "Това е стандартният метод за проверка дали файлът е маркиран като скрит." },
                        { "text": "isInvisible()", "Sr": false, "O8": "Няма такъв метод." },
                        { "text": "isPrivate()", "Sr": false, "O8": "Няма такъв метод." }
                    ],
                    "fS": 0
                },
                 {
                    "zBa": 0,
                    "question": "Кой метод от NIO.2 API (клас `Files`) е най-близкият аналог на `File.listFiles()` за итериране през съдържанието на директория?",
                    "hint": "Той връща `DirectoryStream`, който е `Iterable`.",
                    "GE": [
                        { "text": "Files.list(Path dir)", "Sr": false, "O8": "Този метод връща `Stream<Path>`, което е различно от `listFiles()` връщащ масив. `newDirectoryStream` е по-близък аналог." },
                        { "text": "Files.walk(Path start)", "Sr": false, "O8": "Този метод обхожда рекурсивно, докато `listFiles()` не е рекурсивен." },
                        { "text": "Files.newDirectoryStream(Path dir)", "Sr": true, "O8": "Този метод връща `DirectoryStream`, който позволява итериране през елементите на директорията, подобно на резултата от `listFiles()`." },
                        { "text": "Files.readAttributes(Path path, ...)", "Sr": false, "O8": "Този метод чете атрибути, не съдържание на директория." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.nio.file.Path` се използва за комбиниране на път с друг път (най-често относителен)?",
                    "hint": "Резултатът е нов `Path` обект.",
                    "GE": [
                        { "text": "resolve(Path other)", "Sr": true, "O8": "Това е основният метод за 'добавяне' на един път към друг." },
                        { "text": "resolveSibling(Path other)", "Sr": false, "O8": "Този метод решава `other` спрямо родителя на текущия път." },
                        { "text": "relativize(Path other)", "Sr": false, "O8": "Намира относителния път между два пътя." },
                        { "text": "concat()", "Sr": false, "O8": "Такъв метод няма." }
                    ],
                    "fS": 0
                },
                 {
                    "zBa": 0,
                    "question": "Кой метод на `java.io.File` връща името на файла или директорията като `String`?",
                    "hint": "Връща само последната част от пътя.",
                    "GE": [
                        { "text": "getPath()", "Sr": false, "O8": "Връща целия низ на пътя." },
                        { "text": "getName()", "Sr": true, "O8": "Това е методът, който връща само последното име." },
                        { "text": "toString()", "Sr": false, "O8": "Обикновено връща същото като `getPath()`." },
                        { "text": "getFileName()", "Sr": false, "O8": "Такъв метод няма в `java.io.File`." }
                    ],
                    "fS": 0
                },
                {
                    "zBa": 0,
                    "question": "Кой метод на `java.nio.file.Path` връща името на файла или директорията като `Path` обект?",
                    "hint": "Връща само последната част от пътя, но като `Path`.",
                    "GE": [
                        { "text": "getName(getNameCount() - 1)", "Sr": false, "O8": "Това би върнало последното име, но `getFileName()` е директният метод." },
                        { "text": "toString()", "Sr": false, "O8": "Връща целия път като `String`." },
                        { "text": "getFileName()", "Sr": true, "O8": "Това е методът, който връща последното име като `Path` обект." },
                        { "text": "getName()", "Sr": false, "O8": "Методът `getName(int index)` изисква индекс." }
                    ],
                    "fS": 0
                }
            ]
        };

        const questions = questionsData.Qk;
        // --- Край на данните за теста ---


        // --- Начало на JavaScript логиката ---
        // Тази логика е адаптирана от Test_lec7_easier.html

        // Променливи за състоянието на теста
        let currentQuestionIndex = 0;
        let score = 0;
        let answerSelected = false;

        // Референции към HTML елементи
        const quizContainer = document.getElementById('quiz-container');
        const resultContainer = document.getElementById('result-container');
        const questionEl = document.getElementById('question');
        const hintEl = document.getElementById('hint');
        const optionsContainer = document.getElementById('options-container');
        const feedbackEl = document.getElementById('feedback');
        const progressEl = document.getElementById('progress');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const scoreEl = document.getElementById('score');

        /**
         * Функция за стартиране на теста (или рестартиране)
         */
        function startQuiz() {
            // Разбъркване на въпросите при старт
            shuffleArray(questions);
            
            currentQuestionIndex = 0;
            score = 0;
            answerSelected = false;
            
            // Показва екрана на теста и скрива този за резултати
            quizContainer.style.display = 'block';
            resultContainer.style.display = 'none';
            
            // Зарежда първия въпрос
            loadQuestion();
        }

        /**
         * Функция за разбъркване на масив (Fisher-Yates shuffle)
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }


        /**
         * Функция за зареждане на текущия въпрос и отговори
         */
        function loadQuestion() {
            // Нулиране на състоянието от предишния въпрос
            answerSelected = false;
            feedbackEl.style.display = 'none';
            feedbackEl.innerHTML = '';
            nextBtn.style.display = 'none';

            // Вземане на данните за текущия въпрос
            const questionData = questions[currentQuestionIndex];

            // Попълване на HTML елементите
            questionEl.textContent = questionData.question;
            // Коригираме форматирането на код във въпроса
            questionEl.innerHTML = questionEl.innerHTML.replace(/`([^`]+)`/g, '<code class="bg-gray-200 px-1 rounded">$1</code>');

            hintEl.textContent = questionData.hint;
            progressEl.textContent = `Въпрос ${currentQuestionIndex + 1} от ${questions.length}`;

            // Изчистване на старите отговори
            optionsContainer.innerHTML = '';

            // Разбъркване на отговорите за текущия въпрос
            const shuffledOptions = [...questionData.GE];
            shuffleArray(shuffledOptions);

            // Създаване и добавяне на бутони за всеки възможен отговор
            shuffledOptions.forEach(option => {
                const button = document.createElement('button');
                button.textContent = option.text;
                 // Коригираме форматирането на код в отговора
                button.innerHTML = button.innerHTML.replace(/`([^`]+)`/g, '<code class="bg-gray-200 px-1 rounded">$1</code>');

                // Използваме базовия клас за стилизиране от <style>
                button.className = 'option-btn w-full text-left p-4 border border-gray-300 rounded-lg hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200';
                
                // Запазваме важна информация в data- атрибути
                button.dataset.correct = option.Sr; // 'true' или 'false'
                button.dataset.rationale = option.O8; // Обяснението

                // Добавяме event listener за клик
                button.addEventListener('click', selectAnswer);
                
                optionsContainer.appendChild(button);
            });
        }

        /**
         * Функция, която се изпълнява при избор на отговор
         */
        function selectAnswer(e) {
            // Ако вече е отговорено, не прави нищо
            if (answerSelected) return;
            answerSelected = true;

            const selectedBtn = e.target.closest('button'); // Ensure we get the button element
            if (!selectedBtn) return; // Exit if click wasn't on a button or its child

            const isCorrect = selectedBtn.dataset.correct === 'true';
            let rationale = selectedBtn.dataset.rationale;
             // Коригираме форматирането на код в обяснението
            rationale = rationale.replace(/`([^`]+)`/g, '<code class="bg-gray-200 px-1 rounded">$1</code>');


            // Проверка дали отговорът е верен и обновяване на резултата
            if (isCorrect) {
                score++;
                selectedBtn.classList.add('correct');
            } else {
                selectedBtn.classList.add('incorrect');
            }

            // Показване на обяснението
            feedbackEl.innerHTML = `<p class="font-semibold text-gray-800 mb-1">Обяснение:</p><p>${rationale}</p>`;
            feedbackEl.style.display = 'block';

            // Деактивиране на всички бутони и показване на верния отговор
            Array.from(optionsContainer.children).forEach(child => {
                child.classList.add('disabled');
                // Ако потребителят е сгрешил, показваме и верния отговор
                if (child.dataset.correct === 'true' && !isCorrect) {
                    child.classList.add('correct');
                }
            });

            // Показване на бутона "Следващ" или "Завърши"
            nextBtn.style.display = 'inline-block';
            if (currentQuestionIndex === questions.length - 1) {
                nextBtn.textContent = 'Завърши теста';
            } else {
                nextBtn.textContent = 'Следващ въпрос';
            }
        }

        /**
         * Функция за преминаване към следващ въпрос или показване на резултати
         */
        function handleNext() {
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                loadQuestion();
            } else {
                showResults();
            }
        }

        /**
         * Функция за показване на крайния резултат
         */
        function showResults() {
            quizContainer.style.display = 'none';
            resultContainer.style.display = 'block';
            
            const percentage = Math.round((score / questions.length) * 100);
            scoreEl.innerHTML = `Вашият резултат: <span class="text-blue-600">${score} от ${questions.length}</span> (${percentage}%)`;
        }

        // Добавяне на event listeners за бутоните за навигация
        nextBtn.addEventListener('click', handleNext);
        restartBtn.addEventListener('click', startQuiz);

        // При зареждане на страницата, стартираме теста
        document.addEventListener('DOMContentLoaded', startQuiz);

        // --- Край на JavaScript логиката ---
    </script>

</body>
</html>

