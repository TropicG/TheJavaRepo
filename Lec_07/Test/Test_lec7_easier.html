<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест по Java I/O</title>
    <!-- Зареждане на Tailwind CSS за стилове -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Зареждане на шрифт Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Основен шрифт за цялата страница */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Персонализирани класове за състояние на бутоните */
        .option-btn.correct {
            background-color: #d1fae5; /* Tailwind green-100 */
            border-color: #10b981; /* Tailwind green-500 */
            color: #065f46; /* Tailwind green-800 */
            font-weight: 600;
        }

        .option-btn.incorrect {
            background-color: #fee2e2; /* Tailwind red-100 */
            border-color: #ef4444; /* Tailwind red-500 */
            color: #991b1b; /* Tailwind red-800 */
            font-weight: 600;
        }

        /* Клас за деактивиране на бутоните след отговор */
        .option-btn.disabled {
            pointer-events: none;
            opacity: 0.8;
        }

        /* Скриване на елементи по подразбиране */
        #feedback,
        #next-btn,
        #result-container {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen py-10">

    <div id="app" class="max-w-2xl w-full mx-auto bg-white rounded-xl shadow-2xl overflow-hidden">
        
        <!-- Контейнер за самия тест -->
        <div id="quiz-container" class="p-6 md:p-10">
            <!-- Заглавие и прогрес -->
            <div class="mb-6">
                <h1 class="text-3xl font-bold text-center text-gray-800 mb-2">Тест по Java I/O</h1>
                <div id="progress" class="text-center text-sm font-medium text-gray-500">Въпрос 1 от 50</div>
            </div>

            <!-- Текущ въпрос -->
            <div class="mb-6">
                <h2 id="question" class="text-xl md:text-2xl font-semibold text-gray-900 leading-tight">Зареждане на въпрос...</h2>
            </div>

            <!-- Контейнер за отговорите -->
            <div id="options-container" class="flex flex-col space-y-3">
                <!-- Бутоните за отговори ще бъдат генерирани тук от JavaScript -->
            </div>

            <!-- Обратна връзка/Обяснение -->
            <div id="feedback" class="mt-6 p-4 rounded-lg bg-gray-50 border border-gray-200 text-gray-700">
                <!-- Обяснението ще бъде генерирано тук -->
            </div>

            <!-- Навигация -->
            <div id="nav-buttons" class="mt-8 text-right">
                <button id="next-btn" class="px-8 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                    Следващ въпрос
                </button>
            </div>
        </div>

        <!-- Контейнер за резултати (скрит по подразбиране) -->
        <div id="result-container" class="p-10 text-center">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">Тестът приключи!</h2>
            <div id="score" class="text-2xl font-semibold text-gray-700 mb-8">
                Вашият резултат: 0 от 50
            </div>
            <button id="restart-btn" class="px-8 py-3 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                Започни отначало
            </button>
        </div>

    </div>

    <script>
        // --- Начало на данните за теста ---
        // Данните са взети директно от предоставения JSON файл
        const questions = [
            {"zBa":0,"question":"Какво представлява \"поток\" (stream) в Java, според предоставения файл?","hint":"Текстът описва потока като фундаментална \"абстракция\" за I/O операции.","GE":[
                {"text":"Абстракция, която представлява непрекъснат поток от данни.","Sr":true,"O8":"Това е основната дефиниция, дадена в текста – абстракция за данни в движение."},
                {"text":"Процес, при който продукт се движи на конвейрна лента.","Sr":false,"O8":"Това е дефиницията за \"поточна линия\", а не за I/O поток."},
                {"text":"Мрежова връзка (Socket).","Sr":false,"O8":"Socket-ът може да бъде *източник* или *дестинация* на поток, но не е самият поток."},
                {"text":"Специален клас за работа с файлове.","Sr":false,"O8":"Потоците се използват за работа с файлове, но концепцията е по-широка и важи и за мрежи, памет и др."}
            ],"fS":0},
            {"zBa":0,"question":"Кои са двата основни вида потоци в Java, разделени според типа данни, с които работят?","hint":"Едните са за всякакъв вид данни, а другите са оптимизирани специално за текст.","GE":[
                {"text":"Входни (Input) и Изходни (Output) потоци.","Sr":false,"O8":"Това описва посоката на данните, а не типа на самите данни."},
                {"text":"Базирани на байтове (Byte Streams) и базирани на символи (Character Streams).","Sr":true,"O8":"Текстът ясно разделя потоците на тези за бинарни данни (байтове) и тези, оптимизирани за текст (символи)."},
                {"text":"Файлови (File) и Мрежови (Network) потоци.","Sr":false,"O8":"Това описва източника или дестинацията, а не основния тип на потока."},
                {"text":"Буферирани (Buffered) и Небуферирани (Unbuffered) потоци.","Sr":false,"O8":"Това е допълнителна способност (wrapping), а не основен вид."}
            ],"fS":0},
            {"zBa":0,"question":"Кои са четирите основни *абстрактни* класа в корена на I/O йерархията в Java?","hint":"Те се делят на две категории: байтови и символни.","GE":[
                {"text":"FileInputStream, FileOutputStream, FileReader, FileWriter.","Sr":false,"O8":"Това са *конкретни* класове за работа с файлове, а не базовите абстрактни класове."},
                {"text":"File, Path, Files, FileSystem.","Sr":false,"O8":"Това са класове за работа с файловата система (някои от NIO.2), а не за потоци."},
                {"text":"InputStream, OutputStream, Reader, Writer.","Sr":true,"O8":"Това са четирите основни абстрактни класа, от които произлизат всички останали потоци."},
                {"text":"ObjectInputStream, DataInputStream, BufferedReader, PrintWriter.","Sr":false,"O8":"Това са \"wrapper\" (обвиващи) потоци, които добавят функционалност, а не базовите."}
            ],"fS":0},
            {"zBa":0,"question":"За какъв тип данни са специализирани и оптимизирани Character Streams (Reader/Writer)?","hint":"Тяхната основна задача е да се справят правилно със символи и кодировки.","GE":[
                {"text":"Изображения и аудио файлове.","Sr":false,"O8":"Това са бинарни данни, за които са подходящи Byte Streams."},
                {"text":"Текстови данни (автоматично боравят с кодировки като UTF-8).","Sr":true,"O8":"Това е основната цел на Character Streams – коректна работа с текст и кодировки."},
                {"text":"Сериализирани Java обекти.","Sr":false,"O8":"За цели обекти се използват ObjectInputStream/ObjectOutputStream, които са Byte Streams."},
                {"text":"Всякакъв вид сурови (бинарни) данни.","Sr":false,"O8":"Това е описанието на Byte Streams."}
            ],"fS":0},
            {"zBa":0,"question":"Какво представлява \"wrapping\" (обвиването) на I/O потоци?","hint":"Текстът го свързва с шаблона Decorator.","GE":[
                {"text":"Процесът на затваряне на поток в try-with-resources блок.","Sr":false,"O8":"Try-with-resources управлява жизнения цикъл, но не е \"wrapping\"."},
                {"text":"Компресиране на данни преди запис, например в ZIP.","Sr":false,"O8":"Компресирането може да се постигне чрез wrapping, но самият термин означава друго."},
                {"text":"Вземане на базов поток и обвиването му в друг, за да се добави нова функционалност.","Sr":true,"O8":"Това е дефиницията на шаблона Decorator, използван в Java I/O (напр. `new BufferedInputStream(new FileInputStream(...))`)."},
                {"text":"Преобразуване на Byte stream в Character stream.","Sr":false,"O8":"Това се нарича \"мост\" (bridge stream), което е специфичен вид wrapping."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас е \"мост\" (bridge stream), който преобразува байтов поток (като `FileInputStream`) в символен поток (`Reader`)?","hint":"Името му подсказва, че е `Reader`, който чете от `InputStream`.","GE":[
                {"text":"BufferedReader","Sr":false,"O8":"Това е wrapper за добавяне на буфериране към друг Reader, а не мост от байтове."},
                {"text":"InputStreamReader","Sr":true,"O8":"Този клас е мост, който чете байтове от `InputStream` и ги декодира в символи за `Reader`."},
                {"text":"DataInputStream","Sr":false,"O8":"Това е wrapper за четене на примитивни Java типове от байтов поток."},
                {"text":"FileReader","Sr":false,"O8":"FileReader е удобен клас, който *комбинира* `FileInputStream` и `InputStreamReader`, но `InputStreamReader` е самият мост."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас е \"мост\" (bridge stream), който преобразува символен поток (`Writer`) в байтов поток (`OutputStream`)?","hint":"Името му подсказва, че е `Writer`, който пише в `OutputStream`.","GE":[
                {"text":"BufferedWriter","Sr":false,"O8":"Това е wrapper за добавяне на буфериране към друг Writer."},
                {"text":"PrintWriter","Sr":false,"O8":"Това е wrapper за лесно форматиране на текст, който обвива друг Writer."},
                {"text":"OutputStreamWriter","Sr":true,"O8":"Този клас е мост, който приема символи и ги енкодира в байтове, за да ги запише в `OutputStream`."},
                {"text":"DataOutputStream","Sr":false,"O8":"Това е wrapper за запис на примитивни Java типове в байтов поток."}
            ],"fS":0},
            {"zBa":0,"question":"Защо, според текста, байтовите потоци се провалят при обработка на кирилица?","hint":"Проблемът е свързан с размера на символите в Unicode (напр. 'С' е 11 бита) спрямо единицата за четене на байтовия поток (8 бита).","GE":[
                {"text":"Кирилицата използва различна файлова система.","Sr":false,"O8":"Файловата система не е свързана с начина, по който се четат данните."},
                {"text":"Символи от кирилицата често изискват повече от 8 бита (1 байт) за запис.","Sr":true,"O8":"Текстът дава пример със 'С' (11 бита), което байтов поток (четящ по 8 бита) не може да обработи коректно."},
                {"text":"Байтовите потоци са само за изображения.","Sr":false,"O8":"Те са за всякакви бинарни данни, включително текст, но не се справят добре с многобайтови кодировки."},
                {"text":"Трябва да се използва `System.in` за кирилица.","Sr":false,"O8":"`System.in` е байтов поток и сам по себе си има същия проблем; трябва да се обвие в `InputStreamReader`."}
            ],"fS":0},
            {"zBa":0,"question":"Кой метод на `InputStream` чете един байт и го връща като `int` (0-255), или връща -1 при край на потока?","hint":"Това е най-основният метод за четене, описан в текста.","GE":[
                {"text":"read(byte[] b)","Sr":false,"O8":"Този метод чете множество байтове в масив и връща броя прочетени байтове."},
                {"text":"available()","Sr":false,"O8":"Този метод връща приблизителния брой байтове, достъпни за четене."},
                {"text":"read()","Sr":true,"O8":"Това е основният абстрактен метод за четене на един байт."},
                {"text":"skip(long n)","Sr":false,"O8":"Този метод пропуска `n` на брой байта."}
            ],"fS":0},
            {"zBa":0,"question":"Какво прави методът `flush()` на `OutputStream`?","hint":"Този метод е важен, когато се използват буферирани потоци, за да се гарантира, че данните са записани.","GE":[
                {"text":"Затваря потока и освобождава ресурсите.","Sr":false,"O8":"Това се прави от метода `close()`."},
                {"text":"Изтрива всички данни от потока.","Sr":false,"O8":"Потоците не се \"изтриват\" по този начин; `flush` е за запис."},
                {"text":"Принуждава всички буферирани данни да бъдат записани веднага в дестинацията.","Sr":true,"O8":"Това гарантира, че данните, чакащи в паметта (буфера), се изпращат към файла или мрежата."},
                {"text":"Прочита последния записан байт.","Sr":false,"O8":"Това е изходен поток, той пише, а не чете."}
            ],"fS":0},
            {"zBa":0,"question":"Как ще създадете `FileOutputStream`, за да добавите данни в края на файл, без да триете старото съдържание?","hint":"Текстът описва два режима: Append и Overwrite, които се контролират от втори, булев параметър на конструктора.","GE":[
                {"text":"new FileOutputStream(\"file.txt\")","Sr":false,"O8":"Този конструктор (или с `false`) изтрива (overwrite) съдържанието на файла."},
                {"text":"new FileOutputStream(\"file.txt\", true)","Sr":true,"O8":"Вторият аргумент `true` указва режим 'append' (добавяне)."},
                {"text":"new FileOutputStream(\"file.txt\", false)","Sr":false,"O8":"Аргументът `false` изрично указва режим 'overwrite' (презаписване)."},
                {"text":"new FileOutputStream.append(\"file.txt\")","Sr":false,"O8":"Не съществува такъв статичен метод; режимът се задава в конструктора."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас `Reader` добавя буфериране и позволява четене на текст ред по ред (чрез `readLine()`)?","hint":"Това е \"обвиващ\" (wrapper) `Reader`, който повишава скоростта.","GE":[
                {"text":"FileReader","Sr":false,"O8":"Това е удобен клас за четене на символи от файл, но сам по себе си не предлага `readLine()`."},
                {"text":"InputStreamReader","Sr":false,"O8":"Това е мост от байтове към символи, но не буферира и няма `readLine()`."},
                {"text":"StringReader","Sr":false,"O8":"Този клас чете от `String` в паметта, но не е предназначен за буфериране на други потоци."},
                {"text":"BufferedReader","Sr":true,"O8":"Това е wrapper, който добавя буфер и предоставя удобния метод `readLine()`."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас `Writer` добавя удобни методи за форматиране като `println()` и `printf()`?","hint":"Името му подсказва, че е предназначен за \"принтиране\" (print) на форматиран текст.","GE":[
                {"text":"BufferedWriter","Sr":false,"O8":"Той добавя буфериране (и `newLine()`), но не и `printf()`."},
                {"text":"OutputStreamWriter","Sr":false,"O8":"Това е мост от символи към байтове, не предоставя форматиращи методи."},
                {"text":"PrintWriter","Sr":true,"O8":"Това е wrapper, чиято основна цел е да предостави лесни методи за форматиран текстов изход."},
                {"text":"StringWriter","Sr":false,"O8":"Този клас пише в `String` в паметта, но няма `printf()`."}
            ],"fS":0},
            {"zBa":0,"question":"Какво е `java.io.Serializable`?","hint":"Текстът описва, че този интерфейс \"не съдържа никакви методи\" и целта му е да \"указва\" нещо.","GE":[
                {"text":"Клас за записване на обекти във файлове.","Sr":false,"O8":"Това е описание на `ObjectOutputStream`, който *изисква* обектите да имплементират `Serializable`."},
                {"text":"Маркерен интерфейс, който не съдържа методи.","Sr":true,"O8":"Това е точната дефиниция; той само \"маркира\" класа като подходящ за сериализация."},
                {"text":"Абстрактен клас за криптиране на потоци.","Sr":false,"O8":"Криптирането се извършва от `CipherOutputStream`, което е съвсем различно."},
                {"text":"Метод за преобразуване на обект в JSON.","Sr":false,"O8":"Сериализацията превръща обект в байтове, не задължително в JSON."}
            ],"fS":0},
            {"zBa":0,"question":"Какво е \"десериализация\"?","hint":"Това е обратният процес на сериализацията.","GE":[
                {"text":"Процесът на конвертиране на обект в последователност от байтове.","Sr":false,"O8":"Това е \"сериализация\" (записване)."},
                {"text":"Процесът на пресъздаване на обект в паметта от последователност от байтове.","Sr":true,"O8":"Това е \"десериализация\" (четене), обратният процес на сериализацията."},
                {"text":"Процесът на заключване на файл, за да не се променя.","Sr":false,"O8":"Заключването на файлове е отделна концепция."},
                {"text":"Процесът на проверка на свободно дисково пространство.","Sr":false,"O8":"Това се прави с `FileStore`, а не с десериализация."}
            ],"fS":0},
            {"zBa":0,"question":"Кой е модерният и по-безопасен начин за работа с ресурси (потоци) в Java, който гарантира автоматичното им затваряне?","hint":"Тази конструкция позволява деклариране на ресурса в скобите на `try`.","GE":[
                {"text":"Извикване на `System.gc()` след употреба.","Sr":false,"O8":"Garbage Collector-ът не управлява затварянето на I/O ресурси надеждно."},
                {"text":"Блок `try-catch-finally`, като `close()` се вика във `finally`.","Sr":false,"O8":"Това беше старият начин, но `try-with-resources` е по-модерният и по-безопасен."},
                {"text":"Блок `try-with-resources`.","Sr":true,"O8":"Текстът описва това като модерен начин, който гарантира автоматичното извикване на `close()`."},
                {"text":"Използване на `java.util.Scanner`.","Sr":false,"O8":"`Scanner` също е ресурс, който трябва да бъде затворен, идеално с `try-with-resources`."}
            ],"fS":0},
            {"zBa":0,"question":"Какъв проблем се избягва чрез използването на `try-with-resources`?","hint":"Проблемът възниква, когато грешка попречи на програмата да стигне до `close()`.","GE":[
                {"text":"Бавна скорост на четене.","Sr":false,"O8":"Скоростта се подобрява с буфериране, а не с `try-with-resources`."},
                {"text":"Грешки при обработка на кирилица.","Sr":false,"O8":"Това се решава с `Character Streams`, а не с `try-with-resources`."},
                {"text":"\"Изтичане на ресурси\" (resource leak), ако възникне грешка преди `close()`.","Sr":true,"O8":"Текстът описва, че ако програмата крашне, потокът остава отворен; `try-with-resources` решава това."},
                {"text":"Невъзможност за запис във файл.","Sr":false,"O8":"Това е проблем с права или `FileOutputStream`, а не с управлението на ресурси."}
            ],"fS":0},
            {"zBa":0,"question":"Кой е правилният, крос-платформен начин да се добави нов ред при писане в текстов файл в Java?","hint":"Различните ОС (Windows, Linux) използват различни символи за край на ред.","GE":[
                {"text":"Винаги да се пише `\"\\n\"`.","Sr":false,"O8":"Това работи за UNIX/Linux, но не е правилният разделител за Windows."},
                {"text":"Винаги да се пише `\"\\r\\n\"`.","Sr":false,"O8":"Това е правилно за Windows, но не и за UNIX/Linux."},
                {"text":"Да се използва `System.lineSeparator()` или `PrintWriter.println()`.","Sr":true,"O8":"Текстът изрично препоръчва тези методи, тъй като те автоматично използват правилния разделител за текущата ОС."},
                {"text":"Да се използва `\"\\t\"`.","Sr":false,"O8":"Това е символ за табулация, а не за нов ред."}
            ],"fS":0},
            {"zBa":0,"question":"Кой от трите стандартни потока се използва по подразбиране за четене на данни от клавиатурата?","hint":"Това е стандартният *вход*.","GE":[
                {"text":"System.in","Sr":true,"O8":"Това е стандартният вход, свързан с клавиатурата."},
                {"text":"System.out","Sr":false,"O8":"Това е стандартният изход за нормални съобщения (към екрана)."},
                {"text":"System.err","Sr":false,"O8":"Това е стандартният изход за съобщения за грешки (към екрана)."},
                {"text":"System.keyboard","Sr":false,"O8":"Такъв стандартен поток не съществува."}
            ],"fS":0},
            {"zBa":0,"question":"За какво служи класът `java.util.Scanner`?","hint":"Този клас има методи като `nextInt()` и `next()`.","GE":[
                {"text":"За сканиране на файловата система за вируси.","Sr":false,"O8":"Това е извън обхвата на Java I/O."},
                {"text":"За лесно четене и парсване на данни от потребителя (напр. от `System.in`).","Sr":true,"O8":"Текстът го описва като най-лесния начин за четене от клавиатурата (`scanner.nextInt()`, `scanner.next()`)."},
                {"text":"За форматиране на текст и числа за изход.","Sr":false,"O8":"Това е работата на `java.util.Formatter`."},
                {"text":"За криптиране на потоци.","Sr":false,"O8":"Това се прави от `CipherInputStream`."}
            ],"fS":0},
            {"zBa":0,"question":"Кой е модерният Java API (NIO.2) за работа с файловата система?","hint":"Името му означава Non-blocking I/O, версия 2.","GE":[
                {"text":"Пакетът `java.io`.","Sr":false,"O8":"Това е старият, блокиращ I/O API."},
                {"text":"Пакетът `java.nio.file`.","Sr":true,"O8":"Текстът описва NIO.2 и този пакет като модерния API."},
                {"text":"Пакетът `java.util.zip`.","Sr":false,"O8":"Този пакет е за работа със ZIP архиви."},
                {"text":"Пакетът `javax.crypto`.","Sr":false,"O8":"Този пакет е за криптиране."}
            ],"fS":0},
            {"zBa":0,"question":"Кой *интерфейс* в `java.nio.file` представлява адрес (път) във файловата система?","hint":"Името му буквално означава \"път\".","GE":[
                {"text":"Files","Sr":false,"O8":"Това е помощен *клас* със статични методи, а не интерфейс за адрес."},
                {"text":"File","Sr":false,"O8":"Това е *клас* от стария `java.io` API."},
                {"text":"Path","Sr":true,"O8":"Това е основният интерфейс в NIO.2, който представлява път до файл или директория."},
                {"text":"FileSystem","Sr":false,"O8":"Това представлява цялата файлова система, а не конкретен адрес."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас в `java.nio.file` е помощен и пълен със *статични методи* за операции с файлове (като копиране, триене, четене)?","hint":"Този клас е в множествено число и се използва заедно с `Path`.","GE":[
                {"text":"Path","Sr":false,"O8":"Това е интерфейс, който представлява път, а не клас със статични методи."},
                {"text":"Files","Sr":true,"O8":"Това е помощният клас (utility class) с методи като `Files.copy()`, `Files.delete()`."},
                {"text":"File","Sr":false,"O8":"Това е клас от стария API; операциите са негови инстанционни методи (`file.delete()`), а не статични."},
                {"text":"FileSystems","Sr":false,"O8":"Този клас се използва за достъп до `FileSystem`, а не за общи операции с файлове."}
            ],"fS":0},
            {"zBa":0,"question":"Какъв е проблемът с ръчното изписване на `C:\\temp\\file.txt` в Java код?","hint":"Текстът обсъжда различните разделители (separators) в Windows и Linux.","GE":[
                {"text":"Няма проблем, това е правилният начин.","Sr":false,"O8":"Това е проблем, тъй като кодът няма да работи на Linux или macOS."},
                {"text":"Кодът няма да работи на Linux/macOS, които използват `/` като разделител.","Sr":true,"O8":"Това е проблем за крос-платформената съвместимост; трябва да се ползва `File.separator` или `Path`."},
                {"text":"Трябва да се изпише `C://temp//file.txt`.","Sr":false,"O8":"Двойната наклонена черта (в тази посока) не решава проблема с крос-платформеността."},
                {"text":"Файлове не могат да се записват в `temp` директорията.","Sr":false,"O8":"Проблемът е в разделителя (`\\`), а не в името на директорията."}
            ],"fS":0},
            {"zBa":0,"question":"В шаблоните за търсене (glob), какво означава символът `*`?","hint":"Използва се за намиране на всички файлове с определено разширение, напр. `*.java`.","GE":[
                {"text":"Точно един символ.","Sr":false,"O8":"Това се означава с `?`."},
                {"text":"Произволен брой символи, включително нула, *в рамките на едно име*.","Sr":true,"O8":"Това е точната дефиниция (напр. `*.txt` намира `File.txt`, но не и `dir/File.txt`)."},
                {"text":"Произволен брой символи, *рекурсивно* през директории.","Sr":false,"O8":"Това се означава с `**`."},
                {"text":"Един от символите в списък, напр. `[abc]`.","Sr":false,"O8":"Това е различен синтаксис."}
            ],"fS":0},
            {"zBa":0,"question":"В шаблоните за търсене (glob), какво означава `**`?","hint":"Този шаблон се използва за търсене в *поддиректории*.","GE":[
                {"text":"Замества точно два символа.","Sr":false,"O8":"Това не е вярно; `??` би заместило два символа."},
                {"text":"Рекурсивно търсене през директории.","Sr":true,"O8":"Това е точната дефиниция (напр. `**/*.java` намира всички Java файлове във всички поддиректории)."},
                {"text":"Замества произволен брой символи само в името на файла.","Sr":false,"O8":"Това се означава с `*`."},
                {"text":"Търси файлове, започващи със `*`.","Sr":false,"O8":"Това е специален символ (wildcard), а не буквален."}
            ],"fS":0},
            {"zBa":0,"question":"В шаблоните за търсене (glob), какво означава `?`?","hint":"Използва се, когато знаете точния брой липсващи символи.","GE":[
                {"text":"Замества точно един знак.","Sr":true,"O8":"Това е точната дефиниция (напр. `File?.txt` ще намери `File1.txt`, но не и `File10.txt`)."},
                {"text":"Замества нула или повече знаци.","Sr":false,"O8":"Това се означава с `*`."},
                {"text":"Означава, че търсенето е опционално.","Sr":false,"O8":"Това не е значението му в glob шаблоните."},
                {"text":"Търси файлове, съдържащи въпросителен знак.","Sr":false,"O8":"Това е специален символ (wildcard)."}
            ],"fS":0},
            {"zBa":0,"question":"Кои класове в `javax.crypto` се използват за автоматично криптиране/декриптиране на данни по време на писане/четене?","hint":"Имената им съдържат `Cipher`, което е термин за алгоритъм за криптиране.","GE":[
                {"text":"ZipInputStream и ZipOutputStream.","Sr":false,"O8":"Те са за ZIP архиви, не за криптиране."},
                {"text":"CipherInputStream и CipherOutputStream.","Sr":true,"O8":"Това са потоците, които обвиват други потоци и прилагат `Cipher` (алгоритъм) върху данните."},
                {"text":"DataInputStream и DataOutputStream.","Sr":false,"O8":"Те са за примитивни типове данни, не за криптиране."},
                {"text":"ObjectInputStream и ObjectOutputStream.","Sr":false,"O8":"Те са за сериализация на обекти, не за криптиране."}
            ],"fS":0},
            {"zBa":0,"question":"В кой пакет се намират класовете за работа със ZIP архиви в Java?","hint":"Името на пакета съдържа \"zip\".","GE":[
                {"text":"java.io","Sr":false,"O8":"Това е основният I/O пакет, но ZIP класовете са в `java.util`."},
                {"text":"java.nio.file","Sr":false,"O8":"Това е модерният API за файлова система, но не съдържа ZIP потоците."},
                {"text":"java.util.zip","Sr":true,"O8":"Това е пакетът, съдържащ `ZipFile`, `ZipEntry`, `ZipInputStream` и `ZipOutputStream`."},
                {"text":"javax.crypto","Sr":false,"O8":"Това е пакетът за криптиране."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас представлява *един* елемент (файл или директория) *вътре* в ZIP архив?","hint":"Името му означава \"запис\" или \"елемент\" в ZIP.","GE":[
                {"text":"ZipFile","Sr":false,"O8":"Това представлява самия ZIP архив (целия файл)."},
                {"text":"ZipInputStream","Sr":false,"O8":"Това е поток за четене на съдържанието на архива, елемент по елемент."},
                {"text":"Path","Sr":false,"O8":"Това е за пътища във файловата система, а не вътре в ZIP."},
                {"text":"ZipEntry","Sr":true,"O8":"Това е класът, който описва един запис (entry) в ZIP файла."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас се използва за *създаване* на ZIP архив (записване на файлове в него)?","hint":"Трябва ви *изходен* (Output) поток.","GE":[
                {"text":"ZipFile","Sr":false,"O8":"Този клас се използва главно за четене на съществуващ ZIP архив."},
                {"text":"ZipInputStream","Sr":false,"O8":"Това е поток за четене (Input) от ZIP архив."},
                {"text":"ZipOutputStream","Sr":true,"O8":"Това е поток за запис (Output), който се използва за създаване на ZIP."},
                {"text":"ZipEntry","Sr":false,"O8":"Това описва елемент, но не извършва самото записване."}
            ],"fS":0},
            {"zBa":0,"question":"Атомарната единица за работа при `ByteStream` е 1 байт (8 бита). Каква е атомарната единица при `CharacterStream`?","hint":"Тези потоци са създадени да работят със *символи*, а не с байтове.","GE":[
                {"text":"1 бит.","Sr":false,"O8":"Нито един от потоците не работи на ниво бит."},
                {"text":"1 символ (представен в Java като 2 байта/16 бита).","Sr":true,"O8":"Текстът посочва, че `CharacterStream` работи символ по символ (16 бита)."},
                {"text":"4 байта (32 бита).","Sr":false,"O8":"Това е размерът на `int`, но не и атомарната единица за четене на `CharacterStream`."},
                {"text":"1 ред текст.","Sr":false,"O8":"Четенето на ред е възможност, предоставена от `BufferedReader`, а не атомарната единица на `Reader`."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас `Writer` се използва за писане директно в `String` в паметта?","hint":"Текстът го споменава заедно със `StringReader` като \"Потоци към паметта\".","GE":[
                {"text":"StringWriter","Sr":true,"O8":"Този клас събира изхода в `String` (или `StringBuffer`)."},
                {"text":"PrintWriter","Sr":false,"O8":"Той форматира текст, но обикновено пише към друг `Writer` (напр. `FileWriter`), а не директно в `String`."},
                {"text":"CharArrayWriter","Sr":false,"O8":"Този клас пише в масив от символи (`char[]`), което е близко, но `StringWriter` е за `String`."},
                {"text":"BufferedWriter","Sr":false,"O8":"Той буферира писането към друг `Writer`, а не пише в `String`."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас `Reader` се използва за четене директно от `char[]` (масив от символи) в паметта?","hint":"Текстът го споменава заедно с `CharArrayWriter` като \"Потоци към паметта\".","GE":[
                {"text":"StringReader","Sr":false,"O8":"Този клас чете от `String` обект."},
                {"text":"BufferedReader","Sr":false,"O8":"Той буферира четенето от друг `Reader`."},
                {"text":"CharArrayReader","Sr":true,"O8":"Името му показва, че чете от `char` масив (Array)."},
                {"text":"InputStreamReader","Sr":false,"O8":"Това е мост от `InputStream` (байтове), а не от `char` масив."}
            ],"fS":0},
            {"zBa":0,"question":"Кой е третият етап от жизнения цикъл на потоците, описан като \"много важна стъпка\"?","hint":"Тази стъпка освобождава заетите ресурси.","GE":[
                {"text":"Създаване (Отваряне).","Sr":false,"O8":"Това е първата стъпка."},
                {"text":"Използване (Четене/Писане).","Sr":false,"O8":"Това е втората стъпка."},
                {"text":"Затваряне (Close).","Sr":true,"O8":"Текстът описва затварянето като много важно за освобождаване на ресурси и запис на данни."},
                {"text":"Буфериране (Buffering).","Sr":false,"O8":"Буферирането е опционална функционалност, а не етап от жизнения цикъл."}
            ],"fS":0},
            {"zBa":0,"question":"Ако обвиете `FileInputStream` в `DataInputStream`, какво се случва, когато извикате `.close()` на `DataInputStream`?","hint":"Това е част от удобството на шаблона Decorator (wrapping).","GE":[
                {"text":"Само `DataInputStream` се затваря, `FileInputStream` остава отворен.","Sr":false,"O8":"Това би довело до изтичане на ресурси; обвиващият поток е отговорен за вътрешния."},
                {"text":"Външният поток (`DataInputStream`) автоматично затваря и вътрешния (`FileInputStream`).","Sr":true,"O8":"Това е правилото при \"wrapping\" – затварянето се делегира навътре."},
                {"text":"Трябва ръчно да затворите и двата потока.","Sr":false,"O8":"Това не е необходимо и е лоша практика, ако се използва `try-with-resources`."},
                {"text":"Ще възникне грешка, защото `FileInputStream` не може да бъде затворен така.","Sr":false,"O8":"Това е стандартният начин на работа."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас се използва за четене/писане на цели Java обекти (сериализация)?","hint":"Текстът ги споменава в категорията \"Objects\".","GE":[
                {"text":"DataInputStream / DataOutputStream","Sr":false,"O8":"Те са за примитивни типове (int, float, long), а не за цели обекти."},
                {"text":"ObjectInputStream / ObjectOutputStream","Sr":true,"O8":"Имената им ясно показват, че са предназначени за работа с `Object`."},
                {"text":"BufferedReader / BufferedWriter","Sr":false,"O8":"Те са за текст (символи), а не за сериализирани обекти."},
                {"text":"FileInputStream / FileOutputStream","Sr":false,"O8":"Те са базови потоци за байтове; `ObjectOutputStream` ги *обвива*, за да запише обекти във файл."}
            ],"fS":0},
            {"zBa":0,"question":"Кой метод на `InputStream` чете `len` на брой байта и ги записва в масив `b`, започвайки от позиция `off`?","hint":"Търсим метода с три параметъра: масив, отместване (offset) и дължина (length).","GE":[
                {"text":"read()","Sr":false,"O8":"Чете само един байт."},
                {"text":"read(byte[] b)","Sr":false,"O8":"Опитва да напълни целия масив `b`, започвайки от позиция 0."},
                {"text":"read(byte[] b, int off, int len)","Sr":true,"O8":"Това е точният подпис на метода, описан в текста."},
                {"text":"readAllBytes()","Sr":false,"O8":"Чете *всички* оставащи байтове, а не `len` на брой."}
            ],"fS":0},
            {"zBa":0,"question":"Кой метод на `OutputStream` записва `len` на брой байта от масив `b`, започвайки от позиция `off`?","hint":"Подобно на `read`, търсим метода с трите параметъра: масив, отместване и дължина.","GE":[
                {"text":"write(int b)","Sr":false,"O8":"Записва само един байт."},
                {"text":"write(byte[] b, int off, int len)","Sr":true,"O8":"Това е точният подпис на метода, описан в текста."},
                {"text":"write(byte[] b)","Sr":false,"O8":"Записва целия масив `b`."},
                {"text":"flush()","Sr":false,"O8":"Изпразва буфера, а не записва нови данни от масив."}
            ],"fS":0},
            {"zBa":0,"question":"Кой метод на `InputStream` връща *приблизителния* брой байтове, които могат да бъдат прочетени веднага?","hint":"Името му подсказва, че проверява какво е \"налично\" (available).","GE":[
                {"text":"readAllBytes()","Sr":false,"O8":"Този метод *чете* всички байтове, а не връща бройка."},
                {"text":"available()","Sr":true,"O8":"Това е точната дефиниция на този метод."},
                {"text":"skip(long n)","Sr":false,"O8":"Този метод *пропуска* байтове."},
                {"text":"read()","Sr":false,"O8":"Този метод *чете* един байт."}
            ],"fS":0},
            {"zBa":0,"question":"Кой метод на `java.io.Reader` чете един-единствен символ и го връща като `int` (0-65535)?","hint":"Това е най-основният метод за четене на `Reader`.","GE":[
                {"text":"read(char[] cbuf)","Sr":false,"O8":"Чете в масив от символи."},
                {"text":"read()","Sr":true,"O8":"Това е основният метод за четене на един символ, аналог на `InputStream.read()`."},
                {"text":"ready()","Sr":false,"O8":"Проверява дали четенето е възможно, но не чете."},
                {"text":"skip(long n)","Sr":false,"O8":"Пропуска `n` на брой символи."}
            ],"fS":0},
            {"zBa":0,"question":"Кой метод на `java.io.Writer` записва цял `String` в потока?","hint":"Този метод приема `String` като аргумент.","GE":[
                {"text":"write(char[] cbuf)","Sr":false,"O8":"Записва масив от символи."},
                {"text":"write(String str)","Sr":true,"O8":"Това е удобен метод, специфичен за `Writer`, за запис на низове."},
                {"text":"write(int c)","Sr":false,"O8":"Този метод (взет от `OutputStream.write(int b)`) записва един символ, подаден като `int`."},
                {"text":"flush()","Sr":false,"O8":"Изпразва буфера, а не записва низ."}
            ],"fS":0},
            {"zBa":0,"question":"Кой от стандартните потоци се използва специално за писане на съобщения за грешки?","hint":"Името му идва от \"Error\".","GE":[
                {"text":"System.in","Sr":false,"O8":"Това е за вход."},
                {"text":"System.out","Sr":false,"O8":"Това е за нормален изход."},
                {"text":"System.err","Sr":true,"O8":"Това е стандартният изход за грешки (Error)."},
                {"text":"System.log","Sr":false,"O8":"Такъв стандартен поток не съществува."}
            ],"fS":0},
            {"zBa":0,"question":"За какво служи класът `java.util.Formatter`?","hint":"Този клас е свързан с `printf()`.","GE":[
                {"text":"За четене на форматирани данни от потребителя.","Sr":false,"O8":"Това е работата на `Scanner`."},
                {"text":"За подпомагане на форматирането на текст и числа при изход.","Sr":true,"O8":"Това е неговата основна цел, подобно на `printf()`."},
                {"text":"За форматиране на твърдия диск.","Sr":false,"O8":"Това е съвсем различна операция извън Java I/O."},
                {"text":"За компресиране на данни.","Sr":false,"O8":"Това се прави от `ZipOutputStream`."}
            ],"fS":0},
            {"zBa":0,"question":"Кой е правилният, крос-платформен начин да се вземе разделителят за път (path separator)?","hint":"Търсим разделителя за пътища (paths), а не за редове (lines).","GE":[
                {"text":"Винаги да се използва `\"/\"`.","Sr":false,"O8":"Това работи на Linux/macOS, но не е гарантирано за всички операции на Windows."},
                {"text":"Винаги да се използва `\"\\\\\"` (екранирано).","Sr":false,"O8":"Това работи само на Windows."},
                {"text":"Да се използва `File.separator` или `FileSystem.getSeparator()`.","Sr":true,"O8":"Текстът препоръчва тези начини за получаване на правилния разделител (`\\` или `/`) за текущата ОС."},
                {"text":"Да се използва `System.lineSeparator()`.","Sr":false,"O8":"Това е за *нов ред* в текстов файл, а не за *разделител* в път до файл."}
            ],"fS":0},
            {"zBa":0,"question":"В шаблоните за търсене (glob), какво означава `*.{java,txt}`?","hint":"Скобите `{}` се използват за изброяване на няколко възможни съвпадения.","GE":[
                {"text":"Намира файлове, които се казват `java` или `txt`.","Sr":false,"O8":"Това търси файлове, които *завършват* на `.java` или `.txt`."},
                {"text":"Намира файлове, чието име е `*` и разширението е `java` или `txt`.","Sr":true,"O8":"`*` замества произволен брой символи, а `{}` дава списък с опции."},
                {"text":"Намира файлове, съдържащи `{java,txt}` в името си.","Sr":false,"O8":"Скобите `{}` имат специално значение в glob шаблоните."},
                {"text":"Това е невалиден шаблон.","Sr":false,"O8":"Това е валиден шаблон за заместване на под-шаблони."}
            ],"fS":0},
            {"zBa":0,"question":"Кои класове в `java.nio.file` се използват за проверка на свободното дисково пространство?","hint":"Текстът споменава, че Java предоставя ОС-независимо API за това чрез тези класове.","GE":[
                {"text":"FileSystems и FileStore","Sr":true,"O8":"Текстът описва, че `FileSystems` дава достъп до `FileStore`, който съдържа информация за дисковия дял."},
                {"text":"Path и Files","Sr":false,"O8":"Те са за операции с файлове, а не за информация за диска."},
                {"text":"File.getFreeSpace()","Sr":false,"O8":"Това е метод от стария `java.io.File` API; текстът се фокусира върху `java.nio.file`."},
                {"text":"Scanner и Formatter","Sr":false,"O8":"Те са за четене и писане на форматирани данни."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас `InputStream` се използва за четене на примитивни Java типове (като `int`, `float`, `long`)?","hint":"Текстът го споменава в категорията \"Data\".","GE":[
                {"text":"DataInputStream","Sr":true,"O8":"Този wrapper е специализиран за четене на \"Data\" (примитивни типове)."},
                {"text":"ObjectInputStream","Sr":false,"O8":"Той е за цели обекти, не за примитиви."},
                {"text":"BufferedReader","Sr":false,"O8":"Той е за текст (символи), не за бинарни примитиви."},
                {"text":"FileInputStream","Sr":false,"O8":"Той чете сурови байтове; `DataInputStream` го обвива, за да интерпретира тези байтове като `int` или `float`."}
            ],"fS":0},
            {"zBa":0,"question":"Кой клас `OutputStream` се използва за запис на примитивни Java типове (като `int`, `float`, `long`)?","hint":"Текстът го споменава в категорията \"Data\".","GE":[
                {"text":"DataOutputStream","Sr":true,"O8":"Този wrapper е специализиран за запис на \"Data\" (примитивни типове)."},
                {"text":"ObjectOutputStream","Sr":false,"O8":"Той е за цели обекти, не за примитиви."},
                {"text":"PrintWriter","Sr":false,"O8":"Той записва примитиви, но като *текст* (напр. числото 123 като символите '1', '2', '3'), а не като бинарни данни."},
                {"text":"FileOutputStream","Sr":false,"O8":"Той записва сурови байтове; `DataOutputStream` го обвива, за да конвертира `int` или `float` в байтове."}
            ],"fS":0},
            {"zBa":0,"question":"Какъв тип потоци (Byte или Character) са `System.in`, `System.out` и `System.err`?","hint":"`System.in` е `InputStream`. `System.out` и `System.err` са `PrintStream`. Проверете какво наследява `PrintStream`.","GE":[
                {"text":"`System.in` е Byte, а `System.out`/`System.err` са Character.","Sr":false,"O8":"`System.out` и `System.err` са `PrintStream`, който е `OutputStream` (Byte Stream), макар и да работи лесно с текст."},
                {"text":"Всички са Character Streams (Reader/Writer).","Sr":false,"O8":"Те са `InputStream` и `PrintStream` (който е `OutputStream`), следователно са Byte Streams."},
                {"text":"Всички са Byte Streams (InputStream/OutputStream).","Sr":true,"O8":"`System.in` е `InputStream`. `System.out` и `System.err` са `PrintStream`, който наследява `OutputStream`. Всички са байтови."},
                {"text":"`System.in` и `System.out` са Byte, `System.err` е Character.","Sr":false,"O8":"И трите са базирани на байтови потоци."}
            ],"fS":0}
        ];
        // --- Край на данните за теста ---


        // --- Начало на JavaScript логиката ---

        // Променливи за състоянието на теста
        let currentQuestionIndex = 0;
        let score = 0;
        let answerSelected = false;

        // Референции към HTML елементи
        const quizContainer = document.getElementById('quiz-container');
        const resultContainer = document.getElementById('result-container');
        const questionEl = document.getElementById('question');
        const optionsContainer = document.getElementById('options-container');
        const feedbackEl = document.getElementById('feedback');
        const progressEl = document.getElementById('progress');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const scoreEl = document.getElementById('score');

        /**
         * Функция за стартиране на теста (или рестартиране)
         */
        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            answerSelected = false;
            
            // Показва екрана на теста и скрива този за резултати
            quizContainer.style.display = 'block';
            resultContainer.style.display = 'none';
            
            // Зарежда първия въпрос
            loadQuestion();
        }

        /**
         * Функция за зареждане на текущия въпрос и отговори
         */
        function loadQuestion() {
            // Нулиране на състоянието от предишния въпрос
            answerSelected = false;
            feedbackEl.style.display = 'none';
            feedbackEl.innerHTML = '';
            nextBtn.style.display = 'none';

            // Вземане на данните за текущия въпрос
            const questionData = questions[currentQuestionIndex];

            // Попълване на HTML елементите
            questionEl.textContent = questionData.question;
            progressEl.textContent = `Въпрос ${currentQuestionIndex + 1} от ${questions.length}`;

            // Изчистване на старите отговори
            optionsContainer.innerHTML = '';

            // Създаване и добавяне на бутони за всеки възможен отговор
            questionData.GE.forEach(option => {
                const button = document.createElement('button');
                button.textContent = option.text;
                // Използваме базовия клас за стилизиране от <style>
                button.className = 'option-btn w-full text-left p-4 border border-gray-300 rounded-lg hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200';
                
                // Запазваме важна информация в data- атрибути
                button.dataset.correct = option.Sr; // 'true' или 'false'
                button.dataset.rationale = option.O8; // Обяснението

                // Добавяме event listener за клик
                button.addEventListener('click', selectAnswer);
                
                optionsContainer.appendChild(button);
            });
        }

        /**
         * Функция, която се изпълнява при избор на отговор
         */
        function selectAnswer(e) {
            // Ако вече е отговорено, не прави нищо
            if (answerSelected) return;
            answerSelected = true;

            const selectedBtn = e.target;
            const isCorrect = selectedBtn.dataset.correct === 'true';
            const rationale = selectedBtn.dataset.rationale;

            // Проверка дали отговорът е верен и обновяване на резултата
            if (isCorrect) {
                score++;
                selectedBtn.classList.add('correct');
            } else {
                selectedBtn.classList.add('incorrect');
            }

            // Показване на обяснението
            feedbackEl.innerHTML = `<p class="font-semibold text-gray-800 mb-1">Обяснение:</p><p>${rationale}</p>`;
            feedbackEl.style.display = 'block';

            // Деактивиране на всички бутони и показване на верния отговор
            Array.from(optionsContainer.children).forEach(child => {
                child.classList.add('disabled');
                // Ако потребителят е сгрешил, показваме и верния отговор
                if (child.dataset.correct === 'true' && !isCorrect) {
                    child.classList.add('correct');
                }
            });

            // Показване на бутона "Следващ" или "Завърши"
            nextBtn.style.display = 'inline-block';
            if (currentQuestionIndex === questions.length - 1) {
                nextBtn.textContent = 'Завърши теста';
            } else {
                nextBtn.textContent = 'Следващ въпрос';
            }
        }

        /**
         * Функция за преминаване към следващ въпрос или показване на резултати
         */
        function handleNext() {
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) {
                loadQuestion();
            } else {
                showResults();
            }
        }

        /**
         * Функция за показване на крайния резултат
         */
        function showResults() {
            quizContainer.style.display = 'none';
            resultContainer.style.display = 'block';
            
            const percentage = Math.round((score / questions.length) * 100);
            scoreEl.innerHTML = `Вашият резултат: <span class="text-blue-600">${score} от ${questions.length}</span> (${percentage}%)`;
        }

        // Добавяне на event listeners за бутоните за навигация
        nextBtn.addEventListener('click', handleNext);
        restartBtn.addEventListener('click', startQuiz);

        // При зареждане на страницата, стартираме теста
        document.addEventListener('DOMContentLoaded', startQuiz);

        // --- Край на JavaScript логиката ---
    </script>

</body>
</html>
