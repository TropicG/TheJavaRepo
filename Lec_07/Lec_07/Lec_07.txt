* Какво е поточна линия?

	Това е производителен процес, при който продуктът се движи на конвейрна лента, а всеки работник извършва една и съща малка, повтаряща се задача 
	
* Входни-изходни потоци 

	Някой неща относно концепцията за входно-изходните потоци (streams) в Java:
		- Цялата система за вход-изход (I/О) в Java е изградена върху идеята за потици 
		- Поток е реално една абстракция, която представлява непрекъснат поток от данни 
		- Съществуват само две операции или може да се четат данни от потока (вход) или да се пишат данни в поток (изход)
		- В Java потоците са разделени на два вида, тези който са базирани на байтове (всякакъв вид данни) и тези който са базирани на символи (оптимизирани за работа с текст)
	
* Основния модел за вход-изход (I/O) в Java 

	При вход, Java рпиложението чете (Read) данни от източник (Source), този източник може да бъде файл, конзола или мрежова връзка. Целият процес се случва чрез InputStream (входен поток)
	
	При изход, Java приложението пише (Write) данни към дестинацията, която отново може да бъде файл, конзола или Socket. Целият процес се случва чрез OutputStream (изходен поток)
	
	С други думи, InputStream внася данни в програмта, докато OutputStream изнася данни от нея
	
* Абстрактни класове в корена на I/O йерархията 

	Всичко се базира на четири основни абстрактни класа, които са разделени на две категории:
		- Byte I/O Streams (Байтови потоци) 
		- Character I/O Streams (Символни потоци)
		
	Абстрактните класове в Byte I/O Streams са:
		- InputStream: Това е базовия клас за четене на данни байт по байт (примерно изображение, аудио, всякакви файлове)
		- OutputStream: Това е базовия клас за писане на данни байт по байт 
		
	Абстрактните класове в Character I/О Streams са:
		- Reader: Това е базовия клас за четене на текстови данни символ по символ  (автоматично борави с кодировки като UTF-8)
		- Writer: Това е базовия клас за писане на текстови данни символ по символ 
		
	За по накратко:
		- Byte потоците са за всякакви (бинарни) данни
		- Character потоците са специализирани и оптимизирани за текст 
	
* Абстракните класове и техните конкретни наследници 

	Основните абстрактни класове за I/O в Java (InputStream, OutputStream, Reader и Writer) имат много конкретни наследници (подкласове)

	Всеки наследник е специализиран да работи с различен тип източник или дестинация на данни, примерно:
		- Файлове (FileInputStream)
		- Мрежови връзки (Socket)
		- Буфери в паметта (ByteArrayInputStream)
		- Комуникацията между нишки (PipedInputStream)
		
* Входни-изходни потоци: според допълнителните си качества 

	Освен според източника си потоците могат и да се класифицират и според допълнителните си качества, това се постига като един басов поток се обвива (wrapping) с друг, който добавя нова способност
	Примери за такива способности:
		- Четене/писане на специфични данни като тестк, примитивни типове или цели обекти 
		- Обработка на данни като парсване (анализиране), буфериране (за по-бърза обработка), компресиране или криптиране 
		
* Видове потоци 

	Както споменахме по-рано има две вида потоци (Streams) в Jav: Byte Streams и Character Streams 
	
	Byte Streams (Байтови потоци):
		- Те служат за бинарно четене и писане на сурови (бинарни) данни - байт по байт 
		- Използват се за всякакъв тип файлове, особено за не-текстови като изображенея, аудио
		- Освните класове тук са InputStream и OutputStream както и техните наследници (FileInputStream, DataInputStream, BufferedInputStream и др.)
		
	Character Streams (Символни потоци):
		- Те са специализирани за четене и посане на текстови данни - символ по символ 
		- Автоматично се справят с различните кодировки на символи (примерно UTF-8)
		- Освноните класове са Reader и Writer както и техните наследници (FileReader, BufferedReader, PrintWriter)
		
* Основните категории какъв може да е един поток 

	Основните категории на потоци:
		- Basic: Това са основните абстрактни класове, всички други ги наследяват 
		- Arrays: За четене/писане от масив в паметта 
		- Files: За четене/писане от файлове на диска 
		- Buffering: Добавяне на буфер за по-бърза работа 
		- Data: За четене/писане на примитивни Java типове 
		- Objects: За четене/писане на цели Java обекти 
		- Data-formatted: За лесно форматиране на изхода в четим текст 
		
* Йерархията за Байтовите потоци (Byte Streams) в Java 

	Всичко започва от тези два основни абстракни класа:
		- InputStream
		- OutputStream 
		
	Класовете, които наследяват тези основни абстрактни класове, се делят на две групи:
		- Потоците към източник/дестинация се свързват директно с конкрене източник или цел  като FileInputStream, ByteArrayInputStream
		- Wrapper потоците обвиват друг поток, за да му дадат нова функционалност , базовите класове за товаса FilterInputStream и FilterOutputStream (примери BufferedInputStread, DataInputStream)

* Йерархията на Символните потоци (Character Streams) в Java

	Всичко започва от тези двата основни абстракни класа:
		- Reader
		- Writer 
		
	Основните типове калсове в тази йерархия са:
		- Bridge Streams (Мостови потоци)
		- Wrappers (Обвиващи потоци)
		- Потоци към паметта
		
	Bridge Streams:
		- InputStreamReader е най-важния Reader, той е мост, който преобразвуа байтов поток (примерно FileInputStream) в символен, позволявайки четенето на текст от файл или мрежа 
		- OutputStreamWriter е мост, който преобразува символи в байтове, за да ги пише в OutputStream
		- FileReader/FileWriter са удобни класове, който комбинират горните две с файлове потоци за лесна работа с файлове 
		
	Wrappers:
		- BufferedReader обвива друг Reader и добавя буфериране, което повишава скоростта и позволява четене на тескт ред по ред 
		- BufferedWriter обвива Writer и добавя буфериране за по-бърз запис 
		- PrintWriter обвива Writer и добавя удобни методи за форматиране на текст като println() и printf()
		
	Потоци към паметта:
		- StringReader/StringWriter се използва за четене или писане директно от/към String в паметта 
		- CharArrayReader/CharArrayWriter се използва за четене или писане от/към масив от символи (char[])
		
* Жизнен цикъл на stream-овете 

	Жизнения цикъл на потоците се състои от три стъпки:
		- Създават се: Потоък се отваря и се свързва с източник на данни 
		- Използват се: Извършват се операции за четене или писане на данни 
		- Затварят се: Това е много важна стъпка, защото като се затвори потокът се освобождават заетите ресурси и гарантира, че всички данни са записани 
		
* Wrapping на I/O потоци в Java 

	Концепцията за wrapping на I/O потоците в Java е известна още като шаблона Decorator 
	
	Идеята е че се взима един базов поток (например InputStream) и се обвива в друг, по-специализиран поток (например DataInputStream)
	Целта е да се добавят нови функционалности:
		- Базовият InputStream може само да чете сурови байтове (чрез метода read())
		- Обвиващия DataInputStream добавя по-удобните методи като readInt(), readFloat(), readLong() които автоматично четат и преобразуват байтовете в съответния тип данни 
	Същата логика важи и за OutputStream и DataOutputStream 
	
	Когато се затвори (.close()) външния обвиващ поток, той автоматично затвароя и вътрешния поток, който го обвива 
	
* Byte Streams vs Character Streams при обработката на символи 

	Атомарната единица за работа с ByteStream е 1 байт (8 бита), те четат байт по байт 
	
	Атомаранта единца за работа с CharacterStreams е 1 символ, който в Java се представява като 2 байта (16 бите) 
	
	Виж ByteStreamExample.java
	Виж CharacterStreamExample.java
	Виж FileInputStreamExample.java
	
* Защо байтовите потоци се провалят при обработка на кирилица

	Символите от латинската азбука имат размер до 8 бита, докато символите от кирилица имат размер повече от 8 бита 
	
	Символ като 'I' има стойност 73, което може да се запише с 7 бита (01001001) и това се побира в един байт 
	Символ като 'С' (това е българско с) има стойност 1057 в Unicode и за да се напише са нужни 11 бита (10000100001)

	И понеже един байтов поток чете само по 8 бита, тоест 1 байт наведнъж, той не може да прочете целия 11-битов символ и това води до грешки и счупени символи 
	
* Java.io.InputStream 

	