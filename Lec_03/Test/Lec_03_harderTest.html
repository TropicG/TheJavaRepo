<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест по Java: ОПП и Памет (Продвинуто ниво)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .quiz-container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: #f9fafb;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .answer-btn {
            transition: all 0.2s ease-in-out;
        }
        .answer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .correct {
            background-color: #10b981 !important;
            color: white !important;
            border-color: #059669 !important;
        }
        .incorrect {
            background-color: #ef4444 !important;
            color: white !important;
            border-color: #dc2626 !important;
        }
        .rationale {
            font-size: 0.875rem;
            margin-top: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: #e5e7eb;
        }
        code {
            background-color: #e5e7eb;
            padding: 0.1rem 0.3rem;
            border-radius: 0.25rem;
            font-family: monospace;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="quiz-container" class="quiz-container">
        <div id="quiz-header" class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-900 mb-2">Тест по Java: ОПП и Памет (Продвинуто ниво)</h1>
            <p id="progress-text" class="text-gray-600">Въпрос 1 от 50</p>
        </div>
        
        <div id="question-area" class="mb-6">
            <h2 id="question-text" class="text-xl font-semibold mb-4 text-center">Зареждане на въпрос...</h2>
        </div>

        <div id="answers-area" class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <!-- Answer buttons will be generated here -->
        </div>

        <div id="feedback-area" class="mt-6">
             <p id="hint-text" class="text-sm text-gray-500 italic text-center p-2 border border-dashed rounded-md"></p>
        </div>

        <div id="navigation-area" class="mt-8 flex justify-center">
            <button id="next-btn" class="hidden bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-indigo-700 transition-colors">Следващ въпрос</button>
        </div>

        <div id="results-area" class="hidden text-center">
            <h2 class="text-2xl font-bold mb-4">Тестът приключи!</h2>
            <p id="score-text" class="text-3xl font-bold mb-6"></p>
            <button id="restart-btn" class="bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-indigo-700 transition-colors">Започни отначало</button>
        </div>
    </div>

    <script>
        const quizData = {
            "questions": [
    {
        "questionNumber": 1,
        "question": "Ако метод получи референция към обект и я пренасочи към нов обект (<code>param = new Object();</code>), как ще се отрази това извън метода?",
        "answerOptions": [
            {
                "text": "Оригиналната променлива също ще сочи към новия обект.",
                "isCorrect": false,
                "rationale": "Пренасочването засяга само копието на референцията вътре в метода."
            },
            {
                "text": "Няма да има ефект върху оригиналната променлива извън метода.",
                "isCorrect": true,
                "rationale": "Java предава референциите по стойност. Методът работи с копие на референцията, така че промяната на това копие не засяга оригинала."
            },
            {
                "text": "Оригиналният обект ще бъде маркиран за Garbage Collector.",
                "isCorrect": false,
                "rationale": "Оригиналният обект остава достъпен чрез оригиналната референция извън метода."
            },
            {
                "text": "Ще се хвърли <code>NullPointerException</code> при излизане от метода.",
                "isCorrect": false,
                "rationale": "Тази операция е напълно валидна и не води до изключения."
            }
        ],
        "hint": "Помислете какво точно се копира, когато референтен тип се предава като параметър."
    },
    {
        "questionNumber": 2,
        "question": "При изпълнението на <code>String s = new String(\"test\");</code>, колко обекта от тип <code>String</code> се създават в паметта (ако приемем, че \"test\" не съществува в string pool-а)?",
        "answerOptions": [
            {
                "text": "Нула, използва се само литерал.",
                "isCorrect": false,
                "rationale": "Операторът `new` винаги създава нов обект."
            },
            {
                "text": "Един, само в heap паметта.",
                "isCorrect": false,
                "rationale": "Освен обекта, създаден с `new`, се случва и още нещо с низовия литерал."
            },
            {
                "text": "Два: един в string pool-а и един в heap-а извън pool-а.",
                "isCorrect": true,
                "rationale": "Низовият литерал \"test\" се поставя в string pool-а, а `new String(...)` изрично създава нов, отделен обект в heap-а."
            },
            {
                "text": "Един, само в string pool-а.",
                "isCorrect": false,
                "rationale": "Използването на `new` гарантира създаването на обект извън string pool-а."
            }
        ],
        "hint": "Каква е разликата между <code>String s = \"test\";</code> и <code>String s = new String(\"test\");</code>?"
    },
    {
        "questionNumber": 3,
        "question": "В сложна йерархия C -> B -> A, ако се създаде обект <code>new C()</code>, чий статичен инициализатор ще се изпълни пръв?",
        "answerOptions": [
            {
                "text": "Статичният инициализатор на C.",
                "isCorrect": false,
                "rationale": "Статичната инициализация следва йерархията на наследяване отгоре надолу."
            },
            {
                "text": "Статичният инициализатор на A.",
                "isCorrect": true,
                "rationale": "Зареждането и инициализацията на класовете започва от най-високия клас в йерархията (прародителя) и продължава надолу."
            },
            {
                "text": "Статичният инициализатор на B.",
                "isCorrect": false,
                "rationale": "Клас A трябва да бъде инициализиран преди B."
            },
            {
                "text": "Всички се изпълняват паралелно.",
                "isCorrect": false,
                "rationale": "Инициализацията на класовете е последователен, синхронизиран процес."
            }
        ],
        "hint": "За да се зареди един клас, неговият родителски клас трябва да бъде зареден първо."
    },
    {
        "questionNumber": 4,
        "question": "Как може един <code>enum</code> да има различно поведение за всяка своя константа?",
        "answerOptions": [
            {
                "text": "Чрез използване на <code>if/else</code> в методите на <code>enum</code>-а.",
                "isCorrect": false,
                "rationale": "Въпреки че е възможно, това не е най-елегантният и обектно-ориентиран подход."
            },
            {
                "text": "Чрез дефиниране на абстрактен метод в <code>enum</code>-а и имплементация за всяка константа.",
                "isCorrect": true,
                "rationale": "Това позволява на всяка константа да предостави своя собствена имплементация, превръщайки я в полиморфен обект."
            },
            {
                "text": "Невъзможно е, всички константи споделят едно и също поведение.",
                "isCorrect": false,
                "rationale": "Enums са много по-мощни от обикновени константи и позволяват дефиниране на специфично поведение."
            },
            {
                "text": "Чрез наследяване на <code>enum</code>-а и препокриване на методите.",
                "isCorrect": false,
                "rationale": "Enums не могат да бъдат наследявани (те са имплицитно `final`)."
            }
        ],
        "hint": "Помислете за <code>enum</code>-ите не просто като константи, а като пълноценни класове."
    },
    {
        "questionNumber": 5,
        "question": "Как може да се постигне \"дълбока\" неизменяемост (deep immutability) в един <code>record</code>, който съдържа изменяемо поле, например <code>List<String></code>?",
        "answerOptions": [
            {
                "text": "Чрез използване на <code>final</code> за полето.",
                "isCorrect": false,
                "rationale": "`final` осигурява само плитка (shallow) неизменяемост на референцията."
            },
            {
                "text": "Невъзможно е, <code>record</code>-ите са само плитко неизменяеми.",
                "isCorrect": false,
                "rationale": "Въпреки че по подразбиране са плитко неизменяеми, програмистът може да предприеме стъпки за постигане на дълбока неизменяемост."
            },
            {
                "text": "Чрез създаване на защитно копие (defensive copy) на листа в каноничния или компактен конструктор.",
                "isCorrect": true,
                "rationale": "Присвояването на неизменяемо копие (напр. чрез `List.copyOf()`) гарантира, че вътрешното състояние не може да бъде променено отвън."
            },
            {
                "text": "Чрез имплементиране на интерфейса <code>Serializable</code>.",
                "isCorrect": false,
                "rationale": "Сериализацията е свързана със съхранение и пренос на обекти, а не с тяхната неизменяемост."
            }
        ],
        "hint": "Какво трябва да направите с подадения в конструктора списък, за да сте сигурни, че никой извън <code>record</code>-а няма да го промени?"
    },
    {
        "questionNumber": 6,
        "question": "Какво се случва, ако в <code>try-with-resources</code> блок възникне изключение, а след това и методът <code>close()</code> на ресурса хвърли изключение?",
        "answerOptions": [
            {
                "text": "Само изключението от <code>close()</code> се разпространява нагоре.",
                "isCorrect": false,
                "rationale": "Оригиналното изключение се счита за по-важно."
            },
            {
                "text": "Само оригиналното изключение от <code>try</code> блока се разпространява.",
                "isCorrect": false,
                "rationale": "Информацията за второто изключение не се губи напълно."
            },
            {
                "text": "Оригиналното изключение се разпространява, а изключението от <code>close()</code> се добавя като \"подтиснато\" (suppressed).",
                "isCorrect": true,
                "rationale": "Това запазва и двете информации, като основното изключение е това от `try` блока, а другото е достъпно чрез `getSuppressed()`."
            },
            {
                "text": "Програмата се срива незабавно, без да разпространява изключения.",
                "isCorrect": false,
                "rationale": "Механизмът за изключенията продължава да работи по дефиниран начин."
            }
        ],
        "hint": "Как <code>try-with-resources</code> предотвратява загубата на информация при възникване на множество грешки?"
    },
    {
        "questionNumber": 7,
        "question": "Какво ще бъде поведението на <code>switch</code> израз, който използва pattern matching върху <code>sealed</code> интерфейс, ако добавите нов наследник към <code>permits</code> списъка, но не го добавите в <code>case</code> клоновете?",
        "answerOptions": [
            {
                "text": "Кодът ще се компилира, но ще хвърли <code>RuntimeException</code> при изпълнение.",
                "isCorrect": false,
                "rationale": "Компилаторът е достатъчно интелигентен, за да хване този проблем предварително."
            },
            {
                "text": "Ще възникне грешка при компилация, защото <code>switch</code> изразът не е изчерпателен.",
                "isCorrect": true,
                "rationale": "Една от основните ползи на `sealed` класовете е, че компилаторът може да провери за изчерпателност и да предотврати подобни грешки."
            },
            {
                "text": "Кодът ще се компилира и ще се изпълни, като новият тип ще бъде игнориран.",
                "isCorrect": false,
                "rationale": "Липсата на `case` за позволен подтип се счита за грешка, освен ако няма `default` клон."
            },
            {
                "text": "Ще се изпълни <code>default</code> клонът, ако съществува такъв.",
                "isCorrect": false,
                "rationale": "Въпреки че това би се случило, основният отговор е, че компилаторът ще се оплаче от липсата на изчерпателност, ако няма `default`."
            }
        ],
        "hint": "Как `sealed` класовете помагат на компилатора да гарантира, че сте обработили всички възможни случаи?"
    },
    {
        "questionNumber": 8,
        "question": "Ако един метод има <code>return</code> в <code>try</code> блока и друг <code>return</code> във <code>finally</code> блока, коя стойност ще бъде върната?",
        "answerOptions": [
            {
                "text": "Стойността от <code>try</code> блока.",
                "isCorrect": false,
                "rationale": "Блокът `finally` има способността да \"презапише\" резултата от `try` блока."
            },
            {
                "text": "Стойността от <code>finally</code> блока.",
                "isCorrect": true,
                "rationale": "<code>finally</code> блокът се изпълнява последен, точно преди методът да върне контрола, и неговият `return` има предимство."
            },
            {
                "text": "Ще възникне грешка при компилация.",
                "isCorrect": false,
                "rationale": "Синтаксисът е валиден, въпреки че често се счита за лоша практика."
            },
            {
                "text": "Ще се хвърли <code>IllegalStateException</code> по време на изпълнение.",
                "isCorrect": false,
                "rationale": "Няма да се хвърли автоматично изключение; поведението е дефинирано."
            }
        ],
        "hint": "Кой блок код има \"последната дума\" преди методът да приключи?"
    },
    {
        "questionNumber": 9,
        "question": "Каква е разликата между <code>catch (Exception e)</code> и <code>catch (Throwable t)</code>?",
        "answerOptions": [
            {
                "text": "Няма разлика, те са еквивалентни.",
                "isCorrect": false,
                "rationale": "`Throwable` е родителски клас на `Exception`, но има и друг важен наследник."
            },
            {
                "text": "<code>catch (Throwable t)</code> прихваща и <code>Error</code>-и, докато <code>catch (Exception e)</code> не го прави.",
                "isCorrect": true,
                "rationale": "`Throwable` е базовият клас за всички грешки и изключения, включително фатални `Error`-и като `OutOfMemoryError`, които обикновено не трябва да се прихващат."
            },
            {
                "text": "<code>catch (Exception e)</code> прихваща само <code>Checked Exceptions</code>.",
                "isCorrect": false,
                "rationale": "<code>Exception</code> е родител както на `Checked Exceptions`, така и на `RuntimeException` (Unchecked)."
            },
            {
                "text": "<code>catch (Throwable t)</code> е остарял синтаксис и не трябва да се използва.",
                "isCorrect": false,
                "rationale": "Синтаксисът е валиден, но прихващането на `Throwable` се счита за лоша практика в почти всички случаи."
            }
        ],
        "hint": "Погледнете йерархията на класовете за грешки. Какви са двата основни наследника на `Throwable`?"
    },
    {
        "questionNumber": 10,
        "question": "Кога се налага да дефинирате изрично каноничен конструктор за <code>record</code>?",
        "answerOptions": [
            {
                "text": "Винаги, той не се генерира автоматично.",
                "isCorrect": false,
                "rationale": "Компилаторът генерира каноничен конструктор по подразбиране."
            },
            {
                "text": "Когато искате да пропуснете инициализацията на някои полета.",
                "isCorrect": false,
                "rationale": "Всички `final` полета трябва да бъдат инициализирани в конструктора."
            },
            {
                "text": "Когато компактният конструктор не е достатъчен, например ако трябва да извършите действие след присвояването на полетата.",
                "isCorrect": true,
                "rationale": "Ако логиката ви изисква повече от предварителна валидация (която се прави в компактен конструктор), например извикване на метод след като `this.field` е присвоено, трябва да напишете пълния каноничен конструктор."
            },
            {
                "text": "Само когато <code>record</code>-ът имплементира интерфейс.",
                "isCorrect": false,
                "rationale": "Имплементирането на интерфейси не е свързано с нуждата от изричен конструктор."
            }
        ],
        "hint": "Каква е основната разлика в синтаксиса и възможностите между компактен и каноничен конструктор?"
    },
    {
        "questionNumber": 11,
        "question": "Ако един обект няма никакви референции към него, кога точно Garbage Collector-ът ще освободи паметта му?",
        "answerOptions": [
            {
                "text": "Незабавно, в момента, в който последната референция изчезне.",
                "isCorrect": false,
                "rationale": "GC не работи в реално време; той е недетерминистичен процес."
            },
            {
                "text": "По време на следващия цикъл на Garbage Collector-а, но точният момент не е гарантиран.",
                "isCorrect": true,
                "rationale": "GC работи периодично във фонов режим. Няма гаранция кога точно ще се изпълни и ще почисти конкретен обект."
            },
            {
                "text": "Само когато програмата приключи.",
                "isCorrect": false,
                "rationale": "GC работи по време на изпълнение на програмата, за да предотврати изчерпването на паметта."
            },
            {
                "text": "Когато се извика методът <code>System.gc()</code>.",
                "isCorrect": false,
                "rationale": "Извикването на `System.gc()` е само препоръка към JVM да стартира GC, но не е гаранция, че това ще се случи веднага."
            }
        ],
        "hint": "Детерминистичен или недетерминистичен процес е събирането на смет в Java?"
    },
    {
        "questionNumber": 12,
        "question": "Какъв е ефектът от декларирането на наследник на <code>sealed</code> клас като <code>non-sealed</code>?",
        "answerOptions": [
            {
                "text": "Класът не може да бъде наследяван повече.",
                "isCorrect": false,
                "rationale": "Това е ефектът на модификатора `final`."
            },
            {
                "text": "Класът може да бъде наследен само от класове, дефинирани в същия файл.",
                "isCorrect": false,
                "rationale": "Това не е правило, свързано с `non-sealed`."
            },
            {
                "text": "Ограничението за наследяване се премахва и този клас отваря йерархията отново за свободно наследяване.",
                "isCorrect": true,
                "rationale": "<code>non-sealed</code> ефективно връща поведението на класическото, неконтролирано наследяване за този конкретен клон на йерархията."
            },
            {
                "text": "Компилаторът ще изисква <code>default</code> клон във всички <code>switch</code> изрази, които го използват.",
                "isCorrect": false,
                "rationale": "Това е следствие от отварянето на йерархията, но не е директният ефект на самия модификатор."
            }
        ],
        "hint": "Какво се случва, ако искате да позволите на потребителите на вашата библиотека да разширят част от вашата `sealed` йерархия?"
    },
    {
        "questionNumber": 13,
        "question": "Кое от следните твърдения за връзката между <code>equals()</code> и <code>hashCode()</code> в Java е най-точно?",
        "answerOptions": [
            {
                "text": "Ако два обекта са равни според <code>equals()</code>, те трябва да имат еднакъв <code>hashCode()</code>.",
                "isCorrect": true,
                "rationale": "Това е основното правило в договора между двата метода, което е критично за правилното функциониране на хеш-базирани колекции."
            },
            {
                "text": "Ако два обекта имат еднакъв <code>hashCode()</code>, те трябва да са равни според <code>equals()</code>.",
                "isCorrect": false,
                "rationale": "Това не е задължително. Възможни са т.нар. \"колизии\" - различни обекти да имат един и същ хеш код."
            },
            {
                "text": "Двата метода са напълно независими един от друг.",
                "isCorrect": false,
                "rationale": "Те са свързани с важен договор, чието нарушаване води до проблеми с колекции като `HashMap` и `HashSet`."
            },
            {
                "text": "Препокриването на <code>equals()</code> автоматично генерира съответстващ <code>hashCode()</code>.",
                "isCorrect": false,
                "rationale": "Програмистът е отговорен да препокрие и двата метода по съгласуван начин (освен ако не става въпрос за `record`)."
            }
        ],
        "hint": "Какво е основното изискване на колекции като `HashMap` за обектите, които се използват като ключове?"
    },
    {
        "questionNumber": 14,
        "question": "Кой е единственият начин да се изпълни сложна инициализационна логика за статични `final` променливи, която изисква обработка на изключения?",
        "answerOptions": [
            {
                "text": "В конструктора на класа.",
                "isCorrect": false,
                "rationale": "Конструкторът се изпълнява за инстанции, а статичните променливи са свързани със самия клас."
            },
            {
                "text": "В статичен инициализационен блок (<code>static {}</code>).",
                "isCorrect": true,
                "rationale": "Статичният блок е единственото място, където може да се напише многоредова логика, включително `try-catch` блокове, за инициализация на статични членове."
            },
            {
                "text": "Чрез статичен factory метод.",
                "isCorrect": false,
                "rationale": "Factory методът може да създава инстанции, но не може да инициализира `final` статична променлива след като класът е зареден."
            },
            {
                "text": "Невъзможно е, статичните `final` променливи трябва да се инициализират на един ред.",
                "isCorrect": false,
                "rationale": "Статичните блокове предоставят механизъм за по-сложна логика."
            }
        ],
        "hint": "Къде може да се постави `try-catch` блок на ниво клас, а не в метод?"
    },
    {
        "questionNumber": 15,
        "question": "Какво представлява \"escape analysis\" и как е свързано със stack и heap паметта?",
        "answerOptions": [
            {
                "text": "Анализ на сигурността, който предотвратява инжектиране на код.",
                "isCorrect": false,
                "rationale": "Това е свързано със сигурността на приложенията, а не с оптимизация на паметта."
            },
            {
                "text": "Оптимизация на компилатора, която позволява някои обекти да бъдат алокирани на stack-а, ако не \"избягат\" от обхвата на метода.",
                "isCorrect": true,
                "rationale": "Ако компилаторът докаже, че животът на един обект е ограничен само до текущия метод, той може да го алокира на по-бързия stack, вместо на heap-а, избягвайки натоварването на GC."
            },
            {
                "text": "Механизъм за проследяване на изтичане на памет (memory leaks).",
                "isCorrect": false,
                "rationale": "Това е оптимизация за производителност, а не инструмент за дебъгване."
            },
            {
                "text": "Процесът на прехвърляне на обекти от stack-а към heap-а.",
                "isCorrect": false,
                "rationale": "Това описва обратния процес; escape analysis се опитва да направи точно обратното."
            }
        ],
        "hint": "Може ли JVM понякога да наруши правилото, че всички обекти се създават в heap-а, с цел оптимизация?"
    },
	{
        "questionNumber": 16,
        "question": "Кое твърдение за `String Pool` в Java е най-точно?",
        "answerOptions": [
            {
                "text": "Той се намира в stack паметта.",
                "isCorrect": false,
                "rationale": "String Pool е част от heap паметта, управлявана специално от JVM."
            },
            {
                "text": "Всеки път, когато се създаде низ с `new String()`, той се добавя в `String Pool`.",
                "isCorrect": false,
                "rationale": "`new String()` създава обект извън pool-а. Методът `intern()` може да го добави ръчно."
            },
            {
                "text": "Той е механизъм за оптимизация на паметта, който гарантира, че един и същ низов литерал съществува само веднъж.",
                "isCorrect": true,
                "rationale": "Чрез преизползване на инстанции за еднакви литерали, JVM спестява памет."
            },
            {
                "text": "Съдържанието му се изчиства при всеки цикъл на Garbage Collector-а.",
                "isCorrect": false,
                "rationale": "Обектите в String Pool-а могат да бъдат събрани от GC, но само ако вече не са достъпни от никъде в програмата."
            }
        ],
        "hint": "Защо `\"hello\" == \"hello\"` връща `true` в Java?"
    },
    {
        "questionNumber": 17,
        "question": "Какво ще се случи, ако имате `record` с поле `List<String>`, но аксесорният му метод е препокрит така, че да връща неизменяемо копие?",
        "answerOptions": [
            {
                "text": "Това ще предизвика грешка при компилация.",
                "isCorrect": false,
                "rationale": "Напълно валидно е да се препокрие генерираният аксесорен метод."
            },
            {
                "text": "Това е добра практика за постигане на по-добра енкапсулация и неизменяемост.",
                "isCorrect": true,
                "rationale": "Връщането на защитно копие от аксесора (в допълнение към създаването на такова в конструктора) предотвратява промяната на вътрешното състояние."
            },
            {
                "text": "Няма да има ефект, тъй като оригиналното поле все още е достъпно.",
                "isCorrect": false,
                "rationale": "Оригиналното поле е `private`, така че единственият достъп отвън е чрез аксесорния метод."
            },
            {
                "text": "Това нарушава договора на `record`-ите и може да доведе до непредсказуемо поведение на `equals()`.",
                "isCorrect": false,
                "rationale": "Това не нарушава договора, а го подсилва, като допринася за по-стриктна неизменяемост."
            }
        ],
        "hint": "Как можете да попречите на някой, който извиква `get myList()`, да промени върнатия списък?"
    },
    {
        "questionNumber": 18,
        "question": "Кога един `catch` блок за `IOException` ще прихване и `FileNotFoundException`?",
        "answerOptions": [
            {
                "text": "Никога, те са напълно различни типове изключения.",
                "isCorrect": false,
                "rationale": "Помислете за йерархията на наследяване между класовете на изключенията."
            },
            {
                "text": "Винаги, защото `FileNotFoundException` наследява `IOException`.",
                "isCorrect": true,
                "rationale": "Прихващането на родителски тип изключение (`IOException`) прихваща и всички негови наследници (`FileNotFoundException`)."
            },
            {
                "text": "Само ако са хвърлени в един и същ `try` блок.",
                "isCorrect": false,
                "rationale": "Връзката между тях е базирана на типовата йерархия, а не на мястото, където са хвърлени."
            },
            {
                "text": "Само ако `catch` блокът е маркиран с `throws IOException`.",
                "isCorrect": false,
                "rationale": "`throws` се използва в сигнатурата на метод, а не върху `catch` блок."
            }
        ],
        "hint": "Как работи полиморфизмът при обработката на изключения?"
    },
    {
        "questionNumber": 19,
        "question": "Каква е целта на `phantom reference` в Java?",
        "answerOptions": [
            {
                "text": "Да предотврати обектът да бъде събран от Garbage Collector-а.",
                "isCorrect": false,
                "rationale": "Това се постига със силна референция (strong reference)."
            },
            {
                "text": "Да позволи изпълнението на финализираща логика, след като обектът е вече финализиран и преди паметта да бъде освободена.",
                "isCorrect": true,
                "rationale": "Фантомните референции, в комбинация с `ReferenceQueue`, са по-гъвкав и надежден механизъм за почистване на ресурси след смъртта на обекта, в сравнение с `finalize()`."
            },
            {
                "text": "Да кешира обекти, които могат да бъдат премахнати от GC при недостиг на памет.",
                "isCorrect": false,
                "rationale": "Това описва слабите (weak) или меките (soft) референции."
            },
            {
                "text": "Да създаде плитко копие на обект.",
                "isCorrect": false,
                "rationale": "Това няма връзка с референтните типове."
            }
        ],
        "hint": "Помислете за механизъм за почистване, който е по-надежден от вече остарелия метод `finalize()`."
    },
    {
        "questionNumber": 20,
        "question": "Кое от следните НЕ е характеристика на `enum` типовете?",
        "answerOptions": [
            {
                "text": "Типова безопасност (type safety).",
                "isCorrect": false,
                "rationale": "Една от основните им цели е да осигурят типова безопасност, за разлика от използването на обикновени `int` или `String` константи."
            },
            {
                "text": "Могат да бъдат инстанцирани с `new` извън дефиницията на `enum`-а.",
                "isCorrect": true,
                "rationale": "Техните конструктори са `private`, което забранява създаването на нови инстанции и гарантира, че съществуват само дефинираните константи."
            },
            {
                "text": "Могат да имат специфични за всяка константа методи.",
                "isCorrect": false,
                "rationale": "Чрез абстрактни методи в `enum`-а, всяка константа може да предостави собствена имплементация."
            },
            {
                "text": "Всяка константа е `public static final` инстанция на `enum` класа.",
                "isCorrect": false,
                "rationale": "Това е начинът, по който компилаторът ги третира, което ги прави глобално достъпни и уникални."
            }
        ],
        "hint": "Как `enum` гарантира, че имате строго ограничен и фиксиран набор от възможни стойности?"
    },
	{
        "questionNumber": 21,
        "question": "Ако един клас имплементира `AutoCloseable` и методът му `close()` хвърля `Checked Exception`, какво трябва да направи кодът, който го използва в `try-with-resources` блок?",
        "answerOptions": [
            {
                "text": "Нищо, `try-with-resources` автоматично обработва всички изключения.",
                "isCorrect": false,
                "rationale": "Автоматичното затваряне не елиминира нуждата от обработка на `Checked Exceptions`."
            },
            {
                "text": "Трябва да има `catch` блок за това изключение или методът, съдържащ блока, трябва да го декларира с `throws`.",
                "isCorrect": true,
                "rationale": "Въпреки че `close()` се извиква имплицитно, компилаторът все още изисква потенциалното `Checked Exception` от него да бъде обработено."
            },
            {
                "text": "Трябва да се използва стандартен `try-finally` блок вместо `try-with-resources`.",
                "isCorrect": false,
                "rationale": "`try-with-resources` е предпочитаният начин, но изисква правилна обработка на изключения."
            },
            {
                "text": "Трябва да се декларира ресурсът като `final`.",
                "isCorrect": false,
                "rationale": "Модификаторът `final` не влияе на обработката на изключения."
            }
        ],
        "hint": "Дали имплицитното извикване на метод премахва изискванията на компилатора за обработка на `Checked Exceptions`?"
    },
    {
        "questionNumber": 22,
        "question": "Какъв е смисълът на `final` параметър в сигнатурата на метод (<code>void myMethod(final int x)</code>)?",
        "answerOptions": [
            {
                "text": "Стойността на `x` не може да бъде променяна извън метода.",
                "isCorrect": false,
                "rationale": "Параметрите са локални за метода; това не засяга външния свят."
            },
            {
                "text": "Параметърът `x` не може да бъде пренасочен към нова стойност вътре в тялото на метода.",
                "isCorrect": true,
                "rationale": "Това е гаранция за компилатора, че референцията (или стойността за примитиви) няма да бъде променена. Полезно е при работа с анонимни класове или ламбда изрази."
            },
            {
                "text": "Методът става `final` и не може да бъде препокриван.",
                "isCorrect": false,
                "rationale": "`final` пред параметър няма нищо общо с наследяването на метода."
            },
            {
                "text": "Ускорява изпълнението на метода чрез оптимизации.",
                "isCorrect": false,
                "rationale": "Въпреки че може да помогне на компилатора, основната цел е семантична коректност, а не производителност."
            }
        ],
        "hint": "Какво означава `final` за локална променлива?"
    },
    {
        "questionNumber": 23,
        "question": "Кога е удачно да се използва `non-sealed` в йерархия от `sealed` класове?",
        "answerOptions": [
            {
                "text": "Никога, това нарушава целия смисъл на `sealed` класовете.",
                "isCorrect": false,
                "rationale": "Това е предвидена и полезна функционалност за определени сценарии."
            },
            {
                "text": "Когато искате да позволите на потребителите на вашата библиотека да разширят определен клон от йерархията.",
                "isCorrect": true,
                "rationale": "Това дава възможност за контролирано разширяване, където авторът на API изрично позволява бъдещи, непознати имплементации на даден подтип."
            },
            {
                "text": "За всички крайни класове в йерархията, които не трябва да бъдат наследявани.",
                "isCorrect": false,
                "rationale": "За тази цел се използва модификаторът `final`."
            },
            {
                "text": "Когато базовият клас е интерфейс, а не клас.",
                "isCorrect": false,
                "rationale": "Модификаторът `non-sealed` се прилага за наследниците, независимо дали базовият тип е клас или интерфейс."
            }
        ],
        "hint": "Как можете да балансирате между затворена йерархия и разширяемост?"
    },
    {
        "questionNumber": 24,
        "question": "Кой от следните типове памет в JVM е най-вероятно да предизвика `StackOverflowError`?",
        "answerOptions": [
            {
                "text": "Heap Space",
                "isCorrect": false,
                "rationale": "Запълването на Heap Space води до `OutOfMemoryError`."
            },
            {
                "text": "Metaspace",
                "isCorrect": false,
                "rationale": "Metaspace съхранява метаданни за класовете и запълването му също води до `OutOfMemoryError`."
            },
            {
                "text": "Thread Stack",
                "isCorrect": true,
                "rationale": "Всяка нишка има собствен стек за извиквания на методи. Дълбока или безкрайна рекурсия изчерпва пространството в този стек, водейки до `StackOverflowError`."
            },
            {
                "text": "String Pool",
                "isCorrect": false,
                "rationale": "String Pool-ът е част от heap-а и запълването му би допринесло за `OutOfMemoryError`."
            }
        ],
        "hint": "Къде се съхраняват фреймовете на извиканите методи?"
    },
    {
        "questionNumber": 25,
        "question": "В какъв ред се изпълняват: 1. Нестатичен инициализатор на базовия клас, 2. Конструктор на базовия клас, 3. Нестатичен инициализатор на производния клас, 4. Конструктор на производния клас?",
        "answerOptions": [
            {
                "text": "1, 3, 2, 4",
                "isCorrect": false,
                "rationale": "Конструкторът на базовия клас винаги се изпълнява преди каквото и да е от производния клас."
            },
            {
                "text": "2, 1, 4, 3",
                "isCorrect": false,
                "rationale": "Инициализаторите винаги се изпълняват преди конструктора за съответния клас."
            },
            {
                "text": "1, 2, 3, 4",
                "isCorrect": true,
                "rationale": "Процесът на инстанциране завършва напълно базовия обект (инициализатор + конструктор) преди да започне с производния (инициализатор + конструктор)."
            },
            {
                "text": "3, 4, 1, 2",
                "isCorrect": false,
                "rationale": "Инициализацията винаги върви от родителя към наследника."
            }
        ],
        "hint": "Обектът-родител трябва да бъде напълно конструиран, преди да започне конструирането на обекта-наследник."
    },
	{
        "questionNumber": 26,
        "question": "Какво представлява \"method inlining\" и как се отразява на stack trace-а?",
        "answerOptions": [
            {
                "text": "Това е ръчно пренаписване на код, което не влияе на stack trace-а.",
                "isCorrect": false,
                "rationale": "Това е автоматична оптимизация, извършвана от JIT компилатора."
            },
            {
                "text": "Оптимизация, при която тялото на малък метод се копира на мястото на извикването му, което може да доведе до липса на този метод в stack trace-а.",
                "isCorrect": true,
                "rationale": "JIT компилаторът може да премахне извикването на метода, за да спести overhead, което го прави \"невидим\" при проследяване на грешки."
            },
            {
                "text": "Процесът на вграждане на анонимни класове, който удължава stack trace-а.",
                "isCorrect": false,
                "rationale": "Това е оптимизация, която обикновено скъсява или променя stack trace-а."
            },
            {
                "text": "Дебъгинг техника, която добавя допълнителна информация към stack trace-а.",
                "isCorrect": false,
                "rationale": "Това е оптимизация за производителност, която може да затрудни дебъгването."
            }
        ],
        "hint": "Какво може да направи JIT компилаторът, за да избегне разходите, свързани с извикването на метод?"
    },
    {
        "questionNumber": 27,
        "question": "Може ли един `enum` да наследи друг `enum`?",
        "answerOptions": [
            {
                "text": "Да, ако вторият `enum` е деклариран като `abstract`.",
                "isCorrect": false,
                "rationale": "Enums не могат да бъдат наследявани изобщо."
            },
            {
                "text": "Не, защото всички `enum`-и имплицитно наследяват `java.lang.Enum` и Java не поддържа множествено наследяване на класове.",
                "isCorrect": true,
                "rationale": "Тъй като всеки `enum` вече има родител (`java.lang.Enum`), той не може да наследи друг клас, включително друг `enum`."
            },
            {
                "text": "Да, но само ако са в един и същ пакет.",
                "isCorrect": false,
                "rationale": "Ограниченията за пакети не променят правилата за наследяване."
            },
            {
                "text": "Не, освен ако не се използва ключовата дума `permits`.",
                "isCorrect": false,
                "rationale": "`permits` е свързана със `sealed` класове, а не с `enum` наследяване."
            }
        ],
        "hint": "Кой е имплицитният родителски клас на всеки `enum`?"
    },
    {
        "questionNumber": 28,
        "question": "Кое от следните е пример за \"rethrowing an exception\"?",
        "answerOptions": [
            {
                "text": "<code>catch (IOException e) { throw new RuntimeException(e); }</code>",
                "isCorrect": false,
                "rationale": "Това е \"exception wrapping\" (обвиване на изключение), а не пре-хвърляне на същото."
            },
            {
                "text": "<code>catch (IOException e) { e.printStackTrace(); }</code>",
                "isCorrect": false,
                "rationale": "Това е \"swallowing\" (поглъщане) на изключението, което често е лоша практика."
            },
            {
                "text": "<code>catch (IOException e) { System.out.println(\"Error\"); }</code>",
                "isCorrect": false,
                "rationale": "Това също е форма на поглъщане на изключението, тъй като не го разпространява нагоре."
            },
            {
                "text": "<code>catch (IOException e) { log.error(e); throw e; }</code>",
                "isCorrect": true,
                "rationale": "Тук изключението се прихваща (например за запис в лог), след което същата инстанция се хвърля отново, за да продължи нагоре по стека."
            }
        ],
        "hint": "Как можете да извършите действие при възникване на изключение, без да прекъсвате потока на обработка на грешката?"
    },
    {
        "questionNumber": 29,
        "question": "Защо `record`-ите не могат да бъдат `abstract`?",
        "answerOptions": [
            {
                "text": "Защото не могат да имат методи.",
                "isCorrect": false,
                "rationale": "Record-ите могат да имат както статични, така и инстанционни методи."
            },
            {
                "text": "Защото компилаторът имплицитно ги прави `final`, а `final` и `abstract` са взаимно изключващи се.",
                "isCorrect": true,
                "rationale": "Основната цел на `record` е да бъде прост носител на данни. `final` гарантира, че той не може да бъде част от сложна йерархия, докато `abstract` би изисквал точно това."
            },
            {
                "text": "Защото всичките им полета са `final`.",
                "isCorrect": false,
                "rationale": "Един нормален клас може да има `final` полета и пак да бъде `abstract`."
            },
            {
                "text": "Защото им липсва конструктор по подразбиране.",
                "isCorrect": false,
                "rationale": "Те имат каноничен конструктор; липсата на конструктор без аргументи не е причината."
            }
        ],
        "hint": "Какъв е противоположният на `abstract` модификатор по отношение на наследяването?"
    },
    {
        "questionNumber": 30,
        "question": "Кое от следните е най-доброто описание на `OutOfMemoryError`?",
        "answerOptions": [
            {
                "text": "Checked exception, което трябва да се обработи при работа с големи файлове.",
                "isCorrect": false,
                "rationale": "Това е `Error`, а не `Exception`, и не е `Checked`."
            },
            {
                "text": "RuntimeException, причинено от програмна грешка като безкраен цикъл.",
                "isCorrect": false,
                "rationale": "Въпреки че безкраен цикъл може да го причини, то се класифицира като `Error`."
            },
            {
                "text": "`Error`, което сигнализира за критичен проблем с паметта в JVM, от който приложението обикновено не може да се възстанови.",
                "isCorrect": true,
                "rationale": "Това точно описва сериозността и класификацията на този проблем."
            },
            {
                "text": "Изключение, което се хвърля от Garbage Collector-а, когато не може да намери повече обекти за почистване.",
                "isCorrect": false,
                "rationale": "Хвърля се, когато GC не успее да освободи достатъчно памет, за да удовлетвори заявка за алокация."
            }
        ],
        "hint": "В коя от трите основни категории грешки (`Checked`, `Unchecked`, `Error`) попадат фаталните проблеми на JVM?"
    },
	{
        "questionNumber": 31,
        "question": "Какво е \"circular dependency\" при статична инициализация и до какво може да доведе?",
        "answerOptions": [
            {
                "text": "Когато два метода се извикват рекурсивно, водейки до `StackOverflowError`.",
                "isCorrect": false,
                "rationale": "Това е рекурсия, а не проблем със статичната инициализация."
            },
            {
                "text": "Когато статичният инициализатор на клас А зависи от клас Б, а този на клас Б зависи от клас А, което може да доведе до `StackOverflowError` или неочаквани `null` стойности.",
                "isCorrect": true,
                "rationale": "Това може да доведе до deadlock или до ситуация, в която единият клас се опитва да използва другия, преди той да е напълно инициализиран."
            },
            {
                "text": "Оптимизация на компилатора, която ускорява зареждането на класове.",
                "isCorrect": false,
                "rationale": "Това е сериозен проблем, а не оптимизация."
            },
            {
                "text": "Когато два обекта в heap-а имат референции един към друг, което затруднява Garbage Collector-а.",
                "isCorrect": false,
                "rationale": "Съвременните GC се справят с циклични референции; проблемът е свързан с инициализацията на класовете."
            }
        ],
        "hint": "Какво се случва, ако зареждането на клас А изисква зареждане на клас Б, което от своя страна изисква зареждане на клас А?"
    },
    {
        "questionNumber": 32,
        "question": "Кой от изброените методи на `java.lang.Enum` е `final` и не може да бъде препокрит?",
        "answerOptions": [
            {
                "text": "<code>toString()</code>",
                "isCorrect": false,
                "rationale": "`toString()` може да бъде препокрит, за да предостави по-приятелско име на константата."
            },
            {
                "text": "<code>name()</code>",
                "isCorrect": true,
                "rationale": "Методът `name()` е `final` и винаги връща точно името на константата, както е декларирана в кода. `toString()` е предназначен за препокриване."
            },
            {
                "text": "<code>values()</code>",
                "isCorrect": false,
                "rationale": "`values()` е статичен метод, добавен от компилатора, и не е част от методите на инстанциите, които могат да се препокриват."
            },
            {
                "text": "<code>ordinal()</code>",
                "isCorrect": false,
                "rationale": "Въпреки че препокриването му е лоша идея, `ordinal()` не е деклариран като `final`."
            }
        ],
        "hint": "Кой метод гарантирано връща името на `enum` константата, така както е написана в кода?"
    },
    {
        "questionNumber": 33,
        "question": "Какво се случва, ако компактен конструктор на `record` промени стойността на един от параметрите си?",
        "answerOptions": [
            {
                "text": "Ще възникне грешка при компилация, защото параметрите са имплицитно `final`.",
                "isCorrect": false,
                "rationale": "Параметрите в компактния конструктор не са `final` и могат да бъдат променяни."
            },
            {
                "text": "Променената стойност ще бъде присвоена на съответното поле на `record`-а.",
                "isCorrect": true,
                "rationale": "Това е основната цел на компактния конструктор - да позволи валидация и/или нормализация (промяна) на параметрите преди имплицитното им присвояване на `final` полетата."
            },
            {
                "text": "Промяната ще бъде игнорирана и оригиналната стойност ще бъде присвоена.",
                "isCorrect": false,
                "rationale": "Промяната е валидна и се отразява на крайното състояние на обекта."
            },
            {
                "text": "Ще се хвърли `IllegalStateException` по време на изпълнение.",
                "isCorrect": false,
                "rationale": "Това е позволена и предвидена функционалност."
            }
        ],
        "hint": "Каква е разликата между параметрите на конструктора и `final` полетата на `record`-а?"
    },
    {
        "questionNumber": 34,
        "question": "Кога е възможно методът `finalize()` да бъде извикан повече от веднъж за един и същи обект?",
        "answerOptions": [
            {
                "text": "Никога, JVM гарантира, че `finalize()` се вика най-много веднъж.",
                "isCorrect": false,
                "rationale": "Има един специфичен (и опасен) сценарий, при който това е възможно."
            },
            {
                "text": "Ако `finalize()` хвърли необработено изключение.",
                "isCorrect": false,
                "rationale": "Изключения във `finalize()` се игнорират от GC и прекратяват финализацията."
            },
            {
                "text": "Ако по време на изпълнението на `finalize()` обектът бъде \"възкресен\" (resurrected) чрез създаване на нова силна референция към него.",
                "isCorrect": true,
                "rationale": "Ако обектът бъде възкресен, той няма да бъде изчистен. Ако по-късно отново стане недостъпен, GC може да го финализира отново (въпреки че спецификацията не го гарантира)."
            },
            {
                "text": "Ако изрично се извика `System.gc()` два пъти.",
                "isCorrect": false,
                "rationale": "`System.gc()` е само препоръка и не променя правилата за финализация."
            }
        ],
        "hint": "Какво може да се направи вътре в `finalize()` , за да се попречи на Garbage Collector-а да изтрие обекта?"
    },
    {
        "questionNumber": 35,
        "question": "Кое от следните НЕ може да бъде член на един `record`?",
        "answerOptions": [
            {
                "text": "Статично поле (<code>static int count;</code>).",
                "isCorrect": false,
                "rationale": "Record-ите могат да имат статични полета."
            },
            {
                "text": "Инстанционна променлива (не-статично поле), която не е част от компонентите в декларацията.",
                "isCorrect": true,
                "rationale": "Състоянието на един `record` се дефинира изцяло от неговите компоненти в декларацията. Не могат да се добавят други инстанционни полета."
            },
            {
                "text": "Вложен <code>record</code>.",
                "isCorrect": false,
                "rationale": "Record-ите могат да бъдат влагани един в друг."
            },
            {
                "text": "Инстанционен метод.",
                "isCorrect": false,
                "rationale": "Record-ите могат да имат допълнителни инстанционни методи."
            }
        ],
        "hint": "Какво определя изцяло състоянието (state) на една инстанция на `record`?"
    },
	{
        "questionNumber": 36,
        "question": "Ако метод хвърли `Checked Exception`, но то не е декларирано в `throws` клаузата му, какво ще се случи?",
        "answerOptions": [
            {
                "text": "Ще възникне грешка по време на изпълнение.",
                "isCorrect": false,
                "rationale": "Проблемът ще бъде хванат по-рано."
            },
            {
                "text": "Кодът няма да се компилира.",
                "isCorrect": true,
                "rationale": "Компилаторът налага правилото, че всяко `Checked Exception` трябва или да бъде прихванато локално, или да бъде декларирано в `throws` клаузата."
            },
            {
                "text": "Изключението ще бъде автоматично преобразувано в `RuntimeException`.",
                "isCorrect": false,
                "rationale": "Няма такъв автоматичен механизъм за преобразуване."
            },
            {
                "text": "Изключението ще бъде \"погълнато\" и програмата ще продължи.",
                "isCorrect": false,
                "rationale": "Компилаторът предотвратява тази ситуация."
            }
        ],
        "hint": "Каква е основната разлика между `Checked` и `Unchecked` изключенията по отношение на компилатора?"
    },
    {
        "questionNumber": 37,
        "question": "В контекста на Java Memory Model, какво гарантира ключовата дума `volatile`?",
        "answerOptions": [
            {
                "text": "Че достъпът до променливата ще бъде атомарен.",
                "isCorrect": false,
                "rationale": "`volatile` не гарантира атомарност за сложни операции (като инкрементиране), а само за четене/запис."
            },
            {
                "text": "Че всички промени в променливата, направени от една нишка, ще бъдат видими за другите нишки (visibility).",
                "isCorrect": true,
                "rationale": "`volatile` създава \"happens-before\" връзка, която принуждава промените да бъдат записани в главната памет и четенията да се извършват от нея, а не от локалния кеш на нишката."
            },
            {
                "text": "Че променливата няма да бъде събрана от Garbage Collector-а.",
                "isCorrect": false,
                "rationale": "Това няма връзка с жизнения цикъл на обекта."
            },
            {
                "text": "Че променливата ще бъде алокирана на stack-а вместо на heap-а.",
                "isCorrect": false,
                "rationale": "`volatile` се отнася до поведението на паметта при многонишково програмиране, а не до мястото на алокация."
            }
        ],
        "hint": "Какво решава проблема, при който една нишка работи със стара (кеширана) стойност на споделена променлива?"
    },
    {
        "questionNumber": 38,
        "question": "Може ли статичен инициализационен блок да хвърли `Checked Exception`?",
        "answerOptions": [
            {
                "text": "Да, ако го декларира с `throws`.",
                "isCorrect": false,
                "rationale": "Статичният блок не е метод и няма сигнатура, в която да се декларира `throws`."
            },
            {
                "text": "Да, но трябва да го обвие в `Unchecked Exception`, например `RuntimeException`.",
                "isCorrect": false,
                "rationale": "Въпреки че това е начин да се заобиколи проблема, има и по-директен отговор."
            },
            {
                "text": "Не, статичният блок може да хвърля само `Unchecked Exceptions` или `Error`-и.",
                "isCorrect": true,
                "rationale": "Тъй като няма кой да прихване `Checked Exception` при зареждането на класа, компилаторът не го позволява. Всяко изключение трябва да бъде обработено в самия блок или да е `Unchecked`."
            },
            {
                "text": "Да, без никакви ограничения.",
                "isCorrect": false,
                "rationale": "Компилаторът налага строги ограничения върху изключенията в статични блокове."
            }
        ],
        "hint": "Кой би могъл да постави `try-catch` около процеса на зареждане на клас?"
    },
    {
        "questionNumber": 39,
        "question": "Какво ще се случи, ако препокриете `equals()` в `record`, но не и `hashCode()`?",
        "answerOptions": [
            {
                "text": "Кодът няма да се компилира.",
                "isCorrect": false,
                "rationale": "Компилаторът ще позволи това, но е нарушение на договора между методите."
            },
            {
                "text": "Ще бъде нарушен договорът между `equals()` и `hashCode()`, което ще доведе до неправилно поведение на `HashMap`, `HashSet` и др.",
                "isCorrect": true,
                "rationale": "Ако два обекта са `equals`, но имат различен `hashCode`, те могат да се окажат в различни \"buckets\" на хеш таблица, което я прави неизползваема."
            },
            {
                "text": "Компилаторът автоматично ще генерира съответстващ `hashCode()`.",
                "isCorrect": false,
                "rationale": "Когато изрично препокриете един от методите, компилаторът спира да генерира автоматично и двата."
            },
            {
                "text": "Няма да има никакви последствия, `hashCode()` се използва рядко.",
                "isCorrect": false,
                "rationale": "`hashCode()` е от критично значение за производителността и коректността на всички хеш-базирани колекции."
            }
        ],
        "hint": "Какво се случва с автоматично генерираните методи, когато решите да предоставите своя собствена имплементация?"
    },
    {
        "questionNumber": 40,
        "question": "Кога се използва ключовата дума `transient`?",
        "answerOptions": [
            {
                "text": "За да се маркира метод, който не трябва да бъде наследяван.",
                "isCorrect": false,
                "rationale": "За тази цел се използва `final`."
            },
            {
                "text": "За да се маркира поле, което не трябва да бъде включено в процеса на сериализация.",
                "isCorrect": true,
                "rationale": "Полета, маркирани като `transient`, се игнорират от стандартния механизъм за сериализация на Java, което е полезно за временни данни или данни, които не трябва да се запазват."
            },
            {
                "text": "За да се укаже, че една променлива трябва да се пази в кеша на процесора.",
                "isCorrect": false,
                "rationale": "Това няма връзка с кеширането; `volatile` е по-близо до тази концепция."
            },
            {
                "text": "За да се декларира променлива, която съществува само по време на изпълнение на един метод.",
                "isCorrect": false,
                "rationale": "Това описва локалните променливи."
            }
        ],
        "hint": "Как можете да изключите определена чувствителна или временна информация, когато записвате състоянието на обект?"
    },
	{
        "questionNumber": 41,
        "question": "Ако един `sealed` интерфейс `Shape` има `permits Square, Circle`, където `Square` е `final record`, а `Circle` е `non-sealed class`, какво е вярно?",
        "answerOptions": [
            {
                "text": "Клас `Circle` не може да бъде наследен.",
                "isCorrect": false,
                "rationale": "Модификаторът `non-sealed` изрично позволява наследяване от всякакви други класове."
            },
            {
                "text": "`switch` израз върху `Shape` ще изисква `default` клон, за да се компилира.",
                "isCorrect": true,
                "rationale": "Тъй като `Circle` е `non-sealed`, компилаторът не знае всички възможни негови подтипове и не може да гарантира изчерпателност без `default` клон."
            },
            {
                "text": "`Square` може да бъде наследен от друг `record`.",
                "isCorrect": false,
                "rationale": "Всички `record`-и са имплицитно `final` и не могат да бъдат наследявани."
            },
            {
                "text": "Тази комбинация от модификатори е невалидна и няма да се компилира.",
                "isCorrect": false,
                "rationale": "Комбинацията е напълно валидна и представя често срещан сценарий."
            }
        ],
        "hint": "Кога компилаторът губи способността си да знае всички възможни подтипове в една йерархия?"
    },
    {
        "questionNumber": 42,
        "question": "Какво ще се случи, ако се опитате да хвърлите `null` (<code>throw null;</code>)?",
        "answerOptions": [
            {
                "text": "Ще възникне грешка при компилация.",
                "isCorrect": false,
                "rationale": "Синтаксисът е валиден, но поведението се определя по време на изпълнение."
            },
            {
                "text": "Няма да се случи нищо, операцията ще бъде игнорирана.",
                "isCorrect": false,
                "rationale": "Хвърлянето на `null` е грешка, която JVM ще регистрира."
            },
            {
                "text": "Ще се хвърли `NullPointerException` по време на изпълнение.",
                "isCorrect": true,
                "rationale": "Операторът `throw` изисква обект, който е инстанция на `Throwable`. Хвърлянето на `null` нарушава това изискване и JVM сигнализира за това с `NullPointerException`."
            },
            {
                "text": "Ще се хвърли `IllegalStateException`.",
                "isCorrect": false,
                "rationale": "Грешката е свързана с `null` референция, а не с невалидно състояние на приложението."
            }
        ],
        "hint": "Какъв тип обект очаква операторът `throw`?"
    },
    {
        "questionNumber": 43,
        "question": "Кое от следните най-добре описва `Exception Chaining`?",
        "answerOptions": [
            {
                "text": "Свързване на няколко `catch` блока един след друг.",
                "isCorrect": false,
                "rationale": "Това е обработка на различни типове изключения, а не свързването им."
            },
            {
                "text": "Процесът на обвиване на оригинално изключение (cause) в ново, по-високо ниво изключение, запазвайки оригиналния stack trace.",
                "isCorrect": true,
                "rationale": "Това позволява да се преобразуват ниско-ниво изключения (напр. `SQLException`) в специфични за приложението изключения, без да се губи информация за първопричината."
            },
            {
                "text": "Когато един метод хвърля множество различни изключения.",
                "isCorrect": false,
                "rationale": "Това се декларира в `throws` клаузата, но не е `chaining`."
            },
            {
                "text": "Когато `finally` блок хвърли изключение, което подтиска изключение от `try` блока.",
                "isCorrect": false,
                "rationale": "Това е свързано със suppressed exceptions, което е различен механизъм."
            }
        ],
        "hint": "Как можете да хвърлите ново, по-смислено изключение, без да губите информация за оригиналната грешка?"
    },
    {
        "questionNumber": 44,
        "question": "Какво е основното предимство на `enum`-ите пред статичните `final` константи (напр. <code>public static final int RED = 0;</code>)?",
        "answerOptions": [
            {
                "text": "Заемат по-малко памет.",
                "isCorrect": false,
                "rationale": "Като обекти, `enum`-ите заемат повече памет от обикновени `int` константи."
            },
            {
                "text": "Предоставят типова безопасност (type safety).",
                "isCorrect": true,
                "rationale": "Метод, който очаква `enum Day`, не може случайно да получи `enum Color`. При `int` константите, метод очакващ цвят може да получи ден, ако и двата са `int`."
            },
            {
                "text": "По-бързи са за сравнение.",
                "isCorrect": false,
                "rationale": "Сравнението на `int` е изключително бързо; `enum` сравнението (`==`) също е бързо, но не е това основното предимство."
            },
            {
                "text": "По-лесни са за дебъгване.",
                "isCorrect": false,
                "rationale": "Въпреки че имат смислени имена, основното предимство е свързано с компилатора, а не с дебъгера."
            }
        ],
        "hint": "Какво пречи на един метод, който очаква ден от седмицата, да получи цвят, ако и двете са представени като числа?"
    },
    {
        "questionNumber": 45,
        "question": "Ако имате статичен инициализационен блок, който се проваля с изключение, какво ще се случи при следващ опит за използване на същия клас?",
        "answerOptions": [
            {
                "text": "Статичният блок ще се изпълни отново.",
                "isCorrect": false,
                "rationale": "Процесът на инициализация на клас се опитва само веднъж."
            },
            {
                "text": "Ще бъде хвърлен `NoClassDefFoundError`.",
                "isCorrect": true,
                "rationale": "Първият опит се проваля с `ExceptionInInitializerError`. JVM маркира класа като неуспешно инициализиран и всички последващи опити за достъп до него водят до `NoClassDefFoundError`."
            },
            {
                "text": "Ще бъде хвърлен отново `ExceptionInInitializerError`.",
                "isCorrect": false,
                "rationale": "Първоначалната грешка е `ExceptionInInitializerError`, но последващите са от друг тип."
            },
            {
                "text": "Класът ще бъде зареден успешно, но статичните полета ще са `null`.",
                "isCorrect": false,
                "rationale": "Класът се счита за негоден за употреба след провал в статичната инициализация."
            }
        ],
        "hint": "Какво се случва с клас, чиято инициализация се е провалила веднъж?"
    },
    {
        "questionNumber": 46,
        "question": "Кое от следните е вярно за локалните `record`-и, дефинирани вътре в метод?",
        "answerOptions": [
            {
                "text": "Те могат да достъпват само `final` или ефективно `final` локални променливи от обхвата на метода.",
                "isCorrect": true,
                "rationale": "Подобно на анонимните класове и ламбда изразите, те могат да \"уловят\" (capture) променливи от заобикалящия ги обхват, но само ако те не се променят."
            },
            {
                "text": "Те не могат да имат конструктори или методи.",
                "isCorrect": false,
                "rationale": "Локалните `record`-и имат същите възможности като обикновените, включително конструктори и методи."
            },
            {
                "text": "Те са видими за всички други методи в същия клас.",
                "isCorrect": false,
                "rationale": "Тяхната видимост е строго ограничена до метода, в който са дефинирани."
            },
            {
                "text": "Те не могат да бъдат статични.",
                "isCorrect": false,
                "rationale": "Ако са дефинирани в статичен метод, те са имплицитно статични."
            }
        ],
        "hint": "Какви са правилата за достъп до локални променливи от ламбда изрази?"
    },
    {
        "questionNumber": 47,
        "question": "Каква е разликата в поведението на `equals()` за `record` и за `enum`?",
        "answerOptions": [
            {
                "text": "И в двата случая сравнява по съдържание.",
                "isCorrect": false,
                "rationale": "`enum` има по-специфично поведение поради гарантираната уникалност на инстанциите."
            },
            {
                "text": "`record` сравнява по съдържание, докато `enum` използва сравнение по референция (<code>==</code>), наследено от `Object`.",
                "isCorrect": false,
                "rationale": "`Enum` не използва `equals` от `Object`, а има своя собствена `final` имплементация."
            },
            {
                "text": "`record` сравнява по съдържание (стойностите на компонентите), докато за `enum` сравнението по референция е достатъчно и гарантирано.",
                "isCorrect": true,
                "rationale": "Тъй като за всяка `enum` константа има само една инстанция в JVM, сравнението на референциите с `==` е еквивалентно на `equals()` и е по-бързо."
            },
            {
                "text": "И в двата случая се сравняват референциите.",
                "isCorrect": false,
                "rationale": "`record` имплементацията на `equals()` изрично сравнява състоянието на полетата."
            }
        ],
        "hint": "За кой от двата типа има гаранция, че `MyType.CONSTANT == MyType.CONSTANT` винаги ще е вярно?"
    },
    {
        "questionNumber": 48,
        "question": "Кой е основният недостатък на използването на `finalize()` метода за освобождаване на ресурси?",
        "answerOptions": [
            {
                "text": "Той може да хвърля само `RuntimeException`.",
                "isCorrect": false,
                "rationale": "Въпреки че хвърлянето на изключения от `finalize` е лоша идея, това не е основният му недостатък."
            },
            {
                "text": "Няма гаранция кога и дали изобщо ще бъде извикан.",
                "isCorrect": true,
                "rationale": "Недетерминистичното поведение на Garbage Collector-а прави `finalize()` напълно ненадежден за освобождаване на критични ресурси като файлове или мрежови връзки."
            },
            {
                "text": "Той работи само за обекти в stack паметта.",
                "isCorrect": false,
                "rationale": "Финализацията е свързана с обекти в heap паметта."
            },
            {
                "text": "Той забавя създаването на обекти.",
                "isCorrect": false,
                "rationale": "Той забавя унищожаването на обекти, а не създаването им."
            }
        ],
        "hint": "Какъв е по-надеждният и модерен механизъм за управление на ресурси, въведен в Java 7?"
    },
    {
        "questionNumber": 49,
        "question": "Ако имате <code>public sealed interface Pet permits Dog, Cat {}</code> и <code>final class Dog implements Pet {}</code>, но <code>Cat</code> не е дефиниран, какво ще се случи?",
        "answerOptions": [
            {
                "text": "Кодът ще се компилира, но ще даде грешка при изпълнение, когато се опита да се използва `Cat`.",
                "isCorrect": false,
                "rationale": "Компилаторът проверява за съществуването на всички класове в `permits` списъка."
            },
            {
                "text": "Кодът няма да се компилира, защото класът `Cat`, упоменат в `permits`, не съществува.",
                "isCorrect": true,
                "rationale": "Компилаторът изисква всички класове, изброени в `permits` клаузата, да съществуват и да наследяват/имплементират `sealed` типа."
            },
            {
                "text": "Кодът ще се компилира, приемайки, че `Cat` ще бъде дефиниран в друг файл.",
                "isCorrect": false,
                "rationale": "Компилаторът трябва да може да намери дефиницията по време на компилация."
            },
            {
                "text": "Кодът ще се компилира с предупреждение.",
                "isCorrect": false,
                "rationale": "Това се счита за грешка, а не за предупреждение."
            }
        ],
        "hint": "Какви проверки прави компилаторът, когато види `permits` клауза?"
    },
    {
        "questionNumber": 50,
        "question": "Коя е причината `record`-ите да са добро решение за ключове в `HashMap`?",
        "answerOptions": [
            {
                "text": "Защото са малки и заемат малко памет.",
                "isCorrect": false,
                "rationale": "Размерът им зависи от компонентите; това не е основната причина."
            },
            {
                "text": "Защото автоматично генерират консистентни имплементации на `equals()` и `hashCode()`, базирани на състоянието им.",
                "isCorrect": true,
                "rationale": "Правилната и консистентна имплементация на `equals()` и `hashCode()` е абсолютно задължителна за коректната работа на `HashMap`. Record-ите предоставят това безплатно."
            },
            {
                "text": "Защото имат бърз каноничен конструктор.",
                "isCorrect": false,
                "rationale": "Скоростта на конструктора не влияе на поведението им като ключове в `HashMap`."
            },
            {
                "text": "Защото имплементират интерфейса `Comparable` по подразбиране.",
                "isCorrect": false,
                "rationale": "Те не имплементират `Comparable` по подразбиране, това трябва да се направи изрично."
            }
        ],
        "hint": "Какви са двете най-важни изисквания към обектите, които се използват като ключове в хеш-базирани колекции?"
    }
]
        };

        const questionTextEl = document.getElementById('question-text');
        const answersAreaEl = document.getElementById('answers-area');
        const nextBtn = document.getElementById('next-btn');
        const progressTextEl = document.getElementById('progress-text');
        const resultsAreaEl = document.getElementById('results-area');
        const scoreTextEl = document.getElementById('score-text');
        const restartBtn = document.getElementById('restart-btn');
        const hintTextEl = document.getElementById('hint-text');
        const quizContainer = document.getElementById('quiz-container');
        const navigationAreaEl = document.getElementById('navigation-area');

        let currentQuestionIndex = 0;
        let score = 0;

        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            resultsAreaEl.classList.add('hidden');
            quizContainer.querySelector('#quiz-header').classList.remove('hidden');
            questionTextEl.parentElement.classList.remove('hidden');
            answersAreaEl.classList.remove('hidden');
            hintTextEl.parentElement.classList.remove('hidden');
            navigationAreaEl.classList.remove('hidden');
            nextBtn.classList.add('hidden');
            loadQuestion();
        }

        function loadQuestion() {
            resetState();
            const currentQuestion = quizData.questions[currentQuestionIndex];
            questionTextEl.innerHTML = currentQuestion.question; // Use innerHTML for code tags
            hintTextEl.innerText = `Подсказка: ${currentQuestion.hint}`;
            progressTextEl.innerText = `Въпрос ${currentQuestionIndex + 1} от ${quizData.questions.length}`;

            currentQuestion.answerOptions.forEach(answer => {
                const button = document.createElement('button');
                button.innerHTML = answer.text; // Use innerHTML for code tags
                button.classList.add('answer-btn', 'w-full', 'text-left', 'p-4', 'border-2', 'rounded-lg', 'bg-white', 'hover:bg-indigo-50', 'hover:border-indigo-400');
                if (answer.isCorrect) {
                    button.dataset.correct = true;
                }
                button.dataset.rationale = answer.rationale;
                button.addEventListener('click', selectAnswer);
                answersAreaEl.appendChild(button);
            });
        }

        function resetState() {
            nextBtn.classList.add('hidden');
            hintTextEl.innerText = '';
            while (answersAreaEl.firstChild) {
                answersAreaEl.removeChild(answersAreaEl.firstChild);
            }
        }

        function selectAnswer(e) {
            // Use currentTarget to ensure we get the button even if a child element (like <code>) is clicked
            const selectedBtn = e.currentTarget;
            const isCorrect = selectedBtn.dataset.correct === 'true';

            if (isCorrect) {
                score++;
                selectedBtn.classList.add('correct');
            } else {
                selectedBtn.classList.add('incorrect');
            }
            
            Array.from(answersAreaEl.children).forEach(button => {
                if(button.nodeName === 'BUTTON') { // Ensure we only process buttons, not rationales
                    if (button.dataset.correct === 'true') {
                        button.classList.add('correct');
                    }
                    button.disabled = true;
                    
                    const rationaleEl = document.createElement('div');
                    rationaleEl.classList.add('rationale');
                    rationaleEl.innerText = button.dataset.rationale;
                    button.parentNode.insertBefore(rationaleEl, button.nextSibling);
                }
            });

            if (quizData.questions.length > currentQuestionIndex + 1) {
                nextBtn.classList.remove('hidden');
            } else {
                showResults();
            }
        }

        function showResults() {
            questionTextEl.parentElement.classList.add('hidden');
            answersAreaEl.classList.add('hidden');
            nextBtn.classList.add('hidden');
            hintTextEl.parentElement.classList.add('hidden');
            navigationAreaEl.classList.add('hidden');

            quizContainer.querySelector('#quiz-header').classList.add('hidden');

            resultsAreaEl.classList.remove('hidden');
            scoreTextEl.innerText = `Вашият резултат: ${score} от ${quizData.questions.length} верни отговора.`;
        }

        nextBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            loadQuestion();
        });

        restartBtn.addEventListener('click', startQuiz);

        startQuiz();
    </script>
</body>
</html>
