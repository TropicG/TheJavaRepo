<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест по Java: ОПП и Памет</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .quiz-container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: #f9fafb;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .answer-btn {
            transition: all 0.2s ease-in-out;
        }
        .answer-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .correct {
            background-color: #10b981 !important;
            color: white !important;
            border-color: #059669 !important;
        }
        .incorrect {
            background-color: #ef4444 !important;
            color: white !important;
            border-color: #dc2626 !important;
        }
        .rationale {
            font-size: 0.875rem;
            margin-top: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: #e5e7eb;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="quiz-container" class="quiz-container">
        <div id="quiz-header" class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-900 mb-2">Тест по Java: ОПП и Памет</h1>
            <p id="progress-text" class="text-gray-600">Въпрос 1 от 50</p>
        </div>
        
        <div id="question-area" class="mb-6">
            <h2 id="question-text" class="text-xl font-semibold mb-4 text-center">Зареждане на въпрос...</h2>
        </div>

        <div id="answers-area" class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <!-- Answer buttons will be generated here -->
        </div>

        <div id="feedback-area" class="mt-6">
             <p id="hint-text" class="text-sm text-gray-500 italic text-center p-2 border border-dashed rounded-md"></p>
        </div>

        <div id="navigation-area" class="mt-8 flex justify-center">
            <button id="next-btn" class="hidden bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-indigo-700 transition-colors">Следващ въпрос</button>
        </div>

        <div id="results-area" class="hidden text-center">
            <h2 class="text-2xl font-bold mb-4">Тестът приключи!</h2>
            <p id="score-text" class="text-3xl font-bold mb-6"></p>
            <button id="restart-btn" class="bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-indigo-700 transition-colors">Започни отначало</button>
        </div>
    </div>

    <script>
        const quizData = {
            "questions": [{
                "questionNumber": 1,
                "question": "Какво се случва, когато примитивен тип данни се предава като аргумент на метод в Java?",
                "answerOptions": [{
                    "text": "Методът получава референция към оригиналната променлива.",
                    "isCorrect": false,
                    "rationale": "Референции се използват за обекти, а не за примитивни типове."
                }, {
                    "text": "Създава се копие на стойността и се предава на метода.",
                    "isCorrect": true,
                    "rationale": "Това е известно като \"предаване по стойност\" (pass-by-value) и гарантира, че оригиналната променлива остава непроменена."
                }, {
                    "text": "Оригиналната променлива се променя, ако методът промени параметъра.",
                    "isCorrect": false,
                    "rationale": "Тъй като методът работи с копие, промените в него не засягат оригиналната променлива."
                }, {
                    "text": "Променливата се премества от stack-а на извикващия метод в stack-а на извиквания метод.",
                    "isCorrect": false,
                    "rationale": "Паметта се заделя в новия фрейм на стека за параметъра, но не става въпрос за \"преместване\"."
                }],
                "hint": "Помислете за разликата между \"предаване по стойност\" и \"предаване по референция\"."
            }, {
                "questionNumber": 2,
                "question": "Къде се съхраняват обектите и масивите в Java по време на изпълнение на програмата?",
                "answerOptions": [{
                    "text": "В stack паметта.",
                    "isCorrect": false,
                    "rationale": "Stack паметта съхранява локални променливи и референции, но не и самите обекти."
                }, {
                    "text": "В heap паметта.",
                    "isCorrect": true,
                    "rationale": "Heap паметта е динамично заделена област, предназначена за съхранение на всички обекти и масиви."
                }, {
                    "text": "В регистрите на процесора.",
                    "isCorrect": false,
                    "rationale": "Регистрите се използват за много бързи, временни изчисления, а не за съхранение на обекти."
                }, {
                    "text": "В статичната област на паметта.",
                    "isCorrect": false,
                    "rationale": "Статичната област съхранява статични членове на класовете, но не и инстанциите (обектите), създадени по време на работа."
                }],
                "hint": "Коя област от паметта се управлява от Garbage Collector-а?"
            }, {
                "questionNumber": 3,
                "question": "Коя грешка се хвърля, ако stack паметта се запълни, например при безкрайна рекурсия?",
                "answerOptions": [{
                    "text": "java.lang.OutOfMemoryError",
                    "isCorrect": false,
                    "rationale": "Тази грешка се свързва със запълване на heap паметта, а не на stack-а."
                }, {
                    "text": "java.lang.NullPointerException",
                    "isCorrect": false,
                    "rationale": "Тази грешка възниква при опит за достъп до член на null референция."
                }, {
                    "text": "java.lang.StackOverflowError",
                    "isCorrect": true,
                    "rationale": "Тази грешка индикира, че стекът на извикванията е надхвърлил своя капацитет."
                }, {
                    "text": "java.lang.IllegalArgumentException",
                    "isCorrect": false,
                    "rationale": "Тази грешка се хвърля, когато на метод са подадени невалидни аргументи."
                }],
                "hint": "Името на грешката често описва проблема, който я е причинил."
            }, {
                "questionNumber": 4,
                "question": "Каква е основната разлика при предаване на референтен тип като аргумент в сравнение с примитивен тип?",
                "answerOptions": [{
                    "text": "Създава се пълно копие на обекта.",
                    "isCorrect": false,
                    "rationale": "Копира се само референцията (адресът), а не целият обект."
                }, {
                    "text": "Методът получава копие на референцията към обекта.",
                    "isCorrect": true,
                    "rationale": "Това позволява на метода да достъпва и променя състоянието на оригиналния обект."
                }, {
                    "text": "Обектът не може да бъде променян вътре в метода.",
                    "isCorrect": false,
                    "rationale": "Точно обратното, състоянието на обекта може да бъде променяно чрез копието на референцията."
                }, {
                    "text": "Няма никаква разлика, и двата типа се предават по стойност.",
                    "isCorrect": false,
                    "rationale": "Въпреки че технически референцията се предава по стойност, ефектът е различен, защото позволява промяна на оригиналния обект."
                }],
                "hint": "Какво точно се копира, когато предаваме обект на метод?"
            }, {
                "questionNumber": 5,
                "question": "Кой е отговорен за освобождаването на паметта, заета от обекти в heap-а, които вече не се използват?",
                "answerOptions": [{
                    "text": "Програмистът, чрез изрична команда.",
                    "isCorrect": false,
                    "rationale": "В езици като C++ програмистът управлява паметта, но в Java това е автоматизирано."
                }, {
                    "text": "Операционната система.",
                    "isCorrect": false,
                    "rationale": "Операционната система управлява паметта на ниво процеси, но не и обектите вътре в JVM."
                }, {
                    "text": "Garbage Collector (Сметосъбирач).",
                    "isCorrect": true,
                    "rationale": "Това е автоматичен процес в JVM, който идентифицира и изтрива недостъпни обекти."
                }, {
                    "text": "Компилаторът по време на компилация.",
                    "isCorrect": false,
                    "rationale": "Управлението на паметта за обекти се случва по време на изпълнение, а не по време на компилация."
                }],
                "hint": "Кой механизъм в Java предотвратява \"изтичане на памет\" (memory leaks)?"
            }, {
                "questionNumber": 6,
                "question": "Кога се изпълнява статичен инициализационен блок (static initializer)?",
                "answerOptions": [{
                    "text": "Всеки път, когато се създава нов обект от класа.",
                    "isCorrect": false,
                    "rationale": "Това описва поведението на нестатичен инициализатор или конструктор."
                }, {
                    "text": "Само веднъж, когато класът бъде зареден в паметта за първи път.",
                    "isCorrect": true,
                    "rationale": "Статичните блокове са свързани със самия клас, а не с неговите инстанции, и се изпълняват при зареждането на класа."
                }, {
                    "text": "Когато се извика статичен метод на класа.",
                    "isCorrect": false,
                    "rationale": "Извикването на статичен метод може да предизвика зареждане на класа (и изпълнение на блока), но блокът се изпълнява при зареждането, а не при всяко извикване."
                }, {
                    "text": "Никога не се изпълнява автоматично, трябва да бъде извикан изрично.",
                    "isCorrect": false,
                    "rationale": "Инициализационните блокове са анонимни и се изпълняват автоматично от JVM."
                }],
                "hint": "Какво означава ключовата дума 'static' в контекста на членове на клас?"
            }, {
                "questionNumber": 7,
                "question": "Какъв е редът на инициализация при създаване на обект от производен клас `Dog`, който наследява `Animal`?",
                "answerOptions": [{
                    "text": "Конструктор на Animal -> Конструктор на Dog -> Инициализатори на Animal -> Инициализатори на Dog.",
                    "isCorrect": false,
                    "rationale": "Инициализаторите винаги се изпълняват преди конструкторите на съответния клас."
                }, {
                    "text": "Статични инициализатори на Animal -> Статични на Dog -> Нестатични на Animal -> Конструктор на Animal -> Нестатични на Dog -> Конструктор на Dog.",
                    "isCorrect": true,
                    "rationale": "Този ред правилно описва пълния процес, започвайки от статичната инициализация на базовия клас и завършвайки с конструктора на производния."
                }, {
                    "text": "Статични инициализатори на Dog -> Статични на Animal -> Конструктор на Dog -> Конструктор на Animal.",
                    "isCorrect": false,
                    "rationale": "Инициализацията винаги започва от върха на йерархията (базовия клас) и слиза надолу."
                }, {
                    "text": "Нестатични инициализатори на Dog -> Конструктор на Dog -> Нестатични на Animal -> Конструктор на Animal.",
                    "isCorrect": false,
                    "rationale": "Редът на изпълнение е от базовия към производния клас, а не обратно."
                }],
                "hint": "Инициализацията следва йерархията на наследяване отгоре-надолу."
            }, {
                "questionNumber": 8,
                "question": "Кое от следните твърдения за `enum` в Java е НЕВЯРНО?",
                "answerOptions": [{
                    "text": "Всеки `enum` имплицитно наследява `java.lang.Enum`.",
                    "isCorrect": false,
                    "rationale": "Това е вярно. Компилаторът автоматично добавя `extends java.lang.Enum`."
                }, {
                    "text": "Конструкторът на `enum` може да бъде `public`.",
                    "isCorrect": true,
                    "rationale": "Това е невярно. Конструкторите трябва да са `private` или `package-private`, за да се гарантира, че не могат да се създават нови инстанции извън дефиницията на `enum`-а."
                }, {
                    "text": "Един `enum` може да имплементира интерфейси.",
                    "isCorrect": false,
                    "rationale": "Това е вярно. Въпреки че не може да наследява друг клас, `enum` може да имплементира един или повече интерфейси."
                }, {
                    "text": "Компилаторът добавя статичен метод `values()`, който връща масив с всички константи.",
                    "isCorrect": false,
                    "rationale": "Това е вярно и е удобен начин за итериране през всички възможни стойности на `enum`-а."
                }],
                "hint": "Каква е основната цел на `enum` и как се гарантира фиксираният брой инстанции?"
            }, {
                "questionNumber": 9,
                "question": "Какво прави статичният метод `valueOf(String name)`, който компилаторът добавя към всеки `enum`?",
                "answerOptions": [{
                    "text": "Връща масив от всички константи в `enum`-а.",
                    "isCorrect": false,
                    "rationale": "Това се прави от метода `values()`."
                }, {
                    "text": "Проверява дали подаденият низ съществува като константа.",
                    "isCorrect": false,
                    "rationale": "Методът не връща `boolean`, а самата константа или хвърля изключение."
                }, {
                    "text": "Връща `enum` константата, която съответства на подаденото име.",
                    "isCorrect": true,
                    "rationale": "Този метод е полезен за преобразуване на текстов низ в съответната `enum` инстанция."
                }, {
                    "text": "Връща поредния номер (ordinal) на константата.",
                    "isCorrect": false,
                    "rationale": "За това се използва методът `ordinal()`, който е наследен от `java.lang.Enum`."
                }],
                "hint": "Как бихте преобразували низ, получен от потребител, в `enum` стойност?"
            }, {
                "questionNumber": 10,
                "question": "Какво представлява `Boilerplate` кодът в Java?",
                "answerOptions": [{
                    "text": "Код, който се изпълнява при стартиране на виртуалната машина.",
                    "isCorrect": false,
                    "rationale": "Това е по-скоро част от инициализацията на JVM, а не повтарящ се код в класовете."
                }, {
                    "text": "Повтарящ се, стандартен код, който се пише за прости класове-преносители на данни (като конструктори, getters, `equals()`).",
                    "isCorrect": true,
                    "rationale": "Това е точното определение. `Records` са създадени, за да решат този проблем."
                }, {
                    "text": "Код за обработка на изключения.",
                    "isCorrect": false,
                    "rationale": "Кодът за обработка на изключения е важна част от логиката, а не непременно `boilerplate`."
                }, {
                    "text": "Оптимизиран код, генериран от компилатора.",
                    "isCorrect": false,
                    "rationale": "`Boilerplate` е код, който програмистът пише ръчно, а не такъв, генериран за оптимизация."
                }],
                "hint": "Коя нова функционалност в Java е предназначена да намали този тип код?"
            }, {
                "questionNumber": 11,
                "question": "Кое от следните НЕ се генерира автоматично от компилатора за един `record`?",
                "answerOptions": [{
                    "text": "`private final` член-данни за всеки компонент.",
                    "isCorrect": false,
                    "rationale": "Компилаторът генерира `private final` полета, за да осигури неизменяемост (immutability)."
                }, {
                    "text": "Каноничен конструктор, който приема всички компоненти.",
                    "isCorrect": false,
                    "rationale": "Това е основният конструктор, който инициализира всички полета."
                }, {
                    "text": "Setter методи за всяко поле.",
                    "isCorrect": true,
                    "rationale": "`Records` са неизменяеми, поради което нямат setter методи. Генерират се само accessor (getter) методи."
                }, {
                    "text": "Имплементации на `equals()`, `hashCode()` и `toString()`.",
                    "isCorrect": false,
                    "rationale": "Тези методи се генерират автоматично и се базират на стойностите на компонентите, което е голямо улеснение."
                }],
                "hint": "Помислете за основната характеристика на `record` - неизменяемост (immutability)."
            }, {
                "questionNumber": 12,
                "question": "Какво означава, че един `record` е \"shallowly immutable\" (плитко неизменяем)?",
                "answerOptions": [{
                    "text": "Състоянието на `record`-а може да се променя свободно.",
                    "isCorrect": false,
                    "rationale": "Това противоречи на основната идея за неизменяемост."
                }, {
                    "text": "Референциите към полетата не могат да се променят, но ако полето е изменяем обект (като `ArrayList`), неговото вътрешно състояние може да се промени.",
                    "isCorrect": true,
                    "rationale": "Това е точното определение. `final` референцията не може да сочи другаде, но обектът, към който сочи, може да бъде променен."
                }, {
                    "text": "Само примитивните типове в `record`-а са неизменяеми.",
                    "isCorrect": false,
                    "rationale": "Неизменяемостта се отнася до всички полета, но ефектът е различен за примитивни и референтни типове."
                }, {
                    "text": "Неизменяемостта се прилага само за първото ниво на вложеност.",
                    "isCorrect": false,
                    "rationale": "Терминът \"shallow\" (плитко) се отнася до това, че самата референция е `final`, а не до състоянието на реферирания обект."
                }],
                "hint": "Какво се случва, ако едно от полетата на `record` е списък (`List`) и извикате метода `add()` върху него?"
            }, {
                "questionNumber": 13,
                "question": "Каква е целта на компактния конструктор в един `record`?",
                "answerOptions": [{
                    "text": "Да замени напълно каноничния конструктор.",
                    "isCorrect": false,
                    "rationale": "Компактният конструктор добавя логика към каноничния, а не го заменя."
                }, {
                    "text": "Да добави валидация или нормализация на параметрите преди присвояването им.",
                    "isCorrect": true,
                    "rationale": "Той е предназначен за проверки и евентуална трансформация на входните данни, докато присвояването остава работа на каноничния конструктор."
                }, {
                    "text": "Да позволи създаването на `record` без параметри.",
                    "isCorrect": false,
                    "rationale": "Компактният конструктор няма списък с параметри в декларацията си, но работи с параметрите на каноничния конструктор."
                }, {
                    "text": "Да инициализира само част от полетата.",
                    "isCorrect": false,
                    "rationale": "Всички полета на `record`-а трябва да бъдат инициализирани; компактният конструктор служи за валидация преди това."
                }],
                "hint": "Как бихте се уверили, че дадено числово поле в `record` е винаги положително?"
            }, {
                "questionNumber": 14,
                "question": "Кое от следните твърдения за `record` класовете е ВЯРНО?",
                "answerOptions": [{
                    "text": "Те могат да наследяват други класове.",
                    "isCorrect": false,
                    "rationale": "Това е невярно, тъй като те имплицитно наследяват `java.lang.Record`."
                }, {
                    "text": "Те са `abstract` по подразбиране.",
                    "isCorrect": false,
                    "rationale": "Те са `final` по подразбиране, което е обратното на `abstract`."
                }, {
                    "text": "Всички `record` класове имплицитно наследяват `java.lang.Record`.",
                    "isCorrect": true,
                    "rationale": "Това е вярно и е причината те да не могат да наследяват други класове."
                }, {
                    "text": "Техните полета са `public` по подразбиране.",
                    "isCorrect": false,
                    "rationale": "Полетата са `private final`, а достъпът до тях става чрез автоматично генерирани `public` accessor методи."
                }],
                "hint": "Каква е базовата суперкласа за всички `record` типове?"
            }, {
                "questionNumber": 15,
                "question": "Какво позволяват `sealed` класовете и интерфейсите в Java?",
                "answerOptions": [{
                    "text": "Да се създават класове, които не могат да бъдат инстанцирани.",
                    "isCorrect": false,
                    "rationale": "Това се постига с `abstract` класове или `private` конструктори."
                }, {
                    "text": "Да се контролира точно кои други класове могат да ги наследяват.",
                    "isCorrect": true,
                    "rationale": "Това е основната цел на `sealed` класовете - да се дефинира затворена, изчерпателна йерархия."
                }, {
                    "text": "Да се създават неизменяеми (immutable) класове.",
                    "isCorrect": false,
                    "rationale": "Неизменяемостта се постига с `final` полета и липса на setters, докато `sealed` се отнася до наследяването."
                }, {
                    "text": "Да се дефинират класове, които могат да бъдат наследени само веднъж.",
                    "isCorrect": false,
                    "rationale": "`sealed` контролира *кои* класове могат да наследяват, а не колко пъти."
                }],
                "hint": "Помислете за проблема с неконтролируемото разширяване на една класова йерархия."
            }, {
                "questionNumber": 16,
                "question": "Ако имаме `public sealed class Shape permits Circle, Square`, какъв трябва да бъде статусът на клас `Circle`?",
                "answerOptions": [{
                    "text": "Той трябва да е `public`.",
                    "isCorrect": false,
                    "rationale": "Въпреки че често е `public`, изискването е свързано с контрола на по-нататъшното наследяване."
                }, {
                    "text": "Той трябва да е `abstract`.",
                    "isCorrect": false,
                    "rationale": "Не е задължително да е `abstract`, може да е и конкретен клас."
                }, {
                    "text": "Той трябва да бъде деклариран като `final`, `sealed` или `non-sealed`.",
                    "isCorrect": true,
                    "rationale": "Всеки пряк наследник на `sealed` клас трябва изрично да определи своя статус по отношение на по-нататъшното наследяване."
                }, {
                    "text": "Той трябва да бъде в различен пакет от `Shape`.",
                    "isCorrect": false,
                    "rationale": "Точно обратното, `sealed` класът и неговите разрешени наследници трябва да са в един и същ пакет."
                }],
                "hint": "Какво трябва да направи всеки наследник, за да продължи (или спре) веригата на контролирано наследяване?"
            }, {
                "questionNumber": 17,
                "question": "Какво означава един наследник на `sealed` клас да бъде деклариран като `non-sealed`?",
                "answerOptions": [{
                    "text": "Той не може да бъде наследяван.",
                    "isCorrect": false,
                    "rationale": "Това се постига с `final`."
                }, {
                    "text": "Той премахва ограничението и позволява на всеки друг клас да го наследи.",
                    "isCorrect": true,
                    "rationale": "Това \"отваря\" йерархията отново в тази точка, връщайки се към класическото поведение на наследяване."
                }, {
                    "text": "Той може да бъде наследен само от класове в същия пакет.",
                    "isCorrect": false,
                    "rationale": "Това е поведение, което се постига с `package-private` достъп, а не с `non-sealed`."
                }, {
                    "text": "Това е синтактична грешка, наследникът трябва да е `final` или `sealed`.",
                    "isCorrect": false,
                    "rationale": "`non-sealed` е третата валидна опция, която позволява отваряне на йерархията."
                }],
                "hint": "Какво се случва, ако искате да позволите на други разработчици да разширяват вашата `sealed` йерархия?"
            }, {
                "questionNumber": 18,
                "question": "Как `sealed` класовете помагат на компилатора и IDE-то?",
                "answerOptions": [{
                    "text": "Намаляват размера на компилирания .class файл.",
                    "isCorrect": false,
                    "rationale": "Ефектът е върху статичния анализ, а не непременно върху размера на файла."
                }, {
                    "text": "Позволяват на компилатора да знае всички възможни подтипове и да прави по-добри проверки, например в `switch` изрази.",
                    "isCorrect": true,
                    "rationale": "Когато компилаторът познава цялата йерархия, той може да провери дали един `switch` е изчерпателен, премахвайки нуждата от `default` клон."
                }, {
                    "text": "Автоматично правят всички методи `final`.",
                    "isCorrect": false,
                    "rationale": "`sealed` се отнася до наследяването на класа, а не до това дали методите му могат да бъдат препокривани (overridden)."
                }, {
                    "text": "Гарантират, че класът ще бъде зареден по-бързо от JVM.",
                    "isCorrect": false,
                    "rationale": "Ползите са свързани с безопасността на типовете и статичния анализ по време на компилация, а не с производителността при зареждане."
                }],
                "hint": "Какво се случва, когато използвате `switch` върху `sealed` тип и пропуснете някой от наследниците?"
            }, {
                "questionNumber": 19,
                "question": "Кое от следните е `Checked Exception`?",
                "answerOptions": [{
                    "text": "`NullPointerException`",
                    "isCorrect": false,
                    "rationale": "Това е `RuntimeException` (Unchecked), обикновено причинен от програмна грешка."
                }, {
                    "text": "`IOException`",
                    "isCorrect": true,
                    "rationale": "Това е класически пример за `Checked Exception`, тъй като операциите с файлове и мрежа могат да се провалят по външни причини и компилаторът изисква обработка."
                }, {
                    "text": "`StackOverflowError`",
                    "isCorrect": false,
                    "rationale": "Това е `Error`, а не `Exception`, и сигнализира за сериозен проблем в JVM."
                }, {
                    "text": "`ArrayIndexOutOfBoundsException`",
                    "isCorrect": false,
                    "rationale": "Това е `RuntimeException` (Unchecked), причинен от логическа грешка в кода."
                }],
                "hint": "Кой тип изключения компилаторът ви задължава да обработите с `try-catch` или да декларирате с `throws`?"
            }, {
                "questionNumber": 20,
                "question": "Какво представлява `stack trace`?",
                "answerOptions": [{
                    "text": "Списък с всички променливи в stack паметта.",
                    "isCorrect": false,
                    "rationale": "Stack trace не показва стойностите на променливите, а последователността на извикванията."
                }, {
                    "text": "Докладна записка за грешки, изпратена до разработчиците на Java.",
                    "isCorrect": false,
                    "rationale": "Това е локална информация за изпълнението на вашата програма."
                }, {
                    "text": "Списък на методите в стека на извикванията в момента, в който е възникнало изключението.",
                    "isCorrect": true,
                    "rationale": "Той показва пътя на изпълнение на програмата, който е довел до грешката, което е изключително полезно за дебъгване."
                }, {
                    "text": "Описание на състоянието на heap паметта.",
                    "isCorrect": false,
                    "rationale": "За анализ на heap-а се използват други инструменти (profilers), а не stack trace."
                }],
                "hint": "Каква информация ви е нужна, за да разберете къде и как е възникнала грешка?"
            }, {
                "questionNumber": 21,
                "question": "Защо обикновено е лоша идея да се прихващат (`catch`) `Error`-и като `OutOfMemoryError`?",
                "answerOptions": [{
                    "text": "Защото компилаторът не го позволява.",
                    "isCorrect": false,
                    "rationale": "Компилаторът го позволява синтактично, но това е считано за лоша практика."
                }, {
                    "text": "Защото `Error`-ите не носят полезна информация.",
                    "isCorrect": false,
                    "rationale": "Те носят много важна информация за критично състояние на JVM."
                }, {
                    "text": "Защото JVM е в нестабилно състояние и опитът за възстановяване може да доведе до непредсказуемо поведение.",
                    "isCorrect": true,
                    "rationale": "Прихващането на `Error` не решава основния проблем (например липса на памет) и програмата не може да продължи да работи надеждно."
                }, {
                    "text": "Защото те трябва да се декларират с `throws`, а не да се прихващат.",
                    "isCorrect": false,
                    "rationale": "`Error`-ите са като Unchecked Exceptions и не се изисква да бъдат декларирани."
                }],
                "hint": "Може ли едно приложение да се възстанови надеждно, ако виртуалната машина няма повече памет?"
            }, {
                "questionNumber": 22,
                "question": "Кой е директният родителски клас в йерархията на изключенията за всички `Checked` и `Unchecked` изключения?",
                "answerOptions": [{
                    "text": "`java.lang.Object`",
                    "isCorrect": false,
                    "rationale": "`Object` е родител на всичко в Java, но не е директният родител само на изключенията."
                }, {
                    "text": "`java.lang.Throwable`",
                    "isCorrect": false,
                    "rationale": "`Throwable` е родител на `Exception` и `Error`, но `Exception` е по-директният родител на двата вида изключения."
                }, {
                    "text": "`java.lang.Exception`",
                    "isCorrect": true,
                    "rationale": "Класът `Exception` е базовият клас за всички изключения, които могат да бъдат прихванати. `RuntimeException` (Unchecked) наследява `Exception`."
                }, {
                    "text": "`java.lang.Error`",
                    "isCorrect": false,
                    "rationale": "`Error` е отделен клон в йерархията, паралелен на `Exception`, за фатални грешки."
                }],
                "hint": "Погледнете йерархията: `Throwable` има два основни наследника. Кой от тях се разклонява допълнително на `Checked` и `Unchecked`?"
            }, {
                "questionNumber": 23,
                "question": "Какво трябва да направи един метод, ако в него може да възникне `Checked Exception`, но той не го обработва с `try-catch` блок?",
                "answerOptions": [{
                    "text": "Нищо, компилаторът ще го игнорира.",
                    "isCorrect": false,
                    "rationale": "Компилаторът ще генерира грешка, защото `Checked` изключенията трябва да бъдат обработени или декларирани."
                }, {
                    "text": "Трябва да декларира изключението чрез `throws` клауза в сигнатурата си.",
                    "isCorrect": true,
                    "rationale": "Това прехвърля отговорността за обработка на изключението към извикващия метод."
                }, {
                    "text": "Трябва да го преобразува в `RuntimeException`.",
                    "isCorrect": false,
                    "rationale": "Въпреки че това е възможна техника (exception wrapping), основното изискване на компилатора е да се декларира с `throws`."
                }, {
                    "text": "Трябва да приключи изпълнението си с `System.exit()`.",
                    "isCorrect": false,
                    "rationale": "Това е крайна мярка и не е стандартният начин за справяне с изключения."
                }],
                "hint": "Как методът \"предупреждава\" този, който го извиква, че може да се случи нещо непредвидено?"
            }, {
                "questionNumber": 24,
                "question": "Кое от изброените е `Unchecked (Runtime)` Exception?",
                "answerOptions": [{
                    "text": "`FileNotFoundException`",
                    "isCorrect": false,
                    "rationale": "Това е `Checked Exception`, свързано с I/O операции."
                }, {
                    "text": "`ArithmeticException`",
                    "isCorrect": true,
                    "rationale": "Това е `RuntimeException`, причинено от програмна грешка като делене на нула."
                }, {
                    "text": "`InterruptedException`",
                    "isCorrect": false,
                    "rationale": "Това е `Checked Exception`, свързано с многонишково програмиране."
                }, {
                    "text": "`CloneNotSupportedException`",
                    "isCorrect": false,
                    "rationale": "Това е `Checked Exception`, което показва, че обектът не може да бъде клониран."
                }],
                "hint": "Кой тип изключения обикновено индикират за бъг в логиката на програмата?"
            }, {
                "questionNumber": 25,
                "question": "Ако няколко `catch` блока са подредени един след друг, кой ще се изпълни?",
                "answerOptions": [{
                    "text": "Всички `catch` блокове, които съвпадат с типа на изключението.",
                    "isCorrect": false,
                    "rationale": "Изпълнява се само един `catch` блок."
                }, {
                    "text": "Първият `catch` блок отгоре-надолу, чийто тип е съвместим с хвърленото изключение.",
                    "isCorrect": true,
                    "rationale": "Редът има значение. Веднъж щом се намери съвпадение, търсенето спира и съответният блок се изпълнява."
                }, {
                    "text": "Най-специфичният `catch` блок, независимо от реда.",
                    "isCorrect": false,
                    "rationale": "Редът е от решаващо значение. Ако по-общ тип (`Exception`) е преди по-специфичен (`IOException`), специфичният никога няма да бъде достигнат."
                }, {
                    "text": "Последният `catch` блок в списъка.",
                    "isCorrect": false,
                    "rationale": "Винаги се търси от началото на списъка."
                }],
                "hint": "Какво ще се случи, ако поставите `catch (Exception e)` преди `catch (IOException e)`?"
            }, {
                "questionNumber": 26,
                "question": "Кое твърдение относно LIFO принципа на stack паметта е вярно?",
                "answerOptions": [{
                    "text": "Първият извикан метод приключва пръв (First-In, First-Out).",
                    "isCorrect": false,
                    "rationale": "Това описва FIFO (опашка), а не LIFO (стек)."
                }, {
                    "text": "Последният извикан метод приключва пръв (Last-In, First-Out).",
                    "isCorrect": true,
                    "rationale": "Това е точното определение на LIFO. Фреймът на последния извикан метод е на върха на стека и се премахва пръв."
                }, {
                    "text": "Методите се изпълняват в случаен ред.",
                    "isCorrect": false,
                    "rationale": "Изпълнението е строго дефинирано от стека на извикванията."
                }, {
                    "text": "Всички методи се изпълняват паралелно.",
                    "isCorrect": false,
                    "rationale": "В една нишка методите се изпълняват последователно, управлявани от стека."
                }],
                "hint": "Представете си купчина чинии. Коя чиния взимате първо?"
            }, {
                "questionNumber": 27,
                "question": "Каква е стойността по подразбиране за член-променлива от тип `boolean` в един клас, ако не е инициализирана изрично?",
                "answerOptions": [{
                    "text": "`true`",
                    "isCorrect": false,
                    "rationale": "Стойността по подразбиране е `false`."
                }, {
                    "text": "`false`",
                    "isCorrect": true,
                    "rationale": "За `boolean` тип, JVM винаги задава `false` като начална стойност."
                }, {
                    "text": "`null`",
                    "isCorrect": false,
                    "rationale": "`null` е стойността по подразбиране за референтни типове, а не за примитивния `boolean`."
                }, {
                    "text": "Няма стойност по подразбиране, компилаторът ще даде грешка.",
                    "isCorrect": false,
                    "rationale": "Компилаторът дава грешка за неинициализирани *локални* променливи, но не и за член-променливи на клас."
                }],
                "hint": "Каква е \"най-неутралната\" стойност за логическа променлива?"
            }, {
                "questionNumber": 28,
                "question": "В кой момент реално се създават и зареждат в паметта инстанциите на един `enum`?",
                "answerOptions": [{
                    "text": "Всеки път, когато се достъпва някоя от константите.",
                    "isCorrect": false,
                    "rationale": "Те се създават само веднъж, а не при всеки достъп."
                }, {
                    "text": "Когато се извика методът `values()` за първи път.",
                    "isCorrect": false,
                    "rationale": "Извикването на `values()` не предизвиква инициализация; то работи с вече създадените инстанции."
                }, {
                    "text": "Когато JVM зареди .class файла на `enum`-а и изпълни неговия статичен инициализационен блок.",
                    "isCorrect": true,
                    "rationale": "Това е правилният отговор. `enum` инстанциите са статични, финални обекти, които се създават при зареждането на класа."
                }, {
                    "text": "Когато се създаде първият обект, който използва този `enum` тип.",
                    "isCorrect": false,
                    "rationale": "Инициализацията на `enum`-а е свързана със зареждането на самия `enum` клас, а не с друг клас, който го използва."
                }],
                "hint": "Мислете за `enum` константите като за `public static final` обекти."
            }, {
                "questionNumber": 29,
                "question": "Може ли един `record` да имплементира интерфейс?",
                "answerOptions": [{
                    "text": "Не, `record`-ите не могат да участват в йерархии на наследяване.",
                    "isCorrect": false,
                    "rationale": "Те не могат да *наследяват* клас, но могат да *имплементират* интерфейси."
                }, {
                    "text": "Да, един `record` може да имплементира един или повече интерфейси.",
                    "isCorrect": true,
                    "rationale": "Това е напълно позволено и е често срещан начин за добавяне на поведение към `record`."
                }, {
                    "text": "Само ако интерфейсът няма методи по подразбиране (default methods).",
                    "isCorrect": false,
                    "rationale": "Няма такова ограничение. `record` може да имплементира всякакви интерфейси."
                }, {
                    "text": "Само ако `record`-ът е деклариран като `abstract`.",
                    "isCorrect": false,
                    "rationale": "`record`-ите са имплицитно `final` и не могат да бъдат `abstract`."
                }],
                "hint": "Как се добавя полиморфно поведение към типове, които не могат да наследяват други класове?"
            }, {
                "questionNumber": 30,
                "question": "Ако имаме `public sealed interface Shape permits Circle`, и `Circle` е `record`, какъв е имплицитният му статус по отношение на наследяването?",
                "answerOptions": [{
                    "text": "`sealed`",
                    "isCorrect": false,
                    "rationale": "`record`-ите не могат да бъдат `sealed`, защото не могат да бъдат наследявани."
                }, {
                    "text": "`non-sealed`",
                    "isCorrect": false,
                    "rationale": "Това би означавало, че `record`-ът може да бъде наследяван, което е невъзможно."
                }, {
                    "text": "`final`",
                    "isCorrect": true,
                    "rationale": "Всички `record` класове са имплицитно `final`, което означава, че те не могат да бъдат наследявани. Това удовлетворява изискването на `sealed` йерархията."
                }, {
                    "text": "Няма статус, това е грешка при компилация.",
                    "isCorrect": false,
                    "rationale": "Това е валидна комбинация, тъй като имплицитният `final` статус на `record`-а е една от позволените опции за наследник."
                }],
                "hint": "Каква е основната характеристика на `record` по отношение на наследяването?"
            }, {
                "questionNumber": 31,
                "question": "Кога се използва `finally` блокът в `try-catch-finally` конструкция?",
                "answerOptions": [{
                    "text": "Само когато не е възникнало изключение.",
                    "isCorrect": false,
                    "rationale": "`finally` се изпълнява независимо от това дали е имало изключение."
                }, {
                    "text": "Само когато е възникнало и е било прихванато изключение.",
                    "isCorrect": false,
                    "rationale": "`finally` се изпълнява и в този случай, но не само тогава."
                }, {
                    "text": "Винаги се изпълнява, след като `try` или `catch` блокът приключи, освен при спиране на JVM.",
                    "isCorrect": true,
                    "rationale": "Това е гарантиран блок за изпълнение, идеален за освобождаване на ресурси (като затваряне на файлове или връзки)."
                }, {
                    "text": "Само когато е възникнало изключение, което не е било прихванато.",
                    "isCorrect": false,
                    "rationale": "`finally` блокът се изпълнява дори и тогава, точно преди изключението да продължи нагоре по стека."
                }],
                "hint": "Как можете да гарантирате, че даден код за \"почистване\" ще се изпълни винаги?"
            }, {
                "questionNumber": 32,
                "question": "Какъв е резултатът от следната операция: `String s = null; System.out.println(s.length());`?",
                "answerOptions": [{
                    "text": "Грешка при компилация.",
                    "isCorrect": false,
                    "rationale": "Кодът е синтактично правилен и ще се компилира."
                }, {
                    "text": "Ще се отпечата 0.",
                    "isCorrect": false,
                    "rationale": "Метод не може да бъде извикан върху `null` референция."
                }, {
                    "text": "Ще се хвърли `NullPointerException`.",
                    "isCorrect": true,
                    "rationale": "Това е класическият пример за `NullPointerException` - опит за извикване на метод или достъп до поле на обект, който е `null`."
                }, {
                    "text": "Ще се хвърли `IllegalArgumentException`.",
                    "isCorrect": false,
                    "rationale": "Тази грешка се отнася до невалидни стойности, подадени като параметри на метод, а не до `null` референции."
                }],
                "hint": "Можете ли да извикате метод на нещо, което не съществува (сочи към `null`)?"
            }, {
                "questionNumber": 33,
                "question": "Достъпът до коя памет е по-бърз и защо?",
                "answerOptions": [{
                    "text": "До Heap паметта, защото е по-голяма.",
                    "isCorrect": false,
                    "rationale": "Размерът не определя скоростта на достъп; по-големият размер често означава по-сложно управление."
                }, {
                    "text": "До Stack паметта, защото работи на LIFO принцип и достъпът е директен.",
                    "isCorrect": true,
                    "rationale": "Простата и предвидима структура на стека позволява много бързо заделяне, освобождаване и достъп до данни."
                }, {
                    "text": "До Heap паметта, защото се управлява от Garbage Collector-а.",
                    "isCorrect": false,
                    "rationale": "Garbage Collector-ът улеснява програмиста, но самият процес на достъп до heap-а е по-бавен."
                }, {
                    "text": "Скоростта на достъп е еднаква.",
                    "isCorrect": false,
                    "rationale": "Има съществена разлика в производителността поради различните механизми на работа."
                }],
                "hint": "Кой тип достъп изисква \"прескачане\" (indirection) от референция към данни?"
            }, {
                "questionNumber": 34,
                "question": "Какво е предназначението на `try-with-resources` конструкцията в Java?",
                "answerOptions": [{
                    "text": "Да заделя повече памет за изпълнението на `try` блока.",
                    "isCorrect": false,
                    "rationale": "Управлението на паметта не се контролира по този начин."
                }, {
                    "text": "Автоматично да затваря ресурси (като файлове, потоци, връзки), които имплементират `AutoCloseable`.",
                    "isCorrect": true,
                    "rationale": "Това е основната му цел - да се избегне писането на `finally` блок за затваряне на ресурси и да се предотврати тяхното изтичане (resource leaks)."
                }, {
                    "text": "Да позволи използването на множество `catch` блокове.",
                    "isCorrect": false,
                    "rationale": "Множество `catch` блокове могат да се използват и със стандартен `try-catch`."
                }, {
                    "text": "Да обработва само `Checked Exceptions`.",
                    "isCorrect": false,
                    "rationale": "Може да се използва за обработка на всякакви изключения, но основното му предимство е управлението на ресурси."
                }],
                "hint": "Как можете да избегнете писането на `resource.close()` в `finally` блок?"
            }, {
                "questionNumber": 35,
                "question": "Кое твърдение за локалните интерфейси, `enum`-и и `record`-и (въведени след Java 16) е вярно?",
                "answerOptions": [{
                    "text": "Те са видими в целия пакет.",
                    "isCorrect": false,
                    "rationale": "Тяхната видимост е ограничена само до метода, в който са дефинирани."
                }, {
                    "text": "Подобряват енкапсулацията, като ограничават дефиницията до метода, който я използва.",
                    "isCorrect": true,
                    "rationale": "Тази функционалност позволява да се скрият помощни типове данни, които са релевантни само за един конкретен метод."
                }, {
                    "text": "Те не могат да имат методи или полета.",
                    "isCorrect": false,
                    "rationale": "Те имат същите възможности като техните не-локални аналози, но с ограничен обхват."
                }, {
                    "text": "Те могат да бъдат само `public`.",
                    "isCorrect": false,
                    "rationale": "Те нямат модификатори за достъп, тъй като тяхната видимост е имплицитно локална."
                }],
                "hint": "Какво правите, ако ви трябва малка структура от данни или интерфейс само за един-единствен метод?"
            }, {
                "questionNumber": 36,
                "question": "Кое твърдение за нестатичен (instance) инициализационен блок е вярно?",
                "answerOptions": [{
                    "text": "Изпълнява се само веднъж, когато класът се зареди.",
                    "isCorrect": false,
                    "rationale": "Това описва статичния инициализатор."
                }, {
                    "text": "Изпълнява се всеки път, когато се създава инстанция на класа, точно преди конструктора.",
                    "isCorrect": true,
                    "rationale": "Това е правилно. Кодът от нестатичните инициализатори се копира в началото на всеки конструктор."
                }, {
                    "text": "Може да инициализира само статични променливи.",
                    "isCorrect": false,
                    "rationale": "Той е предназначен за нестатични (instance) променливи."
                }, {
                    "text": "Трябва да има име.",
                    "isCorrect": false,
                    "rationale": "Инициализаторите са анонимни блокове код."
                }],
                "hint": "Ако имате код, който трябва да се изпълни при извикване на *всеки* конструктор, къде бихте го поставили?"
            }, {
                "questionNumber": 37,
                "question": "Какъв е основният проблем, който `sealed` класовете решават?",
                "answerOptions": [{
                    "text": "Бавна компилация на големи проекти.",
                    "isCorrect": false,
                    "rationale": "`sealed` класовете са свързани с дизайна на типовете, а не с производителността на компилатора."
                }, {
                    "text": "Неконтролируемо наследяване и експлозия от подтипове.",
                    "isCorrect": true,
                    "rationale": "Те позволяват на автора на API да дефинира точно кои имплементации са позволени, създавайки предвидима йерархия."
                }, {
                    "text": "Писането на много `boilerplate` код.",
                    "isCorrect": false,
                    "rationale": "Този проблем се решава от `record`-ите."
                }, {
                    "text": "Трудна обработка на грешки.",
                    "isCorrect": false,
                    "rationale": "Въпреки че помагат при `pattern matching` в `switch`, основният им фокус не е обработката на грешки, а дизайнът на йерархии."
                }],
                "hint": "Какво се случва, когато искате да създадете библиотека и да ограничите начините, по които другите могат да разширяват вашите класове?"
            }, {
                "questionNumber": 38,
                "question": "Кое НЕ е задължително правило за `sealed` класовете?",
                "answerOptions": [{
                    "text": "Наследниците трябва да са `final`, `sealed` или `non-sealed`.",
                    "isCorrect": false,
                    "rationale": "Това е основно правило за поддържане на контрола над йерархията."
                }, {
                    "text": "`sealed` класът и неговите `permits` класове трябва да са в един пакет.",
                    "isCorrect": false,
                    "rationale": "Това също е задължително изискване на компилатора."
                }, {
                    "text": "`sealed` класът трябва да бъде `abstract`.",
                    "isCorrect": true,
                    "rationale": "Това не е задължително. `sealed` класът може да бъде и конкретен, въпреки че често е `abstract`, тъй като служи като база за йерархия."
                }, {
                    "text": "Ако наследниците са в същия файл, `permits` клаузата може да се пропусне.",
                    "isCorrect": false,
                    "rationale": "Това е вярно, компилаторът може да ги открие автоматично в този случай."
                }],
                "hint": "Може ли да се създаде инстанция на базов `sealed` клас?"
            }, {
                "questionNumber": 39,
                "question": "Каква е разликата между `Error` и `Exception` в Java?",
                "answerOptions": [{
                    "text": "Няма разлика, те са синоними.",
                    "isCorrect": false,
                    "rationale": "Те са два различни клона в йерархията на `Throwable` с много различно семантично значение."
                }, {
                    "text": "`Exception` се хвърлят от JVM, а `Error` от потребителския код.",
                    "isCorrect": false,
                    "rationale": "Точно обратното е по-често срещано: `Error` се хвърлят от JVM при критични проблеми, докато `Exception` са по-често свързани с логиката на приложението."
                }, {
                    "text": "`Error` сигнализират за фатални, невъзстановими проблеми в JVM, докато `Exception` са грешки, от които приложението може да се опита да се възстанови.",
                    "isCorrect": true,
                    "rationale": "Това е ключовата концептуална разлика между двете категории."
                }, {
                    "text": "`Error` са винаги `Checked`, а `Exception` са `Unchecked`.",
                    "isCorrect": false,
                    "rationale": "`Error` се третират като `Unchecked`. `Exception` се делят на `Checked` и `Unchecked` (`RuntimeException`)."
                }],
                "hint": "От кой тип проблем се очаква едно добре написано приложение да може да се възстанови?"
            }, {
                "questionNumber": 40,
                "question": "Когато хвърленото изключение не се прихване от нито един `catch` блок в стека на извикванията, какво се случва?",
                "answerOptions": [{
                    "text": "Програмата продължава изпълнението си, игнорирайки грешката.",
                    "isCorrect": false,
                    "rationale": "Необработените изключения не се игнорират."
                }, {
                    "text": "Методът, хвърлил изключението, се извиква отново автоматично.",
                    "isCorrect": false,
                    "rationale": "Няма такъв механизъм за автоматично повторно извикване."
                }, {
                    "text": "Програмата се срива (прекратява) и се отпечатва `stack trace`.",
                    "isCorrect": true,
                    "rationale": "Това е поведението по подразбиране, когато никой не поема отговорност за обработката на изключението."
                }, {
                    "text": "JVM автоматично поправя грешката и продължава.",
                    "isCorrect": false,
                    "rationale": "JVM не може да поправя логически грешки в програмата."
                }],
                "hint": "Какво виждате в конзолата, когато програмата ви \"гръмне\"?"
            }, {
                "questionNumber": 41,
                "question": "Какво ще отпечата `toString()` методът на `record Point(int x, int y)` за инстанция `new Point(10, 20)`?",
                "answerOptions": [{
                    "text": "Адресът на обекта в паметта.",
                    "isCorrect": false,
                    "rationale": "Това е поведението на `toString()` от клас `Object`, но `record`-ите го препокриват."
                }, {
                    "text": "`Point[x=10, y=20]`",
                    "isCorrect": true,
                    "rationale": "Автоматично генерираният `toString()` предоставя четим и информативен изглед на състоянието на `record`-а."
                }, {
                    "text": "`10, 20`",
                    "isCorrect": false,
                    "rationale": "Форматът включва името на класа и имената на полетата."
                }, {
                    "text": "`x=10, y=20`",
                    "isCorrect": false,
                    "rationale": "Името на типа (`Point`) също е част от генерирания низ."
                }],
                "hint": "Каква е целта на автоматично генерирания `toString()` в `record`?"
            }, {
                "questionNumber": 42,
                "question": "Ако имате `final` референция към `ArrayList` в един клас, какво означава това?",
                "answerOptions": [{
                    "text": "Не можете да добавяте или премахвате елементи от списъка.",
                    "isCorrect": false,
                    "rationale": "`final` се отнася до референцията, а не до съдържанието на обекта. Можете да променяте вътрешното състояние на списъка."
                }, {
                    "text": "Референцията не може да бъде накарана да сочи към друг `ArrayList` обект.",
                    "isCorrect": true,
                    "rationale": "Това е точното значение на `final` за референтен тип. Веднъж инициализирана, референцията е постоянна."
                }, {
                    "text": "Списъкът автоматично става неизменяем (immutable).",
                    "isCorrect": false,
                    "rationale": "`ArrayList` е изменяем клас. `final` референцията не променя тази му характеристика."
                }, {
                    "text": "Списъкът трябва да бъде инициализиран в статичен блок.",
                    "isCorrect": false,
                    "rationale": "Може да бъде инициализиран при декларация, в конструктор или в нестатичен инициализатор."
                }],
                "hint": "Каква е разликата между референцията и обекта, към който тя сочи?"
            }, {
                "questionNumber": 43,
                "question": "В `enum`-ите, кой метод връща позицията (индекса) на константата в реда на нейната декларация?",
                "answerOptions": [{
                    "text": "`position()`",
                    "isCorrect": false,
                    "rationale": "Няма такъв метод в `java.lang.Enum`."
                }, {
                    "text": "`index()`",
                    "isCorrect": false,
                    "rationale": "Няма такъв метод в `java.lang.Enum`."
                }, {
                    "text": "`ordinal()`",
                    "isCorrect": true,
                    "rationale": "Този наследен метод връща целочислена стойност, започваща от 0, която съответства на реда на декларация."
                }, {
                    "text": "`valueOf()`",
                    "isCorrect": false,
                    "rationale": "`valueOf()` търси константа по име (String), а не връща позиция."
                }],
                "hint": "Помислете за думата, която означава \"пореден\"."
            }, {
                "questionNumber": 44,
                "question": "Ако един `record` има компактен конструктор с валидация, кога се изпълнява тази валидация?",
                "answerOptions": [{
                    "text": "След като каноничният конструктор е присвоил стойностите на полетата.",
                    "isCorrect": false,
                    "rationale": "Валидацията трябва да се случи преди присвояването, за да се предотвратят невалидни състояния."
                }, {
                    "text": "Вместо каноничния конструктор.",
                    "isCorrect": false,
                    "rationale": "Кодът от компактния конструктор се добавя в началото на каноничния, а не го замества."
                }, {
                    "text": "В началото на каноничния конструктор, преди присвояването на стойностите.",
                    "isCorrect": true,
                    "rationale": "Това позволява да се проверят параметрите и евентуално да се хвърли изключение, преди полетата да бъдат инициализирани с невалидни данни."
                }, {
                    "text": "Само когато се извика `equals()` методът.",
                    "isCorrect": false,
                    "rationale": "Конструкторът се занимава със създаването на обекта, а не със сравнението му."
                }],
                "hint": "Какъв е логичният ред: първо проверяваш данните и после ги запазваш, или обратното?"
            }, {
                "questionNumber": 45,
                "question": "Кой от изброените НЕ е валиден статус за пряк наследник на `sealed` интерфейс?",
                "answerOptions": [{
                    "text": "Клас, който е `final`.",
                    "isCorrect": false,
                    "rationale": "Това е валидна опция, която спира по-нататъшното наследяване."
                }, {
                    "text": "Интерфейс, който е `final`.",
                    "isCorrect": true,
                    "rationale": "Интерфейсите не могат да бъдат `final`, тъй като това би ги направило неизползваеми (не биха могли да бъдат имплементирани). Това е невалидна опция."
                }, {
                    "text": "Интерфейс, който е `non-sealed`.",
                    "isCorrect": false,
                    "rationale": "Това е валидна опция, която отваря йерархията за имплементации."
                }, {
                    "text": "Клас, който е `sealed`.",
                    "isCorrect": false,
                    "rationale": "Това е валидна опция, която продължава контролираната йерархия."
                }],
                "hint": "Каква е основната цел на един интерфейс и как `final` би попречил на тази цел?"
            }, {
                "questionNumber": 46,
                "question": "Коя е основната разлика между `throws` и `throw` в Java?",
                "answerOptions": [{
                    "text": "Няма разлика, използват се взаимозаменяемо.",
                    "isCorrect": false,
                    "rationale": "Те имат коренно различна цел и синтаксис."
                }, {
                    "text": "`throws` се използва в сигнатурата на метод за деклариране на изключения, а `throw` се използва за хвърляне на конкретен обект-изключение.",
                    "isCorrect": true,
                    "rationale": "Това е точното разграничение. `throws` е декларация, а `throw` е действие."
                }, {
                    "text": "`throws` се използва за `Checked Exceptions`, а `throw` за `Unchecked Exceptions`.",
                    "isCorrect": false,
                    "rationale": "И двете ключови думи могат да се използват и за двата вида изключения (`throws` декларира `Checked`, `throw` може да хвърли и двата вида)."
                }, {
                    "text": "`throw` се използва в `try` блок, а `throws` в `catch` блок.",
                    "isCorrect": false,
                    "rationale": "`throw` може да се използва навсякъде в кода, а `throws` е част само от сигнатурата на метода."
                }],
                "hint": "Едната ключова дума е част от \"договора\" на метода, а другата е команда за действие."
            }, {
                "questionNumber": 47,
                "question": "Защо `equals()` методът, генериран за `record`, сравнява по съдържание, а не по референция?",
                "answerOptions": [{
                    "text": "Защото е по-бързо.",
                    "isCorrect": false,
                    "rationale": "Сравнението по референция (с `==`) е по-бързо, но не е семантично правилно за `value object`."
                }, {
                    "text": "Защото `record`-ите са предназначени да бъдат \"value objects\", при които идентичността се определя от данните, които съдържат.",
                    "isCorrect": true,
                    "rationale": "Това е в основата на концепцията за `record`. Два `record` обекта се считат за еднакви, ако носят еднакви данни."
                }, {
                    "text": "Защото не могат да се сравняват по референция.",
                    "isCorrect": false,
                    "rationale": "Могат да се сравняват по референция с оператора `==`, но това проверява дали са един и същ обект в паметта, а не дали са еквивалентни."
                }, {
                    "text": "Това е изискване на интерфейса `AutoCloseable`.",
                    "isCorrect": false,
                    "rationale": "`record`-ите не имплементират `AutoCloseable` по подразбиране и това няма връзка с `equals()`."
                }],
                "hint": "Какво означава един обект да е \"value object\"?"
            }, {
                "questionNumber": 48,
                "question": "Ако в един клас има няколко статични инициализационни блока, в какъв ред ще се изпълнят те?",
                "answerOptions": [{
                    "text": "В ред, определен от JVM за оптимизация.",
                    "isCorrect": false,
                    "rationale": "Редът е строго дефиниран и предвидим."
                }, {
                    "text": "От най-късия към най-дългия.",
                    "isCorrect": false,
                    "rationale": "Размерът на блока няма значение за реда на изпълнение."
                }, {
                    "text": "В реда, в който са дефинирани в класа (от горе надолу).",
                    "isCorrect": true,
                    "rationale": "JVM изпълнява статичните инициализатори и декларации в текстовия ред, в който се появяват в сорс кода."
                }, {
                    "text": "В обратен ред на дефиницията им.",
                    "isCorrect": false,
                    "rationale": "Изпълнението следва естествения ред на четене на файла."
                }],
                "hint": "Как компилаторът чете вашия сорс код файл?"
            }, {
                "questionNumber": 49,
                "question": "Какъв е резултатът от сравнението `new Point(1, 2) == new Point(1, 2)`, където `Point` е `record`?",
                "answerOptions": [{
                    "text": "`true`, защото `record`-ите се сравняват по съдържание.",
                    "isCorrect": false,
                    "rationale": "Операторът `==` винаги сравнява референции (адреси в паметта). Сравнението по съдържание се прави с `.equals()`."
                }, {
                    "text": "`false`, защото се създават два различни обекта в паметта.",
                    "isCorrect": true,
                    "rationale": "Тъй като `new` създава нов обект, референциите ще бъдат различни, дори данните да са еднакви. Затова `==` връща `false`."
                }, {
                    "text": "Грешка при компилация.",
                    "isCorrect": false,
                    "rationale": "Кодът е напълно валиден и ще се компилира и изпълни."
                }, {
                    "text": "Зависи от имплементацията на `hashCode()`.",
                    "isCorrect": false,
                    "rationale": "`hashCode()` се използва при сравнения в хеш-базирани колекции, но не и при директно сравнение с `==`."
                }],
                "hint": "Каква е разликата между оператора `==` и метода `.equals()` за обекти?"
            }, {
                "questionNumber": 50,
                "question": "Кое твърдение най-добре описва `Unchecked Exceptions`?",
                "answerOptions": [{
                    "text": "Те са външни грешки (проблеми с мрежа/файлове), които трябва да се предвидят.",
                    "isCorrect": false,
                    "rationale": "Това описва `Checked Exceptions`."
                }, {
                    "text": "Те са резултат от бъгове в кода и компилаторът не задължава да бъдат обработени.",
                    "isCorrect": true,
                    "rationale": "Идеята е, че тези грешки трябва да бъдат поправени в кода, а не прихващани по време на изпълнение."
                }, {
                    "text": "Те са фатални грешки в JVM, от които програмата не може да се възстанови.",
                    "isCorrect": false,
                    "rationale": "Това описва `Errors`."
                }, {
                    "text": "Те трябва винаги да се декларират с `throws` в сигнатурата на метода.",
                    "isCorrect": false,
                    "rationale": "Това е изискване за `Checked Exceptions`, а не за `Unchecked`."
                }],
                "hint": "Трябва ли да пишете `try-catch` за `NullPointerException`?"
            }]
        };

        const questionTextEl = document.getElementById('question-text');
        const answersAreaEl = document.getElementById('answers-area');
        const nextBtn = document.getElementById('next-btn');
        const progressTextEl = document.getElementById('progress-text');
        const resultsAreaEl = document.getElementById('results-area');
        const scoreTextEl = document.getElementById('score-text');
        const restartBtn = document.getElementById('restart-btn');
        const hintTextEl = document.getElementById('hint-text');
        const quizContainer = document.getElementById('quiz-container');
        const navigationAreaEl = document.getElementById('navigation-area');

        let currentQuestionIndex = 0;
        let score = 0;

        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            resultsAreaEl.classList.add('hidden');
            quizContainer.querySelector('#quiz-header').classList.remove('hidden');
            questionTextEl.parentElement.classList.remove('hidden');
            answersAreaEl.classList.remove('hidden');
            hintTextEl.parentElement.classList.remove('hidden');
            navigationAreaEl.classList.remove('hidden');
            nextBtn.classList.add('hidden');
            loadQuestion();
        }

        function loadQuestion() {
            resetState();
            const currentQuestion = quizData.questions[currentQuestionIndex];
            questionTextEl.innerText = currentQuestion.question;
            hintTextEl.innerText = `Подсказка: ${currentQuestion.hint}`;
            progressTextEl.innerText = `Въпрос ${currentQuestionIndex + 1} от ${quizData.questions.length}`;

            currentQuestion.answerOptions.forEach(answer => {
                const button = document.createElement('button');
                button.innerHTML = answer.text;
                button.classList.add('answer-btn', 'w-full', 'text-left', 'p-4', 'border-2', 'rounded-lg', 'bg-white', 'hover:bg-indigo-50', 'hover:border-indigo-400');
                if (answer.isCorrect) {
                    button.dataset.correct = true;
                }
                button.dataset.rationale = answer.rationale;
                button.addEventListener('click', selectAnswer);
                answersAreaEl.appendChild(button);
            });
        }

        function resetState() {
            nextBtn.classList.add('hidden');
            hintTextEl.innerText = '';
            while (answersAreaEl.firstChild) {
                answersAreaEl.removeChild(answersAreaEl.firstChild);
            }
        }

        function selectAnswer(e) {
            const selectedBtn = e.target;
            const isCorrect = selectedBtn.dataset.correct === 'true';

            if (isCorrect) {
                score++;
                selectedBtn.classList.add('correct');
            } else {
                selectedBtn.classList.add('incorrect');
            }
            
            Array.from(answersAreaEl.children).forEach(button => {
                if (button.dataset.correct === 'true') {
                    button.classList.add('correct');
                }
                button.disabled = true;
                
                const rationaleEl = document.createElement('div');
                rationaleEl.classList.add('rationale');
                rationaleEl.innerText = button.dataset.rationale;
                button.parentNode.insertBefore(rationaleEl, button.nextSibling);
            });

            if (quizData.questions.length > currentQuestionIndex + 1) {
                nextBtn.classList.remove('hidden');
            } else {
                showResults();
            }
        }

        function showResults() {
            questionTextEl.parentElement.classList.add('hidden');
            answersAreaEl.classList.add('hidden');
            nextBtn.classList.add('hidden');
            hintTextEl.parentElement.classList.add('hidden');
            navigationAreaEl.classList.add('hidden');

            quizContainer.querySelector('#quiz-header').classList.add('hidden');

            resultsAreaEl.classList.remove('hidden');
            scoreTextEl.innerText = `Вашият резултат: ${score} от ${quizData.questions.length} верни отговора.`;
        }

        nextBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            loadQuestion();
        });

        restartBtn.addEventListener('click', startQuiz);

        startQuiz();
    </script>
</body>
</html>

