Неща, които трябва да се запомнят:

- Когато дефинираме метода какъв списък от данни да очаква, този списък се нарича параметри
- Когато подаваме данни към един метод, този списък се нарича аргументи 

- Когато се подават примитивни типове те се подават по стойност, тоест стойността се копира и се предава на метода, като промени на стойността не се отразяват извън метода 
- Когато се подава референтен тип или масив, се копира референцията, но тя сочи към същото място в паметта, така промени направи в метода ще се отразят извън метода 

- Стекът е специална памет на компютъра, която се използва за съхранение на информация за активните методи в една програма, като работи на LIFO принципа
- Когато се извиква метод се отделя блок в стека наречен фрейм, този блок съдържа информация като променливи и параметри, а когато приключи метода фрейма се маха
# Самото създаване и премахване на фрейм се случва автоматично

- Хиипът се използва за съхранение на обекти и масиви по време на изпълнение на програмата, нарича се още динамична памет защото се заделя и освобождава по време на програмата
- Памет в хиипа се заделя чрез new и се освобождава от Garbage Collector-a, като сканира хиипа и намира обекти, който не се използват от прогмата
- Новосъдадените обекти се намират в хиипа, докато техните референции се намират на стака,
- Достъпа до хиипа е по-бавен сравнение със stack-a

- Initializer са блок код {}, който служи за инициализация на data members, който се намира в тялото на класа, като се дели на статичен и нестатичен
- Нестатичния initializer се извикват всеки път, когато се създава обект 
- Статичния initializer се извиква само веднъж, когато класът се ареди в паметта, в код изглежда така static {}
# Може да има няколко initializer в даден клас, като реда им на изпълнение се определя отгоре надолу

- Има две основни фази на инциализация на обект:
1) статична част: когато класът е зареден в паметта, като се инициализират статичните член-променливи на базовия клас и след това на класът наследник 
2) нестатична част: когато се създаде нов обект, първо се изпълняват нестатичните initializer и конструкторите на базовия клас, а след това се изпълняват на класът наследник

- Enum е тип клас, който позволява на предварително дефинирани променливи, приемащи предварително подадени стонойности, тези променливи служат за константи и не могат да се добавят нови към класа по време на изпълнение 
- Enum класа има следните характеристики:
1) Всеки enum имплицитно наследвяа java.lang.Enu, компилатора превръща класа на public final cass <EnumName> extends java.lang.Enum
2) тялото на enum, може да съдържа член-данни и методи, а класът трябва да е package-private, който се извиква от компилатора, за да създаде горепосочените enum константи
3) компилатора автоматично добавя методите values() и valueOf(String name)
- Когато компилатора превърне класът в .class файл се задават public static final полета на всяка константа и се подготвя static initializer, в който се поставя private конструктора
# Този static initializer се изпълнява, когато се използва enum-a за първи път и не можем да го създадем 

- Boilerplate код-а се нарича повтрарящия се и стандартен код, който трябва да се пише отновно и отново за прости класове

- Record е клас, предназначен да представя value object, това са обекти, които единствено представляват данни, характеристиктие му са:
1) самият клас е final и всичките му полета са final
2) един record e immutable и има само getters, защото състоянието му не може да се променя
3) shallowly immutable, референциите на data members  не могат да се сменят 
4) record клас наследява java.lang.Record
- Компилатора генерира следните неща за един record обект:
1) слага private final на всички член-данни 
2) създава каноничен конструктор, който има аргументи за всяка член-данна и присвоява стойност към тях
3) създава getter методи за всяка член-данна, като имат същите имена като член-данните
4) имплементират се автоматично методите equals(), hashCode(), toString() 
5) компактния конструктор се пише, само за проверка и валидацията на входните данни, компилатора го добавя в началото на каноничния конструктор 

- След Java 16 е възможно да се дефинира локален интерфейс, enum или record в тялото на метод, в който ще бъде видим само за него, идеята е да се подобри енкапсулацията 

- Sealed класовете позволяват дефинирана на конкретна йерархия към компилатора, това става с думата sealed и трябва да се обозначи с permites кой класове могат да наследяват/имплементират този клас/интерфейс
- Те решават проблема с нежелани наследници на клас/интерфейс както и експлозия от нежелани подтипове
- Няколко правила свързани с sealed класове:
1) Когато един клас е sealed, трябва задължително да има клауза permites, в която посочва наследниците му
2) Когато един клас наследява sealed клас, той трябва да бъде final (не може да бъде наследяван), non-sealed (няма ограничение за наследниците) или sealed
- Sealed класовете предоставят информация за цялата йерархия на компилатора, това може да подобри проверките от компилатора чрез instanceof и да се създаде switch оператор без default клауза
- Когато interface-a е sealed, наследниците интерфейси трябва да са non-sealed/sealed, наследниците класове трябва да са sealed/non-sealed/final, наследниците record са имплицитно final 

- Изключенията в Java са обекти, който служат за сигнализиране на случил се проблем по време на изпълнение, като носи информация за грешката и мястото на възникване
- Когато един метод хвърли изключение, се спира работата и JVM проверява дали текущият метод (или някой от извикалите го) може да го обработи с catch блок, в противен случай програмата спира и се показва stack trace-a
- Йерархията на изключенията се дели на: java.lang.Object -> java.lang.Throwable -> java.lang.Exception -> java.lang.RuntimeException
-                                                                                -> java.lang.Error
- Изключенията се делят на три вида:
1) Checked exception (или compile-time exceptions) са грешки, които са извън контролана на програмата (проблеми с файлове или мрежа), но комплатора задължава да се предвидят и обработят, примери IoException, FileNotFoundException
# Кода трябва или да обработи изключението с try-catch блок или да декларира, че checked exception е възможно да се хвърли, чрез throws
2) Unchecked exceptions са грешки, които се случват по време на изпълнение на програмата, не е нужно да се обработват, защото тяхната идея е да се оправят тези грешки, примери NullPointerException, ArrayIndexOutOfBoundsException
# Прието е checked exception-ите да се обозначават с throws клаузата, докато unchecked exceptions да бъдат описани в документацията на модела
3) Еrrors са най-сериозноните проблеми в Java, те сигнализират фатални грешки в JVM-a, пример OutOfMemoryError