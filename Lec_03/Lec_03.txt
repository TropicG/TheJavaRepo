* Предаване на аргументи в Java 

	Конструктурите и методите имат списък от нула или повече параметри. Когато дефинираме един метод или конструктур се декларира и той какви входнни данни са ми 
	необходими, именно тези данни се наричат параметри
	
	Пареметрите са списъка (наредена n-орка) от тип и име на параметър, тоест всеки параметър има следните неща:
	- Типът му, тоест какъв тип данни един
	- Името на тази променлива 
	
	При извикване на конструктора или метода се подава списък от аргументи, които трябва да са съвместими като брой, подредба и тип със списъка параметри
	
* Предаване на примитивни типове като аргументи 

	Примитивните типове се подават по стойност, с други думи се прави техни копия и променя на стойността на този параметър в конструктора или метода не се отразява
	на стойностите на променливите, подадени като аргументи 

* Предаване на референтни типове като аргументи 

	Когато се подава обект или масив на даден метод, не се създава копие на целия обект а само н референцията към него. Референцията е просто адресът, който сочи късе се намира обектът в паметта на компютъра.
	
	Стойностите на член-данните на реферираните обекти обаче могат да се променят в кода.
	
* Характеристики на stack паметта 
	
	Стъкът е област от паметта на компютъра, която се използва за съхраняването на информация за активните методи в една програма. Принципа на който работи е LIFO, last in - first out 
	
	Ето и следните характеристики за стековата памет:
	- Автоматично се заделя при извикване на метод и освобождаването при приключването му:
	Когато се извика метод програмата автоматично създава блок в стековата памет наречена фрейм. В този фрейм се съхрнява всичката информация нужна за изпълняването на метода.
	Когато метода прикюлчи работата си неговия фрейм се премахва от сега.

	- Променливите в стека съществувт, докато трае изпълнението на метода, който ги е създал (тоест параметрите и локалните променливи):
	Всички локални променливи и параметрите, които методът получава се съхраняват в неговия фрейм. Те живеят само докато метода се изпълнява 
	
	- Ако стек паметта се запълни, се хвърля java.lang.StackOverflowError
	- Обикновенно е с по-малък размер от heap паметта 
	- достъпут до стек паметта е бърз в сравнение с достъпа до heap паметта 

* Характеристики на heap паметта 

	Хийпът е основната, по-голяма и по-гъвкава област от паметта, която програмата използва за съхранение на обекти и масиви по време на изпълнение на програмата 
	
	Ето някой от характеристиките на heap паметта:
	- динамична памет за обекти и масиви: Хийпът се използва за данни, чийто размер не е задължително известем по време на компилация или чиийто живот трябва да продължи след метода.
	Всичките обекти и масиви се запзват в heap-a, тя се нарича динамична защото се заделя и освобождава по време на работа на програмата, а не предварително
	
	- Заделя се явно с оператора new или неявно и се освобождава от garbade collector-a:
	Garbage collector-a периодично сканира хийпа и намира обекти, които вече не се използват и автоматично освобождава паметта, заета от тях.
	
	- новосъздадените обекти седят в хиийпа, докато техните референции седят в stack-a:
	Самият обект се намира в хиийпа, докато променлива, която достъпва този обект се намира в стека 
	
	- ако heap паметта се запълни, се хвърля java.lang.OutOfMemoryError
	- достъпът до heap Паметта е по-бавен в сравнение с достъпа до stack паметта:
	Достъпът до хиипа иска още една стъпка: първо се взима референцията от стека и след това се отива до съответния адрес в хиипа, за да се намерят данните на обекта 
	Този процес на прескачане (indirrection) е по-бавен от директния достп до променливите в стека.
	
* Създаване и инициализиране на обектите 

	Има различни начини, по които data-member-ите на един клас получават своите начални стойности 
	
	Data-member-ите се инициализат с default стойности нададен тип. Когато сме създали нов обект дори и да не сме задали никакви стойности те автоматично ги получават.
	Това гарантира, че самите променливи няма да имат случайни стойности 
	
	Data-member-ите може да се инициализират explicitno с присвояване като част от декларацията им. Този начин е добър само за прости стойности
	
	Нестатичните променливи могат и да се инициализират и в конструкторите, както знаем конструктора се вика всеки път, когато създадем даден клас 
	
	За статичните data-member-ите могат да се инициализират само с initializers блокове 
	Това е блок код, който е маркиран с static и се изпълнява само веднъж, когато класът бъде зареден в паметта за първи път, още преди да е създаден дори един обект 
	
* Initializer 

	Initializer е блок код в {}, който се използва за задаване на начални стойности на член-променливите на един клас. Съществуват два основни вида: статичен и нестатичен 
	
	Представлява блок код, който не е свързан с име или тип данни и се намира в тялото на дефинирания клас, но извън метод или конструктор. Именно инициализатора е анонимен код, просто е код заграден с такива скоби {}
	
	В даден клас може да има няколко инициализационни блокове. Ако обаче няколко такива инициализатори, които са от един тип (нестатичен или статичен) е ще се изпълняват в реда, в който са дефинирани в класа (тоест от горе надолу)
	
	Основната им идея е да инициализират член-данните на клас дали ще са статични или нестатични, обаче има два вида:
	- за нестатичните данни този блок се изпълнява всеки, когато се създава нов обект от класа (това рядко се случва, защото имаш конструктор-а за тази работа)
	- за статични данни този блок се изпълнява само веднъж, когато класът се зарежда за първи път в паметта. Това е единствения начин за инициализация на статични променливи.
	
* Ред на инициализация на обектите 

	Има две основни фази на инициализация: подготовка на класовете (статична част) и създаване на самия обект (нестатична част)
	
	Тзи фаза се изпълнява само веднъж, когато класът се използва за първи път:
	- Инициализират се статичните член-променливи и се викам статичните иницизализатори на базовия клас
	- Инициализират се статичните член-променливи и се викат статичните инициализатори на класът 
	
	Тази фаза се изпълнява всеки път, когато се създава нов обект с new 
	- Изпълняват се инициализаторите на базовия клас
	- Изпълнява се конструктор на базовия клас 
	- Изпълнява се инициализатора на класът 
	- Изпълняват се конструктора на класът 
	
* Enum 

	Enum е специален тип данни, който позволява да дефинираме променлива, която приема стойности от няколко предварително дефинирани константи
	В този клас дефинираме всички възможни стойности, които една променлива от този тип може да има и този списък е непроменяем, тоест не можем да добавяме нови стойности по време на работа
	Всяка от тези възможни стойности е обект-константа, затова имената на тези стойности се пишат с главни букви, защото те са постоянни стойности 
	
	Нарича се enum от enumeration, защото инстанции се дефинират чрез изброяване
	
	Някой от характеристиките на Enum класа:
	- Всеки enum имплицитно наследява абстракния клас java.lang.Enum: компилатора всъщност го превръща в клас, който изглежда такa public final class <EnumName> extends java.lang.Enum<<EnumName>>
	Обаче един Enum клас не може да наследява друг клас експлицитно понеже вече е наследил един, но може да имплементира интерфейси 
	
	- Тялото на enum класа може да съдържа член-променливи и методи
	
	- Ако имаме конструктор, той трябва да е package-private или private:
	Това е важно, понеже Enum трябва да има строго фиксиран брой инстанции, ако конструктора беше public всеки би могъл да създава нови инстанции.
	Но когато конструктора е private, това гарантира, че само самият Enum може да създава своите инстанции 
	
	- Той автоматично създава константите в дефиницията на enum-a, това не може да се извиква експлицитно:
	Когато дефинираме самите константи в класа ние подаваме аргументи, към неговия private конструктор. Тогава системата автоматично вика този конструктор за всяка константа 
	
	Компилатора автоматично добавя към всеки Enum два статични метода:
	- values(): Метода връща масив, съдържащ всички константи на Enum-a, редът на елементите в масива е същия като ред на тяхното деклариранес
	- valueOf(String name): Връща константата, която отговаря на подаденото име
	
	Виж EnumExample.java 
	
	Как се компилира и как се използва един Enum обект в една програма:
	- Когато компилираш .java файла с Enum компилатора превръща този enum в Java клас (тоест .class файл), този клас се:
	създават public static final поле за всяка една константа, която е дефинирана в enum-a, подготвя static initializer и в този initilizer се поставя този private конструктор
	- Когато за първи път използваме enum-a run-time JVM зарежда в паметта .classa на enum-a и изпълнява статичния инициализационен блок, подготвен от компилатора 
	Това е моментът, в който Enum обектите (тези дефинираните константи в класас) реално се зареждат в паметта
	Note: Трябва да знаеш, че този static initializer го добавя компилатора автоматично, ние не можем да го добавим
	
* BoilerPlate код 

	Boilerplate код е повтарящ се, стандартен код, който трябва да се пише отново и отново за прости класове, които служат единствено за преносители на данни
	Records в Java оправят този проблем 
	
	Една от най-големите критики към Java е, че се пише доста boilerplate код, за почти всеки клас трябва да се прави публичен конструктор, геттър методи и да се пренаписват методи
	
* Records 

	Record е специален, опростен вид клас, създаден да бъде прост и да бъде непроменяем носител на данни 
	
	Value Object е обект, които се определя единствено от данните, които съдържа, не се интересуваме много къде седи в паметта 
	Records описват тези value obejct, един record съществува само за да държи своите данни. Може и да бъдат гледани като наименувана n-орка 
	
	Records имат няколко свойства:
	- Самият клас е final (не може да бъде наследяван) и всичките му полета са final (те са константи)
	- Един record е immutable, защото състоянието му не може да бъде променено. Има само getters, няма setters 
	- Той е също shallowly immutable: Понеже самият record е immutable неговите референции към data-memberите не могат да се сменят.
	Но ако имаш data-member, които е променяем обект (ArrayList например), то вътрешнотоо състояние на този datamember може да се промени 
	
* Какво прави компилатора когато се дефинира Record 

	Компилатора автоматично генерира целият boilerplate код, който или иначе трябва да се пише ръчно 
	
	Какво генерира автоматично компилатора:
	- Слага се private final член-данни за всяко пиле (final се отнася към референцията а не за самият обект към който сочи)
	Note: Когато имаме final към примитивен тип това е като константа.
	Note: Ако имаме final към референция, това означава, че не може да сочи към друг обект, но има възможност да се добавя в самия обект ако е ArrayList
	- Каноничен конструктор (Нарича се така, защото е мега директен конструктор): публичен конструктор, чиито параметри съвпадат точно с компонентите дефинирани в record-a.
	Присвоява подадените стойности към final private полетата 
	
	- Getter методи за полетата: За всеки data member се генерира getter метод. Те са със същите имена както datamember-ите 
	- Имплементират се автоматично и equals(), hashCode() и toString():
		equals() имплементацията му сравнява два record Обекта по съдържание, тоест ако техните стойности са равни 
		hashCode() имплементацията му е обвързана с equals() и генерира хеш код на базата на стойностите на всичките компоненти 
		toString() имплементацията му е удобно за четене на състоянието на recorda 
	- Може да се поставя анотация върху data member-ите директно още в дефиницията на record-a, компилатора след това се погрижва да се приложат
	public record User(@NotNull String username, int age) {}

* Създаване на Record обекти 

	Инстанции на класът record се създават чрез оператора new и се изикване неговия каноничен конструктор 
	Самите класове са final, тоест тяхната цел не е да бъдат наследявани а да представят данни, именно заради това не те са и abstract
	
	Всички records автоматично наследяват абстракният клас java.lang.Record, защото компилатора автоматично го кара да го наследи.
	Именно и java.lang.Record не може да бъде наследяван ръчно, това правило е запазено само и единствено за компилатора.
	
	Когто компилатора генерира record класа, той е задължен и да генерира телата за equals(), hashCode() и toString() методите 
	
* Допълнителни функционалности към Record класа 

	Освен едноредове декларация, record-ите могат да съдържат и допълнителни конструктори, методи, статични член-данни и статични factory методи
	
	Компактния конструктор е конструктор в record-a, която единствената му цел е да добави валидация или нормализация на параметрите, които са подадени към полетата.
	Единствено е нужно да направим логика за верификацията на данните, докато компилатора сам се оправя за присвояването на данните. Може дори да се наложи да променим нещо по подадените аргументи
	
	Компактния констукрот няма параметри и се пропускат дори и писането на празните скоби. Вътре в самото тяло може да се достъпват параметртите на каноничния конструктор.
	Кодът в компактния конструктор се добавя като допълнителен код в началото на дефиницията на каноничния конструктор 

	Виж RecordExample.java
	
* Локални интерфейси, enums и records 

	След Java16 е напълно възможно да дефинираш локално интерфейси, enums или records в тялото на самият метод, което ги прави локални за неого
	Самата идея за това е да се подобри енкапсулацията, ако нужните интерфейси, enums или records са нужни само за този конкретен метод 
	
* Sealed класове 

	sealed класовете и интерфейси са функции в Java, които позволяват да контролират точно кои други класове могат да ги наследяват.
	Когато кажем че един клас е sealed ще трябва да кажем на компилатора кой класове могат да бъдат неговите наследници използвайки думата permits
	По този начин могат да се дефинират възможна йерархия от класове по даден декларативен начин. Декларативен начин, означава че ясно се декларира на компилатора самата йерахия на данните.
	sealed класовете позволяват структурирана йерархия, която върви много добре с patterm matching-a
	
* Какви проблеми решават sealed класовете 

	Един проблем, които sealed класовете решават е неконтролируемото наследяване на класовете в една йерархия от класове.
	
	Когато не използваме sealed класове съществуват 2 проблема:
	- Нежелани наследници: Нищо не би спряло програмист да си дефинира свой собствен тип от клас или интерфейс, който ти си си изградил
	- Експлозия от подтипове: Ако имаш йерархия от класове с базов клас в началото, ако неговите наследници не са final е възможно и те да имат нежелани наследници

	Какви проблеми се решават когато използваме sealed:
	- Спиране на нежелани наследници: Ако имаме public sealed interface Shape permits Circle, Rectangle това ще кажа на компилатора че само класовете след permit имат право да имплементират интерфейса.
	- Контрол над цялата верига: Всеки един наследник на базовия клас в йерархията е задължен да декларира своя статис:
		- final: Този наследник е final и не може да бъде наследяван 
		- sealed class <ClassName> permits ...: Този наследник позволява да бъде наследен само от изброените класове 
		- non-sealed class <ClassName>: Този наследник премахва ограничението и позволява на всеки да го наследни  
		
	Как да решиш проблемите с структурираната йерархия, ако работиш на система без sealed класове:
	- Дефиниране на класовете като final: Даден клас не може да бъде наследяван 
	- дефиниране на класове с модификатор package-private: Класовете ще бъдат видими само за другите класове в същия пакет 
	- дефиниране на private или package-private конструктори: Конструкторите на обектите могат да бъдат извикивани само от класове в същия пакет

	Правилата, които трябва да се спазват когато работим със sealed класове 
	- наследниците на sealed клас трябва да са final, seealed или non-sealed
	- sealed класа може да бъде и абстрактен, но не е задължително
	- sealed класа и неговите permitted класове трябва да са в един пакет 
	- ако selead класовете са кратки или малко на брой могат дори и в същия sorce файл да се дефинират (в този случай permits може да се пропусне)
	
	Виж SealedClassExample.java
	
* Други свойства на sealed класовете 

	sealed класовете предоставят на компилатора пълен и изчерпателен списък н всички възможни наследници и това му позволява да анализира кода по-задълбочено.
	Когато йерархията е отворена, компилатора не е никога сигурен, че знае всички възможни типове, докато ако е затворена, компилатора има перферктна информация, това позволява:
	- по-добри проверки от компилатора: компилатора статично може да анализра проверски с instanceof и да прави cast-ове 
	- по-добра помощ от ide-то: IDE-то може да помогне като автоматично добави case клонове за всички липсващи наследници към твоя switch 
	
	Може да се използва 'умен' switch оператор, който няма нужда от default цасе, ако всичките му класове са изброени 

* Допълнителна информация относно sealed класовете 

	Когато дефинираме sealed interface, всеки негов наследник, трябва да спазва следните правила:
	- ако наследникът е interface трябва да е деклариран като non-sealed или sealed, той не може да бъде final (това ще го спре от класове да го имплементират)
	- ако наследникът е клас той може да бъде final, non-sealed или sealed 
	- ако наследникът е record той е имплицитно final така че няма нужда от този модификатор защото се слага имплицитно 
	
* Изключения 

	Изключението е сигнал, че по време на работата се е случил проблем или неочаквана ситуацията и това е прекъснало нормалния ход на изпълненеито 
	Изключенията предоставят вид комуникация между метод и неговите извикващи, ще се върне стойности при нормално течение на програмата и изкключение при проблем 
	
	Примери за хвърляне на изключение:
	- Подаване на невалидни данни 
	- Опитване да се отвори несъществуващ файл 
	- Свършила е паметта на виртуална машина 
	
	Изключенията в Java са обекти, които служат за описване на възникнала грешка. Те са инстанции на специални класове, организирани в йерархия, която позволява грешките да бъдат категоризирани
	Именно, когато програмата срещне грешка Javа създава обект 
	
	Един обект изключение носи със себе си следната информация:
	- Класът на обект (тип на обекта) ни казва каква е грешка (FileNotFoundException, NullPointerException)
	- Подробно съобщение, това е съобщение което дава повече контекст за грешката 
	- Място на възникване, с други думи stack trace, която ни казва точно реда на който е възникнала грешката 
	
* Стека на извиквания на изключенията 

	Стекът на извиквания е структура, която програмата използва, за да следи кои методи се изпълняват сега. Работи на LIFO принципа
	
	Когато в най-горния метод възникне грешка (тоест се хвърли изключение) нормалния поток на работа спира и започва да се търси метод, който може да хване изключението 
	Системата първо проверява дали текущия метод може да обработи изключението, ако не може да обработи изключението този методи се премахва, и управлението се връща към метода който го е извикал 
	Системата след това проверява и този метод за catch блок и ако отново в него няма той се премахва и търсим в метода, който го е извикикал 
	Така системата продължава докато:
	- докато не намери съвместим catch блок с който да обработи изключението 
	- не се стигне до catch блок, тогава програмата се срива и се изписва така наречения stack trace 
	
* Видове изключения 

	Трите основни изключения на които те се делят са: Checked Exceptions, Unchecked (Runtime) Exceptions и Errors 
	
	Самат йерархия, която представлява класовете свързани с тези изключения е следната:
	java.lang.Object -> java.lang.Throwable -> java.lang.Exception -> java.lang.RuntimeException
											-> java.lang.Error
											
* Checked exceptions 

	Checked изключенията са грешки, които са извън контрола на програмата (проблеми с файлове или мрежа), но компилатора задължава програмиста да ги предвиди и обработи 
	Още се наричат compile-time exceptions. Когато се вика метод, който може да хвърли checked изключение кода няма да се компилира, докато:
	- не се обработи с try-catch блок 
	- ако не се добави throws декларацищта към този метод 
	
	Едно добре написано приложение, би трябвало да ги очаква и да се възстановява от тях
	
	Примери за такова изключение:
	- FileNotFoundException: когато има опит за отваряне на файл, който не съществува
	- IOException: проблем при входно-изходните операции 
	
* Unchecked изключения 

	Unchecked изключения са грешки, които обикновенно са резултати от бъгове в код. Компилатора не задължава да бъдат обработени, защото те трябва да бъдат променени, а не прихващани
	Възникват по време на изпълнение на приложението, затова се наричат още и runtime exceptions 
	
	Все по-рядко се използват checked exceptions понеже правят кода по-тромав, защото принуждават всеки метод да ги обработва или декларира.
	
	Примери:
	- ArithmeticException: при опит за делене на нула 
	- ArrayIndexOutOfBoundsException: при опит за достъп на индех който е извън елемента
	- NullPointerExceptioN: при опит за достъп на данни или метод на обект по референция, но той е Null 
	
* Errors 

	Errors са най-сериозната категория проблеми	в Java. Те сигнализират за фатални грешки в самият JVM. Приложението не може да ги очаква или да се възстанови от тях.
	Генерират се от самият JVM, защото той ги установява, че се намира в критично положение и хвърля Error 
	
	Лоша идея е да се прихващат Errors, защото ако примерно хванем OutOfMemoryError това означава че JVM е в нестабилно състояние и ако се изпълни кода в cathc може да доведе до нестабилно поведение
	Правилния подход е да оставиш приложението да спре и да се анализира логиката 
	
	Примери:
	- OutOfMemoryError: когто вече няма достатъчно свободна памет, за обект
	- StackOverflowError: когато стека на извикванията се запълни 
	
* Деклариране на хвърляни изключения 

	Ако метод не обработва даден checked exception, който може да се хвърли в тялото му, той трябва да го декларира чрез throws, за да предупреди извикващия го метод.
	throws клаузата на метода се декларират само checked изключениетя. Потенциалните unchecked изключенията се опистват в документацията но не в сигнатурата на метода
	
	