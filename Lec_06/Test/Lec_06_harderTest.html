<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест по софтуерно тестване (Експертно ниво)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script> <!-- Font Awesome for icons -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Softer background */
        }
        #quiz-container {
            transition: all 0.3s ease-in-out;
        }
        .answer-option {
            transition: all 0.2s ease-in-out;
            transform-origin: center;
        }
        .answer-option:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }
        .correct {
            background: linear-gradient(to right, #dcfce7, #a7f3d0) !important;
            border-color: #10b981 !important;
            color: #064e3b !important;
            transform: scale(1.03);
        }
        .incorrect {
            background: linear-gradient(to right, #fee2e2, #fecaca) !important;
            border-color: #ef4444 !important;
            color: #991b1b !important;
        }
        .disabled {
            pointer-events: none;
            opacity: 0.8;
        }
        .progress-bar-inner {
            transition: width 0.5s ease-in-out;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .icon {
            font-size: 1.2rem;
            margin-left: auto;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-50 via-white to-sky-100 flex items-center justify-center min-h-screen p-4">

    <div id="quiz-container" class="bg-white w-full max-w-3xl rounded-2xl shadow-2xl p-6 md:p-10">
        <!-- Header -->
        <div id="quiz-header">
            <div class="flex justify-between items-center mb-4">
                <h1 class="text-2xl md:text-3xl font-extrabold text-slate-800 tracking-tight">Тест: Експертно Ниво</h1>
                <div class="text-lg font-bold text-indigo-600 bg-indigo-100 px-4 py-1 rounded-full">
                    <span id="score">0</span> <span class="text-sm font-medium text-indigo-500">точки</span>
                </div>
            </div>
            <div class="flex justify-between items-center text-sm text-slate-500 mb-4">
                <span>Прогрес</span>
                <span>Въпрос <span id="question-number">1</span> / <span id="total-questions">50</span></span>
            </div>
            <div class="w-full bg-slate-200 rounded-full h-2.5">
                <div id="progress-bar" class="bg-gradient-to-r from-sky-400 to-indigo-500 h-2.5 rounded-full progress-bar-inner" style="width: 2%"></div>
            </div>
        </div>

        <!-- Question Body -->
        <div id="question-body" class="mt-8">
            <p id="question-text" class="text-xl font-medium text-slate-700 mb-8 min-h-[90px] leading-relaxed"></p>
            <div id="answer-options" class="space-y-4">
                <!-- Answer options will be injected here -->
            </div>
        </div>
        
        <!-- Feedback and Navigation -->
        <div id="feedback-container" class="mt-8 border-t-2 border-slate-100 pt-6">
             <div id="feedback-card" class="hidden p-5 rounded-xl">
                <div class="flex items-center">
                    <div id="feedback-icon" class="text-2xl mr-4"></div>
                    <div>
                        <p class="font-bold text-lg" id="feedback-title"></p>
                        <p class="text-slate-600 mt-1" id="feedback-text"></p>
                    </div>
                </div>
             </div>
             <button id="next-button" class="hidden mt-6 w-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-bold text-lg py-4 px-4 rounded-xl hover:opacity-90 focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all duration-300 shadow-lg hover:shadow-xl">
                Следващ въпрос
            </button>
        </div>

        <!-- Results Screen -->
        <div id="results-container" class="hidden text-center py-8 fade-in">
            <h2 class="text-3xl font-extrabold text-slate-800 mb-2">Тестът приключи!</h2>
            <p class="text-slate-500 mb-8">Вашият финален резултат е:</p>
            <div class="relative inline-flex items-center justify-center">
                 <p class="text-7xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-sky-500 to-indigo-600 mb-2"><span id="final-score">0</span><span class="text-4xl">/50</span></p>
            </div>
            <p class="text-2xl font-semibold text-slate-700 my-8" id="result-message"></p>
            <button id="restart-button" class="w-full bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-bold text-lg py-4 px-4 rounded-xl hover:opacity-90 focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all duration-300 shadow-lg hover:shadow-xl">
                Започни отначало
            </button>
        </div>
    </div>

    <script>
        const quizData = [
    {
        "question": "Какъв е редът на изпълнение на анотациите в JUnit 5 за един-единствен тест метод?",
        "options": [
            "@BeforeEach -> @BeforeAll -> @Test -> @AfterAll -> @AfterEach",
            "@BeforeAll -> @BeforeEach -> @Test -> @AfterEach -> @AfterAll",
            "@BeforeAll -> @Test -> @AfterAll -> @BeforeEach -> @AfterEach",
            "@BeforeEach -> @Test -> @AfterEach -> @BeforeAll -> @AfterAll"
        ],
        "correct": 1,
        "rationale": "Първо се изпълнява веднъж `@BeforeAll` за целия клас, след това `@BeforeEach` преди теста, самият `@Test`, `@AfterEach` след теста и накрая веднъж `@AfterAll` след всички тестове."
    },
    {
        "question": "Коя техника за тестване е най-подходяща за поле, което приема стойности между 18 и 60?",
        "options": [
            "Equivalence Partitioning (Разбиване на еквивалентни класове)",
            "State Transition Testing (Тестване на преходи между състояния)",
            "Boundary Value Analysis (Анализ на граничните стойности)",
            "Decision Table Testing (Тестване с таблици на решенията)"
        ],
        "correct": 2,
        "rationale": "Анализът на граничните стойности е най-ефективен, тъй като тества стойностите на и около границите (17, 18, 19 и 59, 60, 61), където най-често възникват грешки."
    },
    {
        "question": "Каква е разликата между `Mock` и `Spy` в контекста на Mockito?",
        "options": [
            "Mock е фалшив обект, докато Spy е истински обект с допълнителни възможности за проследяване.",
            "Няма разлика, те са синоними.",
            "Spy връща `null` по подразбиране, докато Mock извиква реалните методи.",
            "Mock се използва за unit тестове, а Spy - за интеграционни."
        ],
        "correct": 0,
        "rationale": "Mock е изцяло симулиран обект, докато Spy \"обвива\" реален обект, позволявайки да се проследяват извикванията на реалните му методи или да се подменят (stub) само някои от тях."
    },
    {
        "question": "Кой тип нефункционално тестване проверява поведението на системата при продължително, но нормално натоварване?",
        "options": [
            "Stress Testing",
            "Spike Testing",
            "Soak Testing (Endurance Testing)",
            "Load Testing"
        ],
        "correct": 2,
        "rationale": "Soak testing цели да открие проблеми като изтичане на памет (memory leaks), които се проявяват след като системата е работила продължително време."
    },
    {
        "question": "Какво е основното предимство на параметризираните тестове (`@ParameterizedTest`)?",
        "options": [
            "Изпълняват се по-бързо от обикновените тестове.",
            "Позволяват един и същ тестов метод да се изпълни многократно с различни входни данни, намалявайки дублирането на код.",
            "Гарантират 100% тестово покритие.",
            "Автоматично генерират тестови данни."
        ],
        "correct": 1,
        "rationale": "Те са идеални за тестване на една и съща логика с широк набор от входни стойности, което прави тестовете по-чисти и лесни за поддръжка."
    },
    {
        "question": "Какво е \"Cyclomatic Complexity\" и как е свързано с тестването?",
        "options": [
            "Метрика за скоростта на кода; по-ниска сложност означава по-бързи тестове.",
            "Метрика за броя независими пътища през кода; тя дава представа за минималния брой тестове, нужни за пълно покритие на пътищата.",
            "Метрика за това колко е лесен за четене кодът.",
            "Метрика за броя зависимости, които един клас има."
        ],
        "correct": 1,
        "rationale": "Високата цикломатична сложност индикира по-сложен код, който е по-труден за тестване и по-податлив на грешки, и изисква повече тестови случаи."
    },
    {
        "question": "Каква е целта на `ArgumentCaptor` в Mockito?",
        "options": [
            "Да промени аргументите, с които се извиква даден метод.",
            "Да \"улови\" аргументите, подадени на метод на mock обект, за да могат те да бъдат проверени (asserted).",
            "Да генерира случайни аргументи за параметризирани тестове.",
            "Да валидира типа на аргументите по време на изпълнение."
        ],
        "correct": 1,
        "rationale": "Той е изключително полезен, когато трябва да се направят сложни проверки върху обект, който е подаден като аргумент на mock-нат метод."
    },
    {
        "question": "Кое твърдение най-добре описва разликата между TDD (Test-Driven Development) и BDD (Behavior-Driven Development)?",
        "options": [
            "TDD се фокусира върху unit тестове, докато BDD се фокусира върху UI тестове.",
            "BDD е еволюция на TDD, която използва естествен език (Gherkin), за да опише поведението на системата от гледна точка на бизнеса.",
            "TDD се използва в Agile, а BDD - във Waterfall.",
            "TDD изисква писане на тестове преди кода, докато BDD позволява тестовете да се пишат след кода."
        ],
        "correct": 1,
        "rationale": "BDD цели да подобри комуникацията между техническия екип и бизнес анализаторите, като дефинира тестовете в четим за всички формат (Given-When-Then)."
    },
    {
        "question": "Какво е \"Flaky Test\"?",
        "options": [
            "Тест, който се проваля всеки път.",
            "Тест, който минава и се проваля без промени в кода, често поради зависимости от външни фактори или асинхронни операции.",
            "Тест с много ниска производителност.",
            "Тест, който тества тривиална функционалност."
        ],
        "correct": 1,
        "rationale": "Нестабилните тестове са сериозен проблем, защото подкопават доверието в тестовия пакет и могат да скрият реални регресии."
    },
    {
        "question": "При тестване на REST API, кой HTTP статус код обикновено очаквате при успешно създаване на ресурс чрез POST заявка?",
        "options": [
            "200 OK",
            "201 Created",
            "204 No Content",
            "400 Bad Request"
        ],
        "correct": 1,
        "rationale": "201 Created е най-специфичният и правилен отговор, който индикира, че ресурсът е успешно създаден. 200 OK също е приемлив в някои случаи, но 201 е по-прецизен."
    },
    {
        "question": "Какво представлява \"Тестовата пирамида\" (Test Pyramid)?",
        "options": [
            "Йерархия на QA инженерите в един екип.",
            "Модел, който показва, че трябва да има многобройни бързи unit тестове в основата, по-малко интеграционни и съвсем малко бавни E2E тестове на върха.",
            "Процес за приоритизиране на бъгове.",
            "Структура на един тестов клас, започваща с `@BeforeAll` и завършваща с `@AfterAll`."
        ],
        "correct": 1,
        "rationale": "Идеята е да се постигне бърза и надеждна обратна връзка, като по-голямата част от тестването се извършва на най-ниското и бързо ниво."
    },
    {
        "question": "Коя JUnit 5 анотация се използва за генериране на тестове по време на изпълнение?",
        "options": [
            "@GeneratedTest",
            "@TestFactory",
            "@RuntimeTest",
            "@ParameterizedTest"
        ],
        "correct": 1,
        "rationale": "`@TestFactory` позволява връщането на колекция от `DynamicTest` инстанции, които се създават програмно, предоставяйки голяма гъвкавост."
    },
    {
        "question": "Каква е разликата между \"Verification\" и \"Validation\" в тестването?",
        "options": [
            "Няма разлика, те са взаимозаменяеми.",
            "Verification е автоматизиран процес, докато Validation е ръчен.",
            "Verification проверява дали продуктът е създаден правилно (Are we building the product right?), докато Validation проверява дали е създаден правилният продукт (Are we building the right product?).",
            "Verification се извършва от разработчиците, а Validation - от клиентите."
        ],
        "correct": 2,
        "rationale": "Verification се фокусира върху спазването на спецификациите, докато Validation се уверява, че продуктът отговаря на реалните нужди на потребителя."
    },
    {
        "question": "Какво е основното предизвикателство при End-to-End (E2E) тестовете?",
        "options": [
            "Те са твърде бързи и не могат да хванат проблеми със синхронизацията.",
            "Те са бавни, крехки (brittle) и трудни за поддръжка поради зависимостта си от множество компоненти (UI, API, база данни).",
            "Те могат да тестват само backend логиката, без потребителския интерфейс.",
            "Те изискват 100% тестово покритие на unit ниво, за да работят."
        ],
        "correct": 1,
        "rationale": "Малка промяна в UI или API може да счупи много E2E тестове, а диагностицирането на проблема е сложно, защото провалът може да е във всеки един от слоевете на системата."
    },
    {
        "question": "В кой случай бихте използвали `assertThrows()` в JUnit 5?",
        "options": [
            "За да проверите дали един метод връща `null`.",
            "За да проверите дали един метод хвърля точно определен тип изключение (exception).",
            "За да накарате един тест да се провали, ако хвърли каквото и да е изключение.",
            "За да измерите времето, за което се изпълнява един метод."
        ],
        "correct": 1,
        "rationale": "Това е стандартният начин да се тества поведението на кода при грешни входни данни или неочаквани състояния, като се гарантира, че се хвърля правилният `Exception`."
    },
    {
        "question": "Какво е \"Mutation Testing\"?",
        "options": [
            "Тестване на генетични алгоритми.",
            "Процес, при който автоматично се променя (мутира) продуктовият код, за да се провери дали съществуващите тестове се провалят. Ако не се провалят, тестът е слаб.",
            "Ръчно тестване, при което QA инженерът пробва да \"счупи\" системата с неочаквани данни.",
            "Тестване на производителността чрез мутация на входния трафик."
        ],
        "correct": 1,
        "rationale": "Това е мощна техника за оценка на качеството на самия тестов пакет, а не само на продуктовия код."
    },
    {
        "question": "Коя анотация в JUnit 5 позволява да се изпълняват тестове паралелно?",
        "options": [
            "@Parallel",
            "@EnableParallelism",
            "@Execution(ExecutionMode.CONCURRENT)",
            "Паралелизмът се конфигурира извън кода, чрез билд системата (Maven/Gradle)."
        ],
        "correct": 3,
        "rationale": "В JUnit 5 паралелното изпълнение не се контролира с анотации, а чрез конфигурационни параметри в `junit-platform.properties` файла или в конфигурацията на билд инструмента."
    },
    {
        "question": "Каква е целта на \"Canary Release\" стратегията?",
        "options": [
            "Да се пусне нова версия на софтуера за всички потребители едновременно.",
            "Да се тества новата версия в изолирана среда, която имитира продукционната.",
            "Да се пусне новата версия само за малка част от потребителите, за да се наблюдава поведението й в реални условия, преди да се пусне за всички.",
            "Да се върне към старата версия на софтуера след неуспешно внедряване."
        ],
        "correct": 2,
        "rationale": "Това е техника за намаляване на риска, която позволява събирането на данни за производителност и грешки от реалния трафик, преди да се засегне цялата потребителска база."
    },
    {
        "question": "Кой принцип на SOLID е най-тясно свързан с възможността за лесно тестване и подмяна на зависимости?",
        "options": [
            "Single Responsibility Principle (Принцип на единствената отговорност)",
            "Open/Closed Principle (Принцип на отвореност/затвореност)",
            "Liskov Substitution Principle (Принцип на заместване на Лисков)",
            "Dependency Inversion Principle (Принцип на инверсия на зависимостите)"
        ],
        "correct": 3,
        "rationale": "Този принцип насърчава програмирането към интерфейси, а не към конкретни имплементации, което позволява реалните зависимости лесно да бъдат заменени с тестови двойници (mocks/stubs) по време на тест."
    },
    {
        "question": "Какво е \"Shift-Left Testing\"?",
        "options": [
            "Практика за отлагане на тестването за края на разработката.",
            "Философия, която насърчава извършването на тестови дейности възможно най-рано в жизнения цикъл на разработка.",
            "Тестване, извършвано само от екипа вляво от вас в офиса.",
            "Техника за тестване на битови операции и измествания."
        ],
        "correct": 1,
        "rationale": "Идеята е да се \"измести наляво\" тестването по времевата линия на проекта, като се интегрира още във фазите на изискванията и дизайна, за да се откриват дефекти по-рано и по-евтино."
    },
    {
        "question": "Каква е разликата между `fail()` и `assertFalse(true)`?",
        "options": [
            "Няма разлика, резултатът е идентичен.",
            "`fail()` проваля теста безусловно, докато `assertFalse(true)` проваля теста, защото проверява конкретно булево условие.",
            "`fail()` може да приеме съобщение, докато `assertFalse` не може.",
            "`fail()` спира изпълнението на целия тестов клас, докато `assertFalse` проваля само текущия метод."
        ],
        "correct": 1,
        "rationale": "Въпреки че и двете ще провалят теста, `fail()` се използва, за да се покаже, че е достигната част от кода, която не трябва да бъде достижима, докато `assertFalse` е проверка на състояние."
    },
    {
        "question": "Какъв е основният проблем на тестови двойник от тип \"Dummy\"?",
        "options": [
            "Той е твърде сложен за имплементация.",
            "Той се използва само за подаване като параметър, но никога не се използва реално и не може да симулира поведение.",
            "Винаги хвърля изключения, когато се извика негов метод.",
            "Работи изключително бавно."
        ],
        "correct": 1,
        "rationale": "Dummy обектите са най-простият вид тестови двойници. Тяхната единствена цел е да запълнят списъка с параметри, за да може кодът да се компилира и изпълни, без да се интересуваме от тях."
    },
    {
        "question": "Кое от следните е пример за \"Static Analysis\" (статичен анализ) на код?",
        "options": [
            "Изпълнение на unit тестове.",
            "Проверка на кода за стилови грешки и потенциални бъгове от инструмент като SonarQube или Checkstyle, без да се изпълнява самият код.",
            "Профилиране на паметта на приложението по време на работа.",
            "Ръчно преглеждане на кода от друг разработчик (code review)."
        ],
        "correct": 1,
        "rationale": "Статичният анализ открива проблеми чрез инспекция на сорс кода, за разлика от динамичния анализ (като unit тестовете), който изисква изпълнение на кода."
    },
    {
        "question": "Каква е целта на `Soak Testing`?",
        "options": [
            "Да се провери как системата реагира на внезапни пикове в натоварването.",
            "Да се намери максималният капацитет на системата.",
            "Да се идентифицират проблеми като изтичане на памет чрез подлагане на системата на продължително натоварване.",
            "Да се тества възстановяването на системата след срив."
        ],
        "correct": 2,
        "rationale": "Този тип тестване, наричан още 'endurance testing', симулира работа в продължение на часове или дни, за да открие дефекти, които се проявяват с времето."
    },
    {
        "question": "Каква е основната разлика между `@Nested` тестове и използването на отделни тестови класове?",
        "options": [
            "`@Nested` тестовете се изпълняват паралелно, докато отделните класове - не.",
            "`@Nested` позволява групиране на тестове в вътрешен клас, подобрявайки структурата и четимостта, когато се тества сложно поведение.",
            "Няма разлика, това е просто стилистично предпочитание.",
            "В `@Nested` класове не могат да се използват `@BeforeEach` и `@AfterEach`."
        ],
        "correct": 1,
        "rationale": "Вложените тестове помагат да се изрази по-ясно връзката между групи от тестове, често следвайки BDD стил на описание на поведението."
    },
    {
        "question": "Какво е \"Alpha Testing\"?",
        "options": [
            "Тестване, извършвано от крайни потребители на техните собствени устройства.",
            "Първата фаза на автоматизирано тестване.",
            "Тестване, извършвано вътрешно от екипа (разработчици, QA) в контролирана среда, преди продуктът да бъде показан на външни лица.",
            "Тестване, което се фокусира само върху азбучното сортиране."
        ],
        "correct": 2,
        "rationale": "Това е форма на вътрешно приемателно тестване (internal acceptance testing), което симулира реална употреба, но все още е под контрола на организацията."
    },
    {
        "question": "Какво е \"Beta Testing\"?",
        "options": [
            "Тестване, извършвано от QA екипа преди всяко пускане на нова версия.",
            "Тестване на втората версия на даден продукт.",
            "Тестване, извършвано от реални потребители (ограничена група) в тяхната собствена среда, преди официалното пускане на продукта.",
            "Тестване, което използва непълни (бета) версии на тестови инструменти."
        ],
        "correct": 2,
        "rationale": "Целта е да се събере обратна връзка за бъгове, производителност и използваемост от широк кръг потребители в реални, неконтролирани условия."
    },
    {
        "question": "Какво е \"A/B Testing\"?",
        "options": [
            "Тестване на две различни версии на софтуера едновременно.",
            "Сравняване на версия А (стара) с версия B (нова) за регресии.",
            "Техника, при която се показват две или повече версии на дадена страница или функционалност на различни групи потребители, за да се определи коя версия е по-ефективна.",
            "Тестване на основните (А) и второстепенните (B) функционалности."
        ],
        "correct": 2,
        "rationale": "Това е метод за експериментиране, който позволява вземането на решения, базирани на данни, относно дизайна, потребителския поток или функционалността."
    },
    {
        "question": "Кое от следните НЕ е характеристика на добър Unit тест?",
        "options": [
            "Бърз",
            "Независим",
            "Свързан с база данни",
            "Повтаряем (Repeatable)"
        ],
        "correct": 2,
        "rationale": "Един добър unit тест трябва да е изолиран от външни системи като бази данни, файлова система или мрежа, за да е бърз и надежден. Тези зависимости трябва да се симулират (mock/stub)."
    },
    {
        "question": "Коя JUnit 5 анотация може да се използва, за да се зададе максимално време за изпълнение на тест?",
        "options": [
            "@MaxDuration",
            "@Timeout",
            "@Deadline",
            "@TimeLimit"
        ],
        "correct": 1,
        "rationale": "Ако тестът отнеме повече от указаното време, той ще се провали. Това е полезно за откриване на проблеми с производителността или безкрайни цикли."
    },
    {
        "question": "Какъв е основният недостатък на тестването само на \"happy path\" (успешния път)?",
        "options": [
            "Тестовете стават твърде сложни.",
            "Пропускат се тестове за грешки, невалидни данни и неочаквани потребителски действия, които могат да счупят системата.",
            "Това води до твърде високо тестово покритие.",
            "Забавя процеса на разработка."
        ],
        "correct": 1,
        "rationale": "Една стабилна система трябва да може да се справя елегантно с грешки и изключения, а тестването само на идеалния сценарий оставя тези случаи непроверени."
    },
    {
        "question": "Какво е \"Confirmation Testing\" (Потвърдително тестване)?",
        "options": [
            "Тестване, което потвърждава, че всички нови функционалности работят.",
            "Тестване, което се извършва, за да се уверим, че докладван бъг е бил успешно отстранен.",
            "Тестване, при което се иска потвърждение от клиента преди изпълнение.",
            "Синоним на Smoke Testing."
        ],
        "correct": 1,
        "rationale": "Нарича се още 're-testing'. След като разработчикът поправи бъг, QA инженерът изпълнява отново същия тест, за да потвърди, че поправката работи."
    },
    {
        "question": "Каква е целта на `Mockito.verify()`?",
        "options": [
            "Да провери дали резултатът от даден метод е верен.",
            "Да провери дали даден метод на mock обект е бил извикан определен брой пъти и/или с определени аргументи.",
            "Да подготви (stub) mock обекта да връща определена стойност.",
            "Да провери дали два обекта са еднакви."
        ],
        "correct": 1,
        "rationale": "Това е основният механизъм за верификация на поведение (behavior verification) в Mockito, който е ключов при използването на mock обекти."
    },
    {
        "question": "Какво е \"Sanity Check\" или \"Sanity Test\"?",
        "options": [
            "Изчерпателен регресионен тест.",
            "Бърза, повърхностна проверка на конкретна функционалност след малка промяна или поправка на бъг, за да се уверим, че промяната работи и не е счупила нищо очевидно.",
            "Тест за психическото състояние на QA инженера.",
            "Синоним на Usability Testing."
        ],
        "correct": 1,
        "rationale": "Той е по-тесен по обхват от smoke теста и се фокусира върху областта на промяната. Целта е да се отговори на въпроса \"Разумно ли е изобщо да продължим с по-дълбоко тестване?\"."
    },
    {
        "question": "Коя техника за тестване е най-подходяща за система със сложни бизнес правила и комбинации от условия?",
        "options": [
            "Boundary Value Analysis",
            "Exploratory Testing",
            "Use Case Testing",
            "Decision Table Testing"
        ],
        "correct": 3,
        "rationale": "Таблиците на решенията помагат да се систематизират всички възможни комбинации от входни условия и съответните им резултати, като гарантират, че няма пропуснати сценарии."
    },
    {
        "question": "Каква е разликата между `Assert.assertEquals()` и `Mockito.verify()`?",
        "options": [
            "`assertEquals` проверява състоянието (state), докато `verify` проверява поведението (behavior).",
            "`assertEquals` се използва за mock обекти, а `verify` - за реални обекти.",
            "Те са напълно взаимозаменяеми.",
            "`verify` може да се използва само в `@AfterEach` методи."
        ],
        "correct": 0,
        "rationale": "Assert проверява дали дадена стойност е равна на очакваната (проверка на състояние). Verify проверява дали е имало взаимодействие с mock обект (проверка на поведение)."
    },
    {
        "question": "Какво е \"Test Harness\"?",
        "options": [
            "Документация, описваща как се тества системата.",
            "Колекция от софтуер и тестови данни, конфигурирани да тестват даден модул в изолирана среда. Включва драйвери, стъбове и среда за изпълнение.",
            "Специализиран хардуер за тестване на производителността.",
            "Система за докладване на бъгове."
        ],
        "correct": 1,
        "rationale": "Test harness е цялостната среда, която позволява автоматизираното изпълнение на тестове, като симулира зависимостите, от които се нуждае тестваният код."
    },
    {
        "question": "В JUnit 5, как можете да инжектирате информация за текущия тест (напр. името му) в тестов метод?",
        "options": [
            "Чрез наследяване на клас `TestInfoAware`.",
            "Чрез добавяне на параметър от тип `TestInfo` към метода.",
            "Чрез извикване на статичния метод `JUnit.getCurrentTestInfo()`.",
            "Това не е възможно."
        ],
        "correct": 1,
        "rationale": "JUnit 5 поддържа инжектиране на зависимости (dependency injection) за определени параметри като `TestInfo` и `TestReporter` директно в сигнатурата на тестовия метод."
    },
    {
        "question": "Какво е \"Error Seeding\"?",
        "options": [
            "Практика за умишлено оставяне на грешки в кода, за да се види дали потребителите ще ги намерят.",
            "Техника за оценка на ефективността на тестовия процес чрез умишлено инжектиране на известен брой дефекти в кода. Процентът на намерените \"посети\" дефекти дава представа за ефективността.",
            "Автоматично генериране на тестове, които търсят грешки.",
            "Синоним на Mutation Testing."
        ],
        "correct": 1,
        "rationale": "Въпреки че е подобно на мутационното тестване, error seeding обикновено се прави ръчно и се използва за оценка на целия тестов процес, а не само на автоматизирания пакет."
    },
    {
        "question": "Какво е основното предимство на \"Contract Testing\" (Договорно тестване) при микросървисна архитектура?",
        "options": [
            "Замества напълно нуждата от E2E тестове.",
            "Гарантира, че отделно разработени сървиси (напр. consumer и producer) могат да комуникират помежду си, без да е необходимо да се тестват заедно в напълно интегрирана среда.",
            "Проверява само за синтактични грешки в договорите (напр. OpenAPI/Swagger).",
            "Тества се само при наличие на правен договор между екипите."
        ],
        "correct": 1,
        "rationale": "Това позволява на екипите да работят независимо, като се уверят, че промените, които правят, няма да нарушат \"договора\" (очаквания формат на заявки/отговори) с други сървиси, което прави интеграцията много по-надеждна."
    },
    {
        "question": "Какво е \"pairwise testing\" (тестване по двойки)?",
        "options": [
            "Тестване, при което двама QA инженери работят заедно върху един и същ тест.",
            "Техника за тестване на комбинации от параметри, която тества всяка възможна двойка от стойности, намалявайки драстично броя на тест казусите в сравнение с тестването на всички възможни комбинации.",
            "Тестване на интеграцията между точно два модула.",
            "Синоним на A/B тестване."
        ],
        "correct": 1,
        "rationale": "Това е комбинаторна техника, която е изключително ефективна за намиране на бъгове, причинени от взаимодействието между два параметъра, с много по-малко усилия."
    },
    {
        "question": "Каква е разликата между `final` и `effectively final` в Java и защо е важна за ламбда изразите?",
        "options": [
            "Няма разлика, това е стилистика.",
            "`final` означава, че променливата не може да се променя, а `effectively final` означава, че може, но само веднъж.",
            "Ламбда изразите могат да достъпват само локални променливи, които са `final` или `effectively final` (т.е. стойността им не се променя след инициализация).",
            "`final` се отнася за полета на класа, а `effectively final` за локални променливи."
        ],
        "correct": 2,
        "rationale": "Това ограничение е важно, защото гарантира, че ламбда изразът работи с копие на стойността, което предотвратява проблеми със състоянията и паралелното изпълнение."
    },
    {
        "question": "Кое от следните НЕ е част от \"Twelve-Factor App\" методологията?",
        "options": [
            "Dependencies: Изрично деклариране и изолиране на зависимостите.",
            "Config: Съхраняване на конфигурацията в околната среда (environment).",
            "State: Приложенията трябва да бъдат stateful, като съхраняват сесии в паметта.",
            "Logs: Третиране на логовете като поток от събития."
        ],
        "correct": 2,
        "rationale": "Един от ключовите принципи на Twelve-Factor App е, че процесите трябва да бъдат `stateless` (без състояние), за да се улесни хоризонталното мащабиране."
    },
    {
        "question": "Какво е \"Idempotent\" операция в контекста на API?",
        "options": [
            "Операция, която винаги връща един и същ резултат, независимо от входните данни.",
            "Операция, която може да бъде извикана многократно със същите параметри, като резултатът ще е същият, сякаш е извикана само веднъж.",
            "Операция, която се изпълнява изключително бързо.",
            "Операция, която не може да бъде тествана автоматизирано."
        ],
        "correct": 1,
        "rationale": "HTTP методите GET, PUT, DELETE са идемпотентни. POST не е. Това е важно за надеждността на системите, тъй като позволява безопасно повторно изпращане на заявки при мрежови грешки."
    },
    {
        "question": "Какво е `Chaos Engineering`?",
        "options": [
            "Да се пише код без никаква структура или тестове.",
            "Практика за умишлено инжектиране на грешки и проблеми (напр. спиране на сървъри, въвеждане на мрежова латентност) в продукционна или тестова среда, за да се провери устойчивостта на системата.",
            "Тестване на системата с напълно случайни входни данни.",
            "Синоним на Stress Testing."
        ],
        "correct": 1,
        "rationale": "Целта е проактивно да се открият слабости в системата, преди те да се проявят като реални инциденти, които засягат потребителите."
    },
    {
        "question": "Каква е основната цел на `Code Review` процеса?",
        "options": [
            "Да се намерят възможно най-много бъгове.",
            "Да се провери дали кодът отговаря на стиловите насоки на екипа.",
            "Да се сподели знание, да се подобри качеството на кода и да се открият потенциални проблеми с архитектурата или логиката, преди кодът да бъде интегриран.",
            "Да се оцени производителността на разработчика."
        ],
        "correct": 2,
        "rationale": "Въпреки че намирането на бъгове е част от процеса, основните ползи са свързани с колективната отговорност за качеството, менторството и поддържането на здрава кодова база."
    },
    {
        "question": "Кое от следните е най-добрият пример за `Use Case Testing`?",
        "options": [
            "Тестване на функцията за събиране в калкулатор с различни числа.",
            "Проверка на всички полета във форма за регистрация за валидност.",
            "Изпълнение на сценарий: \"Потребителят търси продукт, добавя го в количката, въвежда адрес за доставка и плаща с кредитна карта\".",
            "Проверка на цвета на бутоните в приложението."
        ],
        "correct": 2,
        "rationale": "Use case тестването се фокусира върху цялостни бизнес процеси и взаимодействия на потребителя (актьора) със системата, за да постигне определена цел."
    },
    {
        "question": "Какво е \"Fuzz Testing\" (Fuzzing)?",
        "options": [
            "Тестване на потребителския интерфейс за размазани (fuzzy) изображения.",
            "Автоматизирана техника за намиране на бъгове, която подава голямо количество невалидни, неочаквани или случайни данни на входа на програмата.",
            "Ръчно тестване без конкретен план.",
            "Тестване на алгоритми за приблизително търсене (fuzzy search)."
        ],
        "correct": 1,
        "rationale": "Fuzzing е изключително ефективен за откриване на бъгове, свързани със сигурността и стабилността, като препълване на буфери (buffer overflows) или необработени изключения."
    },
    {
        "question": "Каква е основната разлика между `fail-safe` и `fail-fast` системите?",
        "options": [
            "`fail-safe` се опитва да продължи работа дори при грешка, докато `fail-fast` се проваля веднага при първия признак на проблем.",
            "`fail-safe` е по-бърза от `fail-fast`.",
            "`fail-safe` се използва за хардуер, а `fail-fast` за софтуер.",
            "Няма съществена разлика."
        ],
        "correct": 0,
        "rationale": "Fail-fast подходът е предпочитан при тестване и разработка, защото прави бъговете по-лесни за откриване и дебъгване, като ги изкарва наяве възможно най-рано."
    }
];

        let currentQuestionIndex = 0;
        let score = 0;

        // DOM Elements
        const questionNumberEl = document.getElementById('question-number');
        const totalQuestionsEl = document.getElementById('total-questions');
        const scoreEl = document.getElementById('score');
        const questionTextEl = document.getElementById('question-text');
        const answerOptionsEl = document.getElementById('answer-options');
        const nextButton = document.getElementById('next-button');
        const feedbackCardEl = document.getElementById('feedback-card');
        const feedbackTitleEl = document.getElementById('feedback-title');
        const feedbackTextEl = document.getElementById('feedback-text');
        const feedbackIconEl = document.getElementById('feedback-icon');
        const progressBarEl = document.getElementById('progress-bar');
        
        const quizHeader = document.getElementById('quiz-header');
        const questionBody = document.getElementById('question-body');
        const feedbackContainer = document.getElementById('feedback-container');

        const resultsContainer = document.getElementById('results-container');
        const finalScoreEl = document.getElementById('final-score');
        const resultMessageEl = document.getElementById('result-message');
        const restartButton = document.getElementById('restart-button');

        function loadQuestion() {
            // Reset state
            answerOptionsEl.innerHTML = '';
            feedbackCardEl.classList.add('hidden');
            nextButton.classList.add('hidden');

            const currentQuestion = quizData[currentQuestionIndex];
            
            // Populate question data
            const questionNumber = currentQuestionIndex + 1;
            questionNumberEl.textContent = questionNumber;
            totalQuestionsEl.textContent = quizData.length;
            scoreEl.textContent = score;
            questionTextEl.innerHTML = currentQuestion.question;

            // Update progress bar
            progressBarEl.style.width = `${(questionNumber / quizData.length) * 100}%`;

            // Create answer buttons
            currentQuestion.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.innerHTML = `<span class="flex-grow">${option}</span><span class="icon"></span>`;
                button.dataset.index = index;
                button.className = 'answer-option w-full flex items-center text-left p-4 border-2 border-slate-300 rounded-xl hover:bg-slate-50 hover:border-indigo-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 font-medium text-slate-700';
                button.addEventListener('click', selectAnswer);
                answerOptionsEl.appendChild(button);
            });
            answerOptionsEl.classList.add('fade-in');
        }

        function selectAnswer(e) {
            const selectedButton = e.currentTarget; // Use currentTarget to ensure we get the button
            const selectedIndex = parseInt(selectedButton.dataset.index);
            const correctIndex = quizData[currentQuestionIndex].correct;

            answerOptionsEl.classList.remove('fade-in');

            // Disable all buttons
            const allButtons = Array.from(answerOptionsEl.children);
            allButtons.forEach(btn => {
                btn.classList.add('disabled');
            });

            // Check if correct and apply styles
            if (selectedIndex === correctIndex) {
                score++;
                scoreEl.textContent = score;
                selectedButton.classList.add('correct');
                selectedButton.querySelector('.icon').innerHTML = '✔️';
                feedbackTitleEl.textContent = "Правилно!";
                feedbackIconEl.innerHTML = '🎉';
                feedbackCardEl.className = 'p-5 rounded-xl bg-green-50 text-green-800 border-2 border-green-200 fade-in';
            } else {
                selectedButton.classList.add('incorrect');
                selectedButton.querySelector('.icon').innerHTML = '❌';
                
                const correctButton = allButtons[correctIndex];
                correctButton.classList.add('correct');
                correctButton.querySelector('.icon').innerHTML = '✔️';
                
                feedbackTitleEl.textContent = "Грешно!";
                feedbackIconEl.innerHTML = '🤔';
                feedbackCardEl.className = 'p-5 rounded-xl bg-red-50 text-red-800 border-2 border-red-200 fade-in';
            }

            // Show feedback
            feedbackTextEl.textContent = quizData[currentQuestionIndex].rationale;
            feedbackCardEl.classList.remove('hidden');
            
            // Show next button
            if (currentQuestionIndex < quizData.length - 1) {
                nextButton.textContent = "Следващ въпрос";
            } else {
                nextButton.textContent = "Виж резултати";
            }
            nextButton.classList.remove('hidden');
        }

        function showResults() {
             quizHeader.classList.add('hidden');
             questionBody.classList.add('hidden');
             feedbackContainer.classList.add('hidden');
             resultsContainer.classList.remove('hidden');
             finalScoreEl.textContent = score;
             
             const percentage = (score / quizData.length) * 100;
             let message = "";
             if (percentage >= 90) {
                 message = "Брилянтно! Вашите познания са на експертно ниво.";
             } else if (percentage >= 70) {
                 message = "Много добре! Разбирате сложните концепции в дълбочина.";
             } else if (percentage >= 50) {
                 message = "Добър резултат! Имате солидна основа, но продължавайте да учите.";
             } else {
                 message = "Нуждаете се от повече подготовка. Не се отказвайте!";
             }
             resultMessageEl.textContent = message;
        }
        
        function handleNextButtonClick() {
            currentQuestionIndex++;
            if (currentQuestionIndex < quizData.length) {
                loadQuestion();
            } else {
                showResults();
            }
        }
        
        function restartQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            
            resultsContainer.classList.add('hidden');
            quizHeader.classList.remove('hidden');
            questionBody.classList.remove('hidden');
            feedbackContainer.classList.remove('hidden');
            
            loadQuestion();
        }

        nextButton.addEventListener('click', handleNextButtonClick);
        restartButton.addEventListener('click', restartQuiz);

        // Initial load
        loadQuestion();
    </script>
</body>
</html>

