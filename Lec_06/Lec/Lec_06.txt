* Кога да се тества?

	В различните фази на разработка на продукт, един дефект или бъг ще струва различно:
	- По време на дизайн, ако една грешка се открие тук, цената за поправка е минимална (условно 1)
	- По време на разработка, една грешка, за да се оправи, цената и ще бъде 6.5 пъти по-висока
	- По време на тестването, ако се открие грешката, нейното управяне ще струва 15 пъти по-скъпо
	- По време вече на поддръжка, ако дефектът е открит от клиент след пускане на продукт, оправянето му струва 100 пъти повече

	Тоест идеята да тестваме е възможно най-рано и по-често

* Тестване като процес vs тестване като фаза

	Тестване като фаза
	Това е старият, традиционен модел, тестването е просто една фаза от линейн процес, който идва след като разработката е приключила
	Проблема тук е че дефектите се откриват много късно, точно преди пускането на продукта и цената за тяхното управяне е изключително голямо

	Тестването като процес
	Това вече е модерният и по-ефективен подход. Тук тестването не е поредата фаза, а е непрекъснат процес, който се случва паралелно с другите фази от разработка
	Тестването почва още при валидирането на изискванията, планирането на тестове по време на дизайна и тестване на функционалностите веднага щом са готови, а дори и когато продукта влезе в подръжка
	Тук проблеми се решават много по-бързо и се виждат много по-рано, което спестява време и ресурси

* Основни видове тестове

	Някой от следните видове тестове са:
	- ръчни тестове: това са тестовете, при които човек (QA специалист) ръчно взаимойдества с приложението (натисна бутони, въвежда данни) и провервяа дали софтуера работи според очакванията

	- автоматични тестов: това са тестове, в които се използва специални инструменти и скриптове, които се извършват автоматично без човешка намеса, делят се на функционални и нефункционални
	Функционалните тестове проверят дали системата прави това, за което е създадена, тоест тези тестове се фокусират върху конкретните бизнес изисквания
	Нефункционалните тестове проверяват как работи системата и се фокусират върху качества като производителност, сигурност и удобство и други

* Функционални и нефункционални тестове

	Функционалните тестове имат няколко вида:
	- Unit тестове (модулни тестове): тестват най-малките, изоличрани части от кода, примерно тестват една функция
	- Integration тестове (Интеграционни тестове): проверяват дали различните модули работят коректно заедно, след като са били тествани отделно

	Нефункционални тестове има няколко вида:
	- Performance тестове: измерват бързината и отзивчивостта на системата при нормално натоварване
	- Stress тестове: системата се натоварва над нормалния и лимит, за да се видим къде е нейната точка на счупване и как се държи при екстремни условия
	- Crash тестове: проверява се колко добре се възстановява системата след срив
	- Security тестове: целта на този тест е да се открие уязвимоста и някой пробиви в сигурността, за да предпазят системата от хакерси атаки
	- Usability тестове: Оценяват колко лесен, интуитивен и удобен е софтуерът за крайния потребител

* Unit Test

	Отново, най-просто казано unit test е код, който тества друг, малък и изолиран фрагмент от код
	Unit теста изпълнява "атомарна" функционалсност, тоест теста се фокусира върху най-малката възможна логическа част от системата
	Реално в практиката един "unit" тест е често един-единствен метод или функция като целта е да се види дали този метод работи правилно

	Причини защо са важни unit тестовете:
	- Дават гаранция за коректност: това е доказателство, че кодът работи по точно същия начин по който се очаква
	- Предпазна мрежа за бъдещето: unit теста веднага ще покажа, че нещо се е счупило, ако се прави някаква модификация в кода и тя случайно е счупило нещо

* Малко дефиници относно тестовете

	Продуктовия код е истинският код на приложението, това е кода, който върши работата, която потребителите виждат и използват
	Test Coverage-a е процентът, който показва каква част от продуктовия код се проверява от автоматичните тестове. Високото покритие дава увереност, че повечето части на системата работят правилно.

	Test Driven Development-a е техника за програмиране, която първо се пише теста и след това кода, който да го удовлетворява
	Test Fixture е фиксираната начална среда или състояние, което е необходимо, за да може един тест да се изпълни, тогава кара тестава винаги да започва при едни и същи предвидими условия.

* JUnit Framework

	JUnit е най-полулярният и широко използван инструмент (framework) за писане и изпълнение на автоматични тестове в Java.
	Той е de facto стандартния unit testing framework, доста еп риет от програмистите като добър инструмент за unit тестовете

	Този testing framework помага със следните неща:
	- Улеснява писането и изпълненеито на тестове, защото без framework трябва Unit тестовете да се пишат на ръка, докато JUnit прави всичко това вместо програмистта.
	Junit предоставят специални анотации, за който framework-a знае, че е тест, има готови проверки (assertEquals) и автоматично изпълнява всичките тестове

	- Framework-a предоставя добра четимост и предвидимост, лесна поддръжка, а дори и може да се интегрира с други системи за интегриране за автоматизация (CI/CD)

* JUnit

	В основата на JUnit стои анотацията, анотациите се слагат върху части от кода и инструктират JUnit framework-a какво да прави с този код.
	
	Структурирането на един JUnit има проста структура:
	- Test Case: създава се Java клас, чиято единствена цел му е да съдържа тестове, ако например имаш Calculator обект с методи, неговият test case ще е CalculatorTest 
	- Test Method: в този Java клас, който е създаден за тестове, за всяка функционалност, която трябва да се провери, се пише отделен метод
	- Анотацията @Test: За да разбере JUnit че този метод е тест, който трябва да бъде изпълнеен, просто се поставя анотацията @Test над него 
	
	За пример може да видиш Calc.java
	
* Конвенция за именуване 
	
	Името на тестовия клас трябва да е със същото име на класа, който ще тества и добавен суфикс Test накрая
	
	Имената на тестовите методи трябва да почват с test, последвано от името на метода в класа, който ще тестваме, и крактко описания на тестовия случай
	Пример: testLoginWithInvalidUserPassword()
	Имената на теста трябва достатъчно добре и ясно да описват сценария 
	
* Статични методи на Assertions класа 

	Assertion е стъпка във всеки теск, която проверява дали резултатът от някакво действие е такъв, какъвто се очаква
	
	За да не се пишат изцяло ръчно проверки, JUnit предоставя специален помощен клас на име org.junit.jupiteer.api.Assertions, този помощен клас има много помощни статични методи, който правят още по-лесно 
	и удобно писането на unit тестове.
	
	Примерни статични методи, които могат да се намерят в този клас, String meesage във всеки един от тях е незадължителен:
	- fail(String message): този метод винаги проваля теста, може да се слага в код, който мислим, че може би е недостижим 
	
	- assertTrue(boolean condtiion, String message): проверява дали даденото условие е вярно, примерно assertTrue(user.isAdmin(), "The user is actually the admin");
	- assertFalse(boolean condition, String message): проверява дали условието е невярно, примерно assertFalse(user.isAdmin(), "The user is actually not the admin");
	
	- assertNull(Object o): проверява дали подаденият обект всъщност е null
	- assertNotNull(Object o): проверява дали обектът не е null
	
	- assertSame(Object expected, Object actual): провервява дали има равенство по референция
	- assertNotSame(Object expected, Object actual): проверява дали няма равенство по референция 
	
	- assertEquals(Object expected, Object actual): проверява дали два обекта са равни по съдържание използвайки .equals() метода на обектите
	Ако се използва за масиви, това не сравнява съдържанието им, проверява само дали двете референции сочат към един и същи масив в паметта 
	
	- assertEquals(double expected, double actual, double delta): този метод е направен за сравнение на числа с плаваща запетая (double, float)
	delta в случая е позволената грешка или толерансът, тестът си минава ако разликата между двете числа е по-малка от delta 
	
	- assertArrayEquals(Object[] expected, Object[] actual): това вече е правилния метод за сравняване на масиви, проверява дали имат еднаква дължина и дали има един и същи елементи в един и същи ред
	- assertIterableEquals(Iterable<?> expected, Iterable<?> actual): метод за сравняване на колекции, проверява дали две колекции връщат едни и същи елементи в един и същ ред 
	
	Добра практика е винаги обаче да се подава съобщение към асъртите и това съобщение да е подробно и смислено
	
	Виж InvestmentWalletTest.java за пример относно @Test 
	
* Анотациите @BeforeEach и @AfterEach 

	Анотациите @BeforeEаch и @AfterEach управляват жизнения цикъл на тестовете, самите те не са тестове, а се изпълняват всеки път преди и след всеки @Test метод.
	
	Един метод маркиран с @BeforeEach се изпълнява преди стартирането на всеки отделен @Test метод в класа.
	Неговата работа главно е да:
	- създава нови инстанции на обекти 
	- нулиране на променливите 
	- зараждане на нужните данни в тестовата база данни 
	
	Един метод маркиран с @AfterEach се изпълнява след всеки отделен @Test метод в класа
	Неговата работа е главно да:
	- изтриване на временни файлове 
	- затваряне на връзки към база данни 
	- освобождаване на заети ресурси 
	
* Анотацията @BeforeAll и @AfterAll 

	Това са тестове анотации, които също управляват жизнения цикъл на тестовете, но те се изпълняват само по веднъж за целия тестов клас 
	Главно се използват за подготовка и почистване на ресурси, които се използват между всички методи в класа или тяхното създаване е доста "скъпо"
	
	Един метод маркиран с @BeforeAll се изпълнява един единствен път, преди да е започнал, който и да е @Test в класа 
	Неговата работа е главно да:
	- стартира връзка с базата данни 
	- зареждане на голям конфигурационен файл 
	- стартира външна услига (примерно Docker контейнер) за тестовете 
	Този метод трябва да е static, защото се изпълнява преди да бъде направена инстанция на самия тестов клас 
	
	Един метод с анотация @AfterAll се изпълнява един единствен път, след като всички @Test методи в класа са приключили
	Неговата работа е главно да:
	- затваря връзката към база данни 
	- изтриване на временни данни, създадени още в началото 
	- спиране на стартираната външна услуга 
	Този метод също трябва да е static  
	
* Ред на изпълнение 

	JUnit не гарантира в какув ред ще се изпълнят @Test методите, могат или да се изпълнят в реда на тяхното записване или по азбучен ред
	Поради тази причина, добрият написан тест трябва да е независим от други, с други думи не трябва да разчита на тест, който трябва да мине преди него.
	Всеки тест трябва да е себедостатъчен, да може да подготви сам средата си и да почиства след себе си, затова се използват много @BeforeEach и @AfterEach 
	
	Въпреки това JUnit предоставя възможност за изрично зададен ред на изпълнението на тестовете, обаче трябва да се използва внимателно и в специфични случай 
	Процесът за подаване на ред е от 2 стъпки:
	- на ниво клас се слага анотацията @TestMethodOrder(MethodOrder.OrderAnnotataion.class), тя казва на JUnit, че в този клас редът на методите ще се определя от друга анотация
	- на ниво метод трябва да се сложи анотацията @Order(<number>) и се подава число вътре в анотацията, тестовете почват от най-млакото число до най голямото 
	
	Виж OrderNumbterTest.java 
	Използването на такива тестове е признак на лош дизайн, ако тестовете трябва да се пускат в определен ред, означава, че са зависими един от други 
	Въпреки това има полезни ситуации в които се използват:
	- Интеграциоони или End-to-End тестове: когато се тества цялостен потребителски сценарии (първо да влезе в сайта, да купи продутк)
	
	Може да подредим самите елементи по лексикографски ред чрез анотацията @TestMethdOrder(MethodOrderer.MethodName.class) и @Test 
	Виж OrderNameTest.java
	
	
	
	